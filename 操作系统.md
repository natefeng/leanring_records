# ![https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226150619202](\image-20201226150619202.png)操作系统

## 操作系统的概念

![image-20201214205203892](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201214205203892.png)

给上面的用户程序提供服务

系统软件

![image-20201214205406637](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201214205406637.png)

## 操作系统的功能和目标

![image-20201214205526780](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201214205526780.png)

作为系统资源的管理者，用户与计算机硬件之间的接口，作为最接近硬件的层次 都需要实现什么功能呢？

![image-20201214205937988](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201214205937988.png)

处理及管理，设备管理，文件管理，存储器管理

![image-20201214210051465](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201214210051465.png)

![image-20201214210221166](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201214210221166.png)

交互式命令接口，用户说一句 操作系统做一句

![image-20201214210315508](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201214210315508.png)

说一堆，操作系统做一堆

![image-20201214210527181](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201214210527181.png)

联机，脱机 练级单，脱机堆，程序接口=系统调用 用户必须通过程序间接使用

## 操作系统的特征

并发，共享，异步，虚拟 其中并发和共享是最基本的特征，两者互为存在条件

### 并发

![image-20201214211643882](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201214211643882.png)

![image-20201214211905796](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201214211905796.png)

### 共享

共享即资源共享，是指系统中的资源可供内存中多个并发程序的进程共同使用

![image-20201214212546153](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201214212546153.png)

### 并发和共享的关系

![image-20201214212745839](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201214212745839.png)

### 虚拟

![image-20201215201220585](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215201220585.png)

![image-20201215201320159](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215201320159.png)

空分复用技术和时分复用技术

![image-20201215201431347](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215201431347.png)

### 异步

![image-20201215201805186](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215201805186.png)

## 操作系统的发展和分类

![image-20201215202130270](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215202130270.png)

![image-20201215202442777](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215202442777.png)

![image-20201215202734657](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215202734657.png)

![image-20201215203115262](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215203115262.png)

![image-20201215203306010](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215203306010.png)

![image-20201215203644097](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215203644097.png)

### 分时操作系统

![image-20201215203859311](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215203859311.png)

![image-20201215204214796](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215204214796.png)

![image-20201215204310838](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215204310838.png)	



## 操作系统的运行机制和体系



![image-20201215204436135](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215204436135.png)

### 指令

![](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215204817077.png)

分为特权指令和非特权指令(普通运算指令)

![image-20201215204950303](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215204950303.png)

特权指令只能用核心态来执行

![image-20201215205125138](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215205125138.png)

![image-20201215205232428](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215205232428.png)

### 内核

![image-20201215205527159](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215205527159.png)

操作系统内核一般有时钟管理，原语(CPU切换，设备驱动)，中断处理，进程管理，存储器管理等

![image-20201215205853876](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215205853876.png)

不一定所有的操作系统对内核功能的定义都一样

由此划分为大内核和微内核

![image-20201215210401662](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215210401662.png)

![image-20201215210517534](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215210517534.png)

### 中断和异常

![image-20201215211613599](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215211613599.png)

![image-20201215211952685](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215211952685.png)

![image-20201215212053140](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215212053140.png)

#### 外中断的处理过程

![image-20201215212500455](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215212500455.png)

![image-20201215212655636](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201215212655636.png)

### 系统调用

![image-20201216203943830](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216203943830.png)

![image-20201216204137216](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216204137216.png)

![image-20201216204350448](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216204350448.png)

### 系统调用和库函数的区别

![image-20201216204917168](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216204917168.png)

![image-20201216205219769](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216205219769.png)	

### 系统调用的背后

![image-20201216205540568](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216205540568.png)

![image-20201216205848707](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216205848707.png)![image-20201216210126225](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216210126225.png)

## 进程

### 进程的定义

![image-20201216210546002](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216210546002.png)

单道程序无进程定义

![image-20201216210834042](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216210834042.png)

多道程序可以并发执行后,才引入了进程和进程实体的概念 因为操作系统要管理并发执行的程序 

操作系统会为每个程序分配一个数据结构,称为程序控制块(PCB),用来记录进程的各种信息如(程序段和数据段) 程序段是指程序被编译后的指令序列,数据段则是存放一些比如定义的变量信息等

PCB丶程序段丶数据段三部分构成了进程实体

![image-20201216211632768](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216211632768.png)

进程是动态的,进程实体是动态的

进程可以认为是程序的一次执行过程,也可以认为是程序以及数据在处理器顺序执行的过程	

### 进程的组成

![image-20201216211843526](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216211843526.png)

PCB1存放的是操作系统对进程管理所需要的各种信息

![image-20201216212123248](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216212123248.png)PCB的组成一般有

进程描述信息,资源分配清单(程序段指针,数据段指针),进程控制和管理信息

进程标识符PID,在进程被创建时分配

创建进程其本质是创建PCB  关闭进程本质是撤销进程实体中的PCB

![image-20201216212447161](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216212447161.png)

### 进程的组织

注重于组织多个进程,因为PCB太多了

![image-20201216212617254](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216212617254.png)

分为链接方式和索引方式

链接方式是按照进程状态分为多个队列

索引方式是按进程状态分为多个索引表

![image-20201216212918357](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216212918357.png)

### 进程的特征

![image-20201216213147809](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216213147809.png)

![image-20201216213155695](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201216213155695.png)

独立单位噢

PCB是进程存在的唯一标志

## 进程的状态与切换

![image-20201217203641261](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217203641261.png)

三种基本状态，运行态，就绪态，阻塞态

![image-20201217203938625](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217203938625.png)

![image-20201217204349680](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217204349680.png)

![image-20201217204449412](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217204449412.png)

## 进程控制

![image-20201217204717157](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217204717157.png)

![image-20201217205215104](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217205215104.png)

防止PCB内容与队列所处的位置不一致

![image-20201217205514815](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217205514815.png)

### 创建原语

![image-20201217205811308](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217205811308.png)

![image-20201217205932680](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217205932680.png)

![image-20201217210052704](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217210052704.png)

![image-20201217210218577](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217210218577.png)

![image-20201217210306053](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217210306053.png)

## 进程通信

![image-20201217210459646](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217210459646.png)

![image-20201217210821700](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217210821700.png)

![image-20201217211103135](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217211103135.png)

### 管道通信

![image-20201217211502865](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217211502865.png)

![image-20201217211829593](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217211829593.png)

![image-20201217211839123](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217211839123.png)





## 线程

![image-20201217212358957](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217212358957.png)

多线程更在意的是应用里面的  进程而是程序的一次执行，比如QQ

![image-20201217212712424](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217212712424.png)

线程是基本的CPU执行单元，也是程序执行流的最小单位

![image-20201217212921438](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217212921438.png)

![image-20201217212938959](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201217212938959.png)

![image-20201219124824179](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219124824179.png)

### 线程的属性

![image-20201219125050148](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219125050148.png)

线程是处理机调度的基本单位，进程是系统资源分配的基本单位，同一进程的多个线程共享进程的资源，不同进程中的线程切换会引起进程切换，同一进程中的线程切换，不会引起进程切换	 

### 线程的实现方式

![image-20201219125352245](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219125352245.png)

用户级线程的线程切换都是由应用程序切换的，所以对操作系统来说只能看到进程，对操作系统透明，用户线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责

用户级线就是从用户视角能看到的线程

![image-20201219125703333](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219125703333.png)

内核级线程 由操作系统进行线程的切换和管理，内核级线程的切换必然需要在核心态下完成

![image-20201219125857440](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219125857440.png)

重点：内核级线程才是处理机分配的基本单位

### 多线程模型

![image-20201219130158464](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219130158464.png)

多对一模型 ，多个用户级线程映射到一个内核级线程，每个用户线程只对应一个内核级线程

不需要切换到核心态，效率高。 但是当线程被阻塞并发度低

![image-20201219130406827](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219130406827.png)

java好像就是一对一模型，一个用户级线程映射一个内核级线程 

![image-20201219130620551](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219130620551.png)

多对多模型，n用户级线程映射到m个内核级线程 n>= M

![image-20201219130659294](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219130659294.png)

## 处理机调度

![image-20201219135935051](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219135935051.png)

调度的基本概念

![image-20201219140207338](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219140207338.png)

处理机调度就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行

![image-20201219140540910](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219140540910.png)

高级调度

内存空间有限，不能一次全部读入，需要按照某种规则进行调入，调入会建立相应的PCB，调出会撤销PCB

### 中级调度

![image-20201219141019490](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219141019490.png)

引入了虚拟存储技术后，可将暂时不能执行的进程调至外存等待，增加内存利用率和吞吐量

但是PCB不会被调入到外存，因为还存放这各种信息，被调入外存的进程在合适的时机还要调入，在进程中称为挂起，而挂起的进程PCB会被放到一个挂起队列中，中级调度就是决定哪个挂起状态的进程重新调入内存

一个进程可能会被多次挂起，调入，所以中级调度发生频率比高级调度高

![image-20201219141610057](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219141610057.png)

挂起态是将进程实体调到外存PCB还在，阻塞态而是进程映像还在内存中

![image-20201219141810466](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219141810466.png)





### 三层调度对比

![image-20201219142022210](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219142022210.png)

![image-20201219142111016](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219142111016.png)

### 进程调度的时机

![image-20201219142307771](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219142307771.png)

![image-20201219142555569](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219142555569.png)

![image-20201219143102040](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219143102040.png)

![image-20201219143143210](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219143143210.png)

### 进程调度的方式

![image-20201219143336545](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219143336545.png)

抢占式调度和非抢占式调度  非抢占式只能主动![image-20201219143824447](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219143824447.png)

![image-20201219143833120](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219143833120.png)

![image-20201219143951027](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219143951027.png)

## 调度算法的评价指标

![image-20201219144038819](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219144038819.png)	

要明白为什么 并且学会计算

### CPU利用率

![image-20201219144244534](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219144244534.png)

![image-20201219144355953](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219144355953.png)

### 周转时间

![image-20201219144712976](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219144712976.png)

是指作业被提交到作业被完成的这段时间间隔

对于操作系统来说 更关心整体

周转时间= 作业运行时间-作业提交时间

![image-20201219145444845](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219145444845.png)

带权周转时间 = 周转时间/作业运行的时间

平均带权周转时间= 各作业带权周转时间之和/作业数

![image-20201219145831148](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219145831148.png)

![image-20201219145909703](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219145909703.png)

![image-20201219145915825](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219145915825.png)

## 调度算法FCFS SJF HRRN

![image-20201219150301892](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219150301892.png)

各种算法要想的东西

### 先来先服务

![image-20201219151828131](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219151828131.png)

![image-20201219152148944](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219152148944.png)

### 短作业优先算法

![image-20201219152627813](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219152627813.png)

![image-20201219153237123](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219153237123.png)

![image-20201219153604476](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219153604476.png)

![image-20201219153756547](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219153756547.png)

会饿死  太恐怖啦  有抢占式也有非抢占式的

### 高响应比优先算法

![image-20201219155656796](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219155656796.png)

![image-20201219155824142](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219155824142.png)

结合了先来先服务和短作业优先算法的优点![image-20201219160007522](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219160007522.png)

适合于早期的批处理系统

## 时间片轮转 优先级 多级反馈队列 调度算法

![image-20201219160237524](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219160237524.png)

### 时间片轮转算法

![image-20201219161350869](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219161350869.png)

![image-20201219161516541](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219161516541.png)

![image-20201219162555762](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219162555762.png)

### 优先级调度算法

![image-20201219163054067](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219163054067.png)

![image-20201219163449771](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219163449771.png)

![image-20201219164003931](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219164003931.png)

![image-20201219164059952](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219164059952.png)

![image-20201219164155780](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219164155780.png)

### 多级反馈队列算法

![image-20201219165120322](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219165120322.png)

设置多个就绪队列 优先级从高到低  时间片分配由小到大

只有K级队列为空，k+1级队列头的进程才会被调度

![image-20201219165647455](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219165647455.png)

![image-20201219165814049](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219165814049.png)

## 进程同步

![image-20201219171951248](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219171951248.png)

![image-20201219172454319](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219172454319.png)

进程异步相当于各并发的进程可以不按照一定次序来进行

在某些情况下需要完成某种次序，并且次数不可以被打乱 那么就需要进程同步

比如上图的管道  写数据必须先写 读数据才能后读

### 进程互斥

![image-20201219172822896](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219172822896.png)

![image-20201219173118357](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219173118357.png)

![image-20201219173342959](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219173342959.png)

遵守的四个原则

空闲让进，忙则等待，有限等待，让权等待![image-20201219173518414](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219173518414.png)

## 进程互斥的软件实现方法

![image-20201219173800407](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201219173800407.png)

![image-20201222124820138](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201222124820138.png)

![image-20201222125020139](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201222125020139.png)

![image-20201222125030121](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201222125030121.png)

违背了空闲让进原则

![image-20201222125608774](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201222125608774.png)

双标志先检查法，违反了忙则等待  两个进程可以同时访问临界区

![image-20201222125904303](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201222125904303.png)

违法空闲让进和有限等待

![image-20201222130604806](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201222130604806.png)

Pertersion算法 皮特森算法

![image-20201222130914716](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201222130914716.png)

遵循了空闲让进，忙则等待，有限等待资源

![image-20201222130949402](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201222130949402.png)

## 进程互斥的硬件实现方法



![image-20201223123633312](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201223123633312.png)

![image-20201223124248179](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201223124248179.png)

![image-20201223124808694](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201223124808694.png)

硬件一般都会造成忙等 也就是CPU一直自旋 占用资源

中断屏蔽只适用于单处理机，并且还只能在核心态下执行 很危险

SWAP指令和TSL很类似 都是硬件实现 上面是给出的C语言逻辑抽象实现

相当于让上锁和检查拥有原子性，相当于就是先拿出旧值，然后设置值为true代表占用锁，返回旧值

## 信号量

![image-20201223132631290](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201223132631290.png)

![image-20201224131622036](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201224131622036.png)

![image-20201224131933626](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201224131933626.png)

![image-20201224132318469](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201224132318469.png)

![image-20201224132919260](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201224132919260.png)

记录性，主要是加入了队列 当资源没了会调用block原语进行自我阻塞 运行态-阻塞态

不会出现忙等非常棒棒 

调用wake up 原语唤醒阻塞队列中的第一个进程

![image-20201224133151199](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201224133151199.png)

![image-20201224133201507](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201224133201507.png)

### 信号量实现进程互斥

![image-20201224201011223](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201224201011223.png)

### 信号量实现进程同步

进程同步是指由于并发出现的异步性代码顺序执行不确定想要让其以正确的顺序来执行实现的

![image-20201224201958601](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201224201958601.png)

![image-20201224202529379](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201224202529379.png)

![image-20201224202540701](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201224202540701.png)

## 生产者和消费者问题

![image-20201226135647738](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226135647738.png)

![image-20201226140254500](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226140254500.png)

箭头指向的是实现进程同步的 也就是说一个操作必须在另外一个操作之前进行 V操作首先需要添加产品P操作才能取走产品

![image-20201226140720044](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226140720044.png)

![image-20201226140933636](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226140933636.png)

生产者消费者需要3个信号量 互斥+双同步

## 多生产者多消费者问题

![image-20201226141332091](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226141332091.png)

![image-20201226142027983](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226142027983.png)

![image-20201226142429580](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226142429580.png)

![image-20201226142720248](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226142720248.png)

可以省略 ![image-20201226142823237](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226142823237.png)

![image-20201226142948786](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226142948786.png)

如果盘子容量为2那么就会造成可能多个进程同时写造成资源覆盖，所以必须加入同步 上面是因为资源数只有1

![image-20201226143619731](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226143619731.png)

一定要以分析事件来分析信号量，不能以进程的行为分析，那么可能会造成非常复杂

## 吸烟者问题

![image-20201226144100018](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226144100018.png)

![image-20201226144611396](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226144611396.png)

![image-20201226144811492](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226144811492.png)

![image-20201226145240515](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226145240515.png)	

## 读者写者问题

![image-20201226150200353](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226150200353.png)

![image-20201226150600805](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226150600805.png)

![image-20201226150625606](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226150625606.png)

![image-20201226151604057](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226151604057.png)

进程之间的读写者解决方法，也非常经典，使用计数器来让第一个读进程加锁，最后一个读进程解锁

读写互斥 还有点问题  因为上面的问题没有考虑到大量读和一个写的情况 会造成一直读 因为count一直不为0 造成写者饿死 

![image-20201226151724834](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226151724834.png)

![image-20201226152355522](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226152355522.png)

上面的改进代码每次都优先判断有没有写进程开始写 如果有则会停止继续向下读

![image-20201226152748857](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226152748857.png)

![image-20201226152755508](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226152755508.png)

写读写 会公平

核心思想就是设置了一个**count计数器**

![image-20201226153028294](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226153028294.png)

## 哲学家进餐问题

![image-20201226153550396](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226153550396.png)

解决的是如何巧妙的避免死锁的问题

其中的一个解决方案

![image-20201226153821966](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226153821966.png)

不合理 因为如果多个线程一起并发抢左手的筷子 那么就会出现都在等待 造成死锁

![image-20201226154021543](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226154021543.png)

第二种方案则是最多只允许4个哲学家同时进餐，那么就会保证至少有一个人可以出现拿到两只筷子 那么就不会出现死锁问题![image-20201226155334668](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226155334668.png)

方法可行 但是其实会造成资源浪费 因为可能有的哲学家左右都有筷子也无法吃饭

## 管程

![image-20201226155803213](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226155803213.png)

### 为什么要引入管程

![image-20201226160024329](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226160024329.png)

因为使用信号量PV操作会使得程序编写困难，必须要注意程序的顺序问题，加锁问题

所以引入了管程的概念，类似于高级的同步机制

上图比如说先执行123操作 那么就会造成死锁，因为如果缓冲区不是空的 开始执行12操作 2操作会阻塞造成等待消费者的V操作 此时发生进程切换 3操作也会进入等待 造成死锁

### 管程的定义和基本特征

![image-20201226161211451](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226161211451.png)

管程的组成部分，需要有共享数据结构，对该数据结构进行操作的一组过程，对该共享数据结构设置初始化的语句

基本特征：管程中的共享数据结构只能由对该数据结构进行操作的一组过程来访问，并且访问过程这一操作只能允许一个进程执行

![image-20201226162432963](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226162432963.png)

上面就是对管程的一系列定义，都由解释器完成加锁，互斥，唤醒 ![image-20201226162840813](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226162840813.png)

![image-20201226163053287](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226163053287.png)

### 知识回顾

![image-20201226163108597](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226163108597.png)

管程其实就是为了实现同步更加方法设计的

## 死锁

![image-20201226164549399](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226164549399.png)

![image-20201226164920495](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226164920495.png)

本质上就是并发环境下互相等待双方持有的资源而陷入的一种现象

![image-20201226165612349](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226165612349.png)

三者的区别

### 死锁产生的必要条件

![image-20201226170624589](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226170624589.png)

互斥条件，必须是对互斥资源进行访问，对资源争夺会导致死锁

以上的条件必须同时满足才会发生死锁

不剥夺条件：进程所获得的资源只能主动释放不能被掠夺

请求和保持条件：在进程拥有一个共享资源的同时又对其他进程占有的资源进行访问，但又对自己的资源不妨

循环等待条件：存在一种进行之间的互相等待链，比如java中的锁 我等待你释放一个锁，你又等待我释放一个锁，那么就会造成循环等待

注意：如果发生死锁了一定会发现循环等待，但是如果发生循环等待了则不一定会发生死锁

循环等待是死锁的必要不充分条件，如果同类资源数只有1那么循环等待就是死锁的充分必要条件了

![image-20201226171320167](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226171320167.png)

### 死锁的处理策略

![image-20201226171540176](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226171540176.png)

预防，避免，检测和解除

避免：银行家算法， 

![image-20201226171703516](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226171703516.png)

![image-20201226171937217](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226171937217.png)

破坏互斥条件

![image-20201226172216910](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226172216910.png)

改用SPOOLing技术 相当于其实就是加了个队列 然后依次取出队列中的进程进行访问而已

![image-20201226172413604](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226172413604.png)

但是有问题 因为有些地方必须使用互斥

#### 不剥夺条件

![image-20201226172758146](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226172758146.png)

缺点很多，比较使用于容易保存和恢复的资源 如CPU

#### 破坏请求和保持条件

![image-20201226173202097](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226173202097.png)

会导致进程饥饿 如果有源源不断的A类和B类线程访问资源 那么C类进程会饥饿，因为C类进行必须等待两个资源都没有被占用才可以使用，所以说资源利用率很低，因为有的资源会一直空闲

![image-20201226173928736](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226173928736.png)

破坏循环等待条件也不可取，因为不可能有每个进程满意的所有编号

![image-20201226173959168](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201226173959168.png)

都有缺陷

#### 预防死锁不太行

### 动态策略

![IMG_0777](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0777-1609144671898.PNG)

避免死锁，使用安全序列

![IMG_0778](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0778.PNG)

![IMG_0779](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0779.PNG)

![IMG_0780](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0780.PNG)

安全序列是指系统按照这种序列分配资源，则每个资源都额能顺利完成，只要能找出一个安全序列，系统就是安全状态，当然安全序列可能有多个

如果分配了资源以后，系统找不到任何一个安全序列，那么系统就进入了不安全状态，不安全状态可能会导致死锁，但是不是一定会导致死锁，但是死锁一定发生在不安全状态下

![IMG_0783](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0783.PNG)

#### 银行家算法

![IMG_0788](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0788-1609144838927.PNG)

用于避免死锁，先判断此次分配是否会导致系统进入不安全状态，如果会，则不答应该次请求，该进程先阻塞等待，让可以完全拿到资源的进程先执行

![IMG_0789](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0789.PNG)

找出一个安全序列，使得可以满足某个进程的需求，然后依次判断

![IMG_0790](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0790.PNG)

![IMG_0792](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0792.PNG)

系统可以设置最大需求数，每个最大需求数存放的是各个资源需要的数，还有已分配数组，最多还需要的，系统可用的 然后根据逻辑依次相减计算出是否是安全序列

![IMG_0793](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0793.PNG)

先判断，然后判断资源能否满足某个进程的最大需求，

### 死锁的检测

​	![IMG_0794](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0794-1609145173765.PNG)

为了能对系统是否发生死锁进行检测，需要用某种数据结构来保存资源的请求和分配信息

资源节点对应一类资源，进程节点对应一个进程

![IMG_0795](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0795.PNG)

如果不能消除所有边，这边连接的进程就发生了死锁

![IMG_0797](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0797.PNG)

找出既没有阻塞也不是孤点的进程，消去它的请求边和分配边，使其称为孤立的节点，如果边全部可以消除，则未发生死锁

### 死锁的解除

​	

![IMG_0798](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0798.PNG)

一般有三种方法，资源剥夺法，撤销进程法，进程回退法

决定对谁动手，一般会根据进程的优先级(对低的动手)，已执行多长(执行短的动手)，还要多久完成等等

# 内存

## 什么是内存

![IMG_0801](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0801-1609145594896.PNG)

![IMG_0802](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0802.PNG)

![IMG_0803](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0803.PNG)

## 逻辑地址和物理地址

![IMG_0804](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0804-1609145638878.PNG)

![IMG_0805](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0805.PNG)

一般如C语言将用户程序编译后，然后形成多个目标模块，形成多个逻辑地址，再装入

![IMG_0806](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0806.PNG)

物理地址一般=逻辑地址+起始地址

![IMG_0807](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0807.PNG)

装入的三种方式

绝对装入 ，在编译的时候就确定了物理地址，直接转换

静态重定位，在装入的时候确认物理地址，然后转换

动态重定位：在运行的时候根据基址寄存器给出的起始地址，动态访问

![IMG_0808](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0808.PNG)

编译之后就产生绝对地址的目标代码，![IMG_0809](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0809.PNG)

运行期间不可以移动，也不能申请内存空间

![IMG_0810](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0810.PNG)

把地址转换推迟到真正运行的时候，装入内存的所有地址依然是逻辑地址，这种方式需要一个重定位寄存器：存放装入模块存放的起始位置

可以根据用户运行期间动态改变重定位寄存器的值，动态申请分配内存

![IMG_0811](D:\Program Files (x86)\qq\MobileFile\IMG_0811.PNG)

链接也有三种方式，静态链接，装入时动态链接，运行时动态链接

静态链接：在程序运行之前，将各模块以及所需要的库函数连接成一个完整的可执行文件

装入时动态链接：在各目标模块装入内存时，边装入边链接的方式

运行时动态链接，在程序种执行时需要该目标模块的时候，才对它进行链接

![IMG_0812](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0812.PNG)

## 内存的分配与回收

![IMG_0818](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0818.PNG)

![IMG_0819](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0819.PNG)

![IMG_0820](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0820.PNG)

内存保护，保证各进程之间数据安全，不会越界访问 

可设置一对上下限寄存器

![IMG_0821](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0821.PNG)

可采用重定位寄存器和届地址寄存器，重定位存放物理地址的起始地址，界地址寄存器存放逻辑的最大地址![IMG_0822](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0822.PNG)

### 覆盖技术

![IMG_0823](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0823-1609147745371.PNG)

![IMG_0824](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0824.PNG)

让其共享一段内存区域，因为某程序如果有类似if判断，只会进入其中之一，则选择最大的内存大小设置为共享区域![IMG_0825](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0825.PNG)

交换技术就是将某个进程先调出外存，中级调度

![IMG_0826](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0826.PNG)

外存对于电脑来说都是磁盘，一般磁盘都会将空间分为对换区和文件区，当需要进行中级调度的时候，会将进程调入对换区，但是进程的PCB块不调入，对换区追求速度采用连续分配方式

![IMG_0827](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0827.PNG)

### 单一连续分配

![image-20201228124307960](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228124307960.png)

单一内存分配，存储器利用率极低，只适合单任何的操作系统，有内部碎片 通常会把内存分为系统区和用户区，系统区存放操作系统相关的数据

### 固定分区分配

![image-20201228124740634](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228124740634.png)

支持多道批程序的系统，分区一般分为大小相等和大小不等，相等灵活性低，但是适合相同的程序并发执行，大小不等灵活性增加

![image-20201228125215627](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228125215627.png)

操作系统会建立一个数据结构--分区说明表，说明每个分区的容量和是否已被分配过，当要增加用户程序的时候会判断要从该该数据结构中找出满足用户容量的并且未被分配的

缺点是：有内部碎片，并且如果程序很大需要通过覆盖技术来解决，又会影响性能

### 动态分区分配

![image-20201228125701563](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228125701563.png)

会在进程每次装入内存的时候，根据进程的大小动态的建立分区，动态分区分配又被称为可变分区分配

![image-20201228125912743](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228125912743.png)

空闲分区表和空闲分区链



![image-20201228130023614](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228130023614.png)

当有多个空闲分区的时候，如何选择？ 选择最大的分区就行分配还是最小的呢？ 这需要涉及动态分区分配算法![image-20201228130219549](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228130219549.png)

![image-20201228130305632](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228130305632.png)

上面是分配

下面是回收

![image-20201228130413345](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228130413345.png)

回收如果有相邻，则合并

![image-20201228130533536](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228130533536.png)

![image-20201228130512712](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228130512712.png)

当前后都有空闲区，则合并前后和自己，三个为一个

![image-20201228130623484](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228130623484.png)

前后都没有，则添加表项

![image-20201228130645099](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228130645099.png)

![image-20201228130922620](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228130922620.png)

内部碎片：指分配给进程中的内存区域，有些部分没有用到

外部碎片：指内存的中的空闲分区由于太小而难以利用

上图20MB无法找到连续的内存空间进行分配，哪怕内存中还有20MB的内存空间可以使用，但是由于都是外部碎片，所以不可以

解决方法一般采用紧凑，将内存数据移位

![image-20201228131120959](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228131120959.png)

使用中级调度将进程进行调入调出

![image-20201228131250082](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201228131250082.png)

### 动态分区分配算法

![image-20201229203011297](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229203011297.png)

![image-20201229203245931](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229203245931.png)

按照容量大小从小到大递增排序![image-20201229203737258](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229203737258.png)

会产生外部碎片

![image-20201229203939725](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229203939725.png)

最坏适应算法，从大到小进程排序，优先分配内存大的空间，使得外部碎片减少

![image-20201229204029339](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229204029339.png)

如果有大进程那么就有问题

![image-20201229204723871](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229204723871.png)

**可以看出上面四种动态分区分配算法，反而是首次适应算法的效果最好，因为会优先使用低地址的小分区，留下高地址的大分区，最佳适应算法的优点，邻近适应算法也称为(循环首次适应算法)，额外记录上次访问的位置从上次访问的位置开始查找，减少对低地址的访问，因为低地址有很多小分区，但是也有最坏适应算法的缺点，无大分区可用。**

最佳适应算法的缺点是造成很多的外部碎片，无法利用

![image-20201229205050870](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229205050870.png)

### 连续分配方式的缺点

![image-20201229205442176](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229205442176.png)

支持多道程序的两种连续分配方式

固定分区产生内部碎片，动态分区产生外部碎片，紧凑的时间代价很高，非连续分配方式

![image-20201229205549268](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229205549268.png)

非连续分配可以是分散的内存方式

## 基本分页存储管理

![image-20201229205920220](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229205920220.png)

拆分，把内存分为一个个相等的小分区，越小内部碎片会更小，内存利用率会更高，再按照进程大小把分区拆分成一个个小部分

### 分页存储管理的基本概念

![image-20201229210312897](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229210312897.png)

内存空间划分为相等的分区，每一个分区就是一个页框，页帧，内存块，物理块，每个页框有一个编号，称为页框号，物理块号等

将用户进程的地址空间也分为与页框大小相等的一个个区域，称为页，页面，将页装入页框，与之一一对应

![image-20201229210534310](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229210534310.png)

![image-20201229210742355](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229210742355.png)

偏移量-》逻辑地址

![image-20201229211140573](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229211140573.png)

物理地址= 页面起始地址+页面内偏移量

需要计算出逻辑地址对应的页号，需要知道每个页号在内存当中的起始位置，需要知道逻辑地址在页面内的偏移量，偏移量是相对于页的起始地址而言的

![image-20201229211624863](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229211624863.png)

页号=逻辑地址/页面长度

页内偏移量=逻辑地址 % 页面长度

二进制更快，因为2进制的&操作直接基于内存，

![image-20201229212656894](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201229212656894.png)

可以看出，红色高20位的值可以代表页面，黑色部分可以代表偏移量

如果逻辑地址为4097 

那么4097%4096 = 1； 在二进制中直接就是高20位结果就是1，低12位代表页内偏移地址

则逻辑地址4097对应的物理地址应该是 X+000000000001	

### 逻辑地址结构

![IMG_0880](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0880.PNG)

![IMG_0881](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0881.PNG)

### 页表

![IMG_0882](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0882.PNG)

、![IMG_0883](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0883.PNG)

![IMG_0884](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/IMG_0884.PNG)

## 基本地址变换机构

![image-20210111124259745](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124259745.png)

![image-20210111124351295](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124351295.png)

![image-20210111124407528](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124407528.png)

![image-20210111124436179](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124436179.png)

![image-20210111124444993](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124444993.png)

![image-20210111124529588](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124529588.png)

## 具有块表的地址变化机构

![image-20210111124624737](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124624737.png)

![image-20210111124703528](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124703528.png)

![image-20210111124713150](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124713150.png)

![image-20210111124721809](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124721809.png)

## 两级页表

![image-20210111124731289](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124731289.png)

![image-20210111124742708](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124742708.png)

![image-20210111124747468](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124747468.png)

![image-20210111124752958](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124752958.png)

![image-20210111124758791](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124758791.png)

![image-20210111124815720](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124815720.png)



![](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124823005.png)

## 基本分段管理

![image-20210111124905874](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124905874.png)

![image-20210111124921320](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124921320.png)

![image-20210111124930417](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124930417.png)

![image-20210111124938857](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124938857.png)

![image-20210111124943860](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124943860.png)

![image-20210111124950584](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124950584.png)

![image-20210111124955772](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111124955772.png)

![image-20210111125000548](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125000548.png)

![image-20210111125006405](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125006405.png)

![image-20210111125011558](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125011558.png)

![image-20210111125034758](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125034758.png)

![image-20210111125044905](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125044905.png)

## 段页式管理

![image-20210111125018847](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125018847.png)

![image-20210111125114473](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125114473.png)

![image-20210111125119667](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125119667.png)

![image-20210111125125412](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125125412.png)

![image-20210111125133323](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125133323.png)

## 虚拟内存

![image-20210111125214109](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125214109.png)

![image-20210111125234597](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125234597.png)

![image-20210111125249079](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125249079.png)

![image-20210111125258716](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125258716.png)

![image-20210111125310585](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125310585.png)

![image-20210111125319767](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125319767.png)

![image-20210111125328569](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125328569.png)

![image-20210111125334622](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125334622.png)

![image-20210111125344302](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125344302.png)

![image-20210111125349536](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125349536.png)

![](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125407786.png)

![image-20210111125402462](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125402462.png)

![image-20210111125424261](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125424261.png)

![image-20210111125442814](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125442814.png)

![image-20210111125447540](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125447540.png)

### 页面置换算法

![image-20210111125459564](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125459564.png)

![image-20210111125513962](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125513962.png)

![image-20210111125520626](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125520626.png)

![image-20210111125533144](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125533144.png)

![image-20210111125538986](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125538986.png)

![image-20210111125543663](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125543663.png)

![image-20210111125548369](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125548369.png)

![image-20210111125554155](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125554155.png)

![image-20210111125559412](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125559412.png)

### 页面分配策略

![image-20210111125609455](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125609455.png)

![image-20210111125617571](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125617571.png)

![image-20210111125623381](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125623381.png)

![image-20210111125628120](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125628120.png)

![image-20210111125632530](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125632530.png)

![image-20210111125639999](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125639999.png)

![image-20210111125644626](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125644626.png)

![image-20210111125648379](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210111125648379.png)

# 文件的属性





# 文件

![image-20210106194152968](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106194152968.png)

![image-20210106194345362](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106194345362.png)

文件可以分为无结构文件和有结构文件 

记录式文件  数据项是文件新系统中最基本的数据单位 由一个个记录组成 而一个记录又由数据项组成

![image-20210106194544632](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106194544632.png)

![image-20210106194707048](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106194707048.png)![image-20210106194926122](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106194926122.png)

![image-20210106194931342](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106194931342.png)

![image-20210106195230901](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106195230901.png)

外存和内存一样 都呗分为一个个物理块，也需要从逻辑地址转换为物理地址

![image-20210106195325883](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106195325883.png)

![image-20210106195431927](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106195431927.png)

## 文件的逻辑结构

![image-20210106195833793](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106195833793.png)![image-20210106195927843](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106195927843.png)

![image-20210106200048386](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106200048386.png)

![image-20210106200225417](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106200225417.png)

![image-20210106200237830](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106200237830.png)

![image-20210106200453571](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106200453571.png)

![image-20210106212246753](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210106212246753.png)

![image-20210109164031441](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109164031441.png)

![image-20210109164507559](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109164507559.png)

###  多级索引顺序文件

![image-20210109164647380](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109164647380.png)

建立多级索引表 提高查询效率 

假设有1000000个记录 如果分为1000组 1000组里面又有1000个记录 那么平均查找次数就为1000次 还是很多 

如果要提高查询效率 分三级

顶级索引表按照规则分100组 100组里面每一组对应一个低级索引表也是100个，低级索引表每一个对应1个记录 那么查找的效率提高很多 平均查找次数只有 50+50+50 150  相比于1000次快了不要太多

![image-20210109165012182](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109165012182.png)

![image-20210109165207982](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109165207982.png)	

## 文件目录

![image-20210109165330657](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109165330657.png)

![image-20210109165439332](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109165439332.png)

![image-20210109171220709](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109171220709.png)

![image-20210109171846304](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109171846304.png)

最重要的FCB就是物理位置和文件名

![image-20210109171914705](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109171914705.png)

![image-20210109172125562](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109172125562.png)

![image-20210109172301478](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109172301478.png)

![image-20210109172616866](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109172616866.png)	

![image-20210109172901459](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109172901459.png)

![image-20210109173032188](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109173032188.png)

![image-20210109173935002](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109173935002.png)

为了方便实现文件之间的共享采用无环图目录结构 每次删除不会真正删除 会将共享文件的引用计数器-1 直到为0才删除![image-20210109174400677](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109174400677.png)

![image-20210109174452461](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109174452461.png)

![image-20210109174500219](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109174500219.png)

## 文件的物理结构

![image-20210109175402045](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109175402045.png)

![image-20210109175442867](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109175442867.png)	![image-20210109175800947](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109175800947.png)

![image-20210109180852746](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109180852746.png)

![image-20210109181121082](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109181121082.png)

![image-20210109181249330](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109181249330.png)

![image-20210109181444297](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109181444297.png)

### 文件分配方式-链接分配

![image-20210109181548860](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109181548860.png)

![image-20210109181857797](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109181857797.png)

![image-20210109182006208](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109182006208.png)

#### 链接分配-显式链接

![image-20210109182341343](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109182341343.png)

![image-20210109182549010](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109182549010.png)

核心就是加载到内存 不需要访问的时候每次读磁盘而已  本质也是读了很多次FAT(文件分配表) 但是由于读取该变很快，只需要找到对应的物理快号 然后再去访问磁盘 所以会快很多而已

![image-20210109182717479](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109182717479.png)

### 索引分配-文件的分配方式

![image-20210109193005323](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109193005323.png)

![image-20210109193217111](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109193217111.png)

![image-20210109193348120](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109193348120.png)

由于索引表是为每个文件创建的并且记录了每个物理快号对应的地址， 如果每个磁盘块1kb，一个索引项4b，那么最多只能存放256个索引项，那么如果一个文件大小超过了256块，那么一个磁盘块装不下文件的整张索引表的，应该如何解决![image-20210109194629364](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109194629364.png)

![image-20210109195412962](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109195412962.png)

![image-20210109195904652](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109195904652.png)

![image-20210109200522786](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109200522786.png)

混合索引无敌

![image-20210109200536036](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109200536036.png)

## 文件的存储空间管理

![image-20210109200812792](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109200812792.png)

已经说过对非空闲磁盘块的管理

![image-20210109200833138](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109200833138.png)

![image-20210109201107266](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109201107266.png)

![image-20210109201605140](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109201605140.png)

![image-20210109201759837](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109201759837.png)

 ### 存储空间管理-空闲链表法

![image-20210109201911977](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109201911977.png)

![image-20210109202049798](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109202049798.png)

![image-20210109202256450](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109202256450.png)

​	![image-20210109202729319](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109202729319.png)

![image-20210109203040192](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109203040192.png)

### 成组链接法

![image-20210109203225020](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109203225020.png)

![image-20210109204027511](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109204027511.png)

![image-20210109204532299](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109204532299.png)

![image-20210109204832768](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210109204832768.png)

## 文件的基本操作

![image-20210110143930881](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110143930881.png)

![image-20210110144201415](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110144201415.png)

![image-20210110144316382](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110144316382.png)![image-20210110144947540](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110144947540.png)

![image-20210110145345435](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110145345435.png)

![image-20210110145513006](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110145513006.png)

![image-20210110145730952](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110145730952.png)

![image-20210110145925306](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110145925306.png)

![image-20210110145938111](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110145938111.png)

## 文件共享

![image-20210110150248652](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110150248652.png)

![image-20210110150308046](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110150308046.png)

![image-20210110212457188](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110212457188.png)

![image-20210110212754345](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110212754345.png)

![image-20210110212919515](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110212919515.png)

![image-20210110213017718](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110213017718.png)

![image-20210110213055595](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110213055595.png)

## 文件保护

![image-20210110213251488](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110213251488.png)

![](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110213634166.png)

![image-20210110213712111](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110213712111.png)

![image-20210110213936206](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110213936206.png)

![image-20210110214059366](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110214059366.png)

![image-20210110214153739](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110214153739.png)

![image-20210110214340258](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110214340258.png)

## 文件系统的层次结构

![image-20210110214833088](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110214833088.png)

![image-20210110215048005](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110215048005.png)

## 磁盘的结构

![image-20210110215106687](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110215106687.png)

![image-20210110215319641](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110215319641.png)

![image-20210110215536972](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110215536972.png)

![image-20210110215814376](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110215814376.png)

![image-20210110215903895](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110215903895.png)

![image-20210110215946498](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110215946498.png)

![image-20210110220008592](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110220008592.png)

![image-20210110220020081](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210110220020081.png)

## 磁盘调度算法

![image-20210116160540599](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116160540599.png)

延迟时间和传输时间都和磁盘转速相关，操作系统无法优化

但是寻道时间操作系统可以优化，有下列不同的许多算法

### 先来先服务算法

![image-20210116160848713](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116160848713.png)

### 最短寻找时机优先算法

![image-20210116162900372](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116162900372.png)

### 扫描算法

![image-20210116163316344](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116163316344.png)

### LOOK调度算法

![image-20210116163510577](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116163510577.png)

### 循环扫描算法

![image-20210116163811087](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116163811087.png)

### C-LOOK调度算法

![image-20210116163952434](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116163952434.png)

### 总结

![image-20210116164001188](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116164001188.png)

## 减少延迟时间的方法

![image-20210116164524170](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116164524170.png)

交替编号

![image-20210116164657035](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116164657035.png)

因为不可以读/写物理上空间连续的数据  因为读/写完一个扇区需要磁盘进行短暂的处理，不能立刻读取相邻的扇区 

### 磁盘地址结构的设计

为什么磁盘的物理地址是 柱面号，盘面号，扇区号

而不是(盘面号 柱面号 扇区号)

![image-20210116165324390](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116165324390.png)

![image-20210116165551350](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116165551350.png)![image-20210116165704297](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116165704297.png)

![image-20210116170330345](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116170330345.png)

![image-20210116170339604](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116170339604.png)

## 磁盘的管理

![image-20210116170437160](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116170437160.png)

### 磁盘的初始化

![image-20210116170716365](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116170716365.png)

磁盘初始化

一般先要进行低级格式化(物理格式化)，将磁盘的各个磁盘划分为扇区，一个扇区通过分为头，尾，数据区域

管理扇区所需要的各种数据一般存放在头尾部分，包括扇区校验码，或者说尾部存放指向下一个磁盘块的指针，然后将磁盘进行分区，一个分区由若干个柱面组成，然后进行逻辑格式化，创建文件系统根目录，初始化空间管理所用的数据结构(如 空闲分区表等)

### 引导块

![image-20210116171102933](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116171102933.png)

![image-20210116171452186](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116171452186.png)

由于ROM自举程序可能需要修改 ，所以选择了只给ROM中存放了一个很小的自举装入程序，相当于让CPU在磁盘上寻找正确的自举程序，这些程序被称为初始化程序，因为计算机开机的时候需要进行一系列初始化的工作

拥有引导块/启动分区的磁盘称为启动磁盘或者系统磁盘(C:盘)

![image-20210116171838860](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116171838860.png)

![image-20210116171849967](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116171849967.png)

# IO

## IO设备的概念和分类

![image-20210116172021890](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116172021890.png)

![image-20210116172447089](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116172447089.png)

![image-20210116172521945](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116172521945.png)

![image-20210116172531154](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116172531154.png)

![image-20210116172616992](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116172616992.png)

![image-20210116172657761](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116172657761.png)

![image-20210116172753474](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116172753474.png)

![image-20210116172800974](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116172800974.png)

## IO控制器

![image-20210116173012118](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116173012118.png)

![image-20210116173301579](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116173301579.png)

![image-20210116173839768](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116173839768.png)

IO控制器相当于中介，用于实现CPU和I/O设备之间的交互，CPU对设备的控制

I/O控制器通常会设置许多寄存器，如状态寄存器，数据寄存器，控制寄存器

![image-20210116174437163](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116174437163.png)

I/O控制器的组成如上图

![image-20210116174547024](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116174547024.png)

由于寄存器可能会有很多个，并且这些寄存器需要相应的地址才能方便CPU操作，有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I/O，另一些寄存器则采用I/O专用地址，称为寄存器独立编址

![image-20210116174906201](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116174906201.png)

![image-20210116174915624](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116174915624.png)

## IO控制方式

![image-20210116175119137](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116175119137.png)

### 程序直接控制方式

![image-20210116175408972](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116175408972.png)

CPU会一直轮询去查看状态寄存器的状态

![image-20210116175727242](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116175727242.png)

因为从I/O设备读取的数据最终是要到寄存器的，比如上图scanf，从键盘输入一个值，输出到控制台，该过程经过了CPU寄存器-存储器的写入	 

![image-20210116175948994](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116175948994.png)

### 中断驱动方式

![image-20210116180249109](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116180249109.png)

![image-20210116180610283](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116180610283.png)

### DMA方式

![image-20210116180901180](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116180901180.png)

由CPU向DMA发出指令并且告诉此次要继续的操作，需要操作外部设置的地址和数据要存放在内存的什么位置，并且不是以字为单位而是以块为单位

![image-20210116181525182](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116181525182.png)

![image-20210116181801208](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116181801208.png)

DMA缺点主要是每次读/写只能是一个块，或者是连续的块，不能每次读取多个离散的块并且存入内存也必须连续

### 通道控制方式

![image-20210116182137707](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116182137707.png)

![image-20210116182533051](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116182533051.png)

![image-20210116182540978](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210116182540978.png)

一个通道可以控制多个IO控制器，一个IO控制器可以控制多个IO设备

## IO软件层次结构

![image-20210120211945857](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210120211945857.png)

![image-20210120212122486](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210120212122486.png)

![image-20210120212448209](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210120212448209.png)

![image-20210120212505522](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210120212505522.png)

![image-20210120212525393](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210120212525393.png)

![image-20210120212558034](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210120212558034.png)

![image-20210120212711794](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210120212711794.png)

![image-20210120212748957](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210120212748957.png)

![image-20210120212843314](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210120212843314.png)

![image-20210120212933257](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210120212933257.png)

![image-20210120213043173](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210120213043173.png)

![image-20210120213128215](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210120213128215.png)

## IO核心子系统

![image-20210122185943038](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122185943038.png)

![](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122190105059.png)

## 假脱机技术

![image-20210122190527083](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122190527083.png)

什么是脱机技术？假脱机技术的实现原理

![image-20210122191035659](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122191035659.png)

![image-20210122191046753](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122191046753.png)

![image-20210122191301042](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122191301042.png)	

![image-20210122191502050](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122191502050.png)

![image-20210122194704547](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122194704547.png)![image-20210122194754846](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122194754846.png)

## 设备的分配与回收

![image-20210122194908853](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122194908853.png)

![](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122195103993.png)

虚拟设备，采用SPOOLing技术将独占设备改造成虚拟的共享设备，都会在输出井中为用户线程提交的请求建立存储区，可同时分配给多个进程使用

![image-20210122195750212](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122195750212.png)

![image-20210122195903793](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122195903793.png)

![image-20210122200013751](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122200013751.png)

![image-20210122200427370](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122200427370.png)

设备控制表

系统为每个设置配置一张DCT表，用于记录设备情况

![image-20210122200628374](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122200628374.png)

![image-20210122200741699](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122200741699.png)

![image-20210122200914669](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122200914669.png)

![image-20210122201002723](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122201002723.png)

![image-20210122201055717](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122201055717.png)

![image-20210122201156369](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122201156369.png)

![image-20210122201419315](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122201419315.png)

![image-20210122201606227](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122201606227.png)

第一次进来的时候首先根据类型查找并且不空闲找到其中一个后，为其在LUT中新增一个表项。记录逻辑设备名和物理名和入口地址，下次来的话直接可以通过表找到

![image-20210122201753344](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122201753344.png)

![image-20210122201805156](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122201805156.png)

## 缓冲区管理

![image-20210122202042662](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122202042662.png)

![image-20210122202238805](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122202238805.png)

![image-20210122202601780](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122202601780.png)

解除CPU与IO设备之间速度不匹配的问题，减少CPU的中断频率，解决数据粒度不匹配，提高CPU与IO的并行性

### 单缓冲

![image-20210122203528337](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122203528337.png)

![image-20210122203804252](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122203804252.png)

![image-20210122203924516](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122203924516.png)

![image-20210122203935065](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122203935065.png)

![image-20210122204152398](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122204152398.png)

![image-20210122204647876](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122204647876.png)

![image-20210122204812841](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122204812841.png)

![image-20210122204851647](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122204851647.png)

![image-20210122204956282](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122204956282.png)

![image-20210122205228761](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122205228761.png)

![image-20210122205236039](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210122205236039.png)