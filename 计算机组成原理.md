# 	计算机组成原理

## 1.1 计算机的基本组成

### 1.1.1运算器，寄存器，输入，输出，控制器

### 寄存器的基本组成

存储体  存放0 1 代码 包括 指令 和操作数 

MAR MDR  MDR  :存放数 MAR :存储指令或者数据的内存地址

一个存储单元所存放的二进制数称为存储字 

存储字的长度称为存储字长

### 运算器的组成

X寄存器 ACC 累加寄存器 MQ 乘除寄存器 ALU 运算器 算术逻辑单元

### 控制器的组成

完成一条指令所需要的操作 大致分为

1：取指令  PC  相当于一个计数器

2：分析指令   IR 指令寄存器 存放指令的

3：执行指令  CU

![image-20201103203910757](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201103203910757.png)

### 主机完成一条指令的过程

![image-20201103204317337](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201103204317337.png)



存数指令

![image-20201103210208459](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201103210208459.png)

首先PC里面存放的是存数指令的地址 然后把指令的地址给MAR MAR被CU控制单元控制给存储体 存储体取出地址上的存储指令 将存储指令存放到MDR 由CU控制单元控制将MDR数据给IR IR将操作符部分取出给CU  CU执行指令 同时IR将地址给MAR 

MAR告诉存储体要存放数据的地址 让存储体开辟存储空间 然后将ACC的数据存放给MDR MDR将数据写入到存储体

### 程序的运行过程详解

![image-20201103212146241](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201103212146241.png)

将程序通过输入设备送至计算机

程序首地址存放到PC寄存器

开始执行程序 分为三个步骤

取指令 PC寄存器存放的是该指令的地址-MAR-M-MDR MDR将取出的数据送给IR

IR取出OP(也就是操作码) 让CU去分析指令 CU分析该指令如果是取数指令 则将IR重的Ad(也就是指令中的地址码) 存放的是该指令操作对象的存储地址 将该地址发送给

MAR-M-MDR MDR将数据取出来之后CU将该数据存入到ACC

### 指令字

指令字(简称指令) 即表示一条指令的机器字

**指令格式**则是由指令字用二进制代码表示 通常分为**操作码**和**地址码**。操作码一般存放该指令的操作特性和功能 由CU进行分析 地址码存放的是参与该操作码上指令的操作数的存储地址

## 总线的分类

片内总线：  芯片内部的部件用来传输的介质

系统总线

  系统总线又分为 数据总线： 通常是双向的 用于数据的传输

​                             地址总线 ： 单向 与存储地址和I/O地址有关

​                             控制总线 ： 有出   有入 

![image-20201105202017587](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201105202017587.png)

![image-20201105202006989](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201105202006989.png)

### 总线结构举例

![image-20201105205400932](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201105205400932.png)

PCI总线结构

![image-20201105205556501](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201105205556501.png)

### 总线控制

1.基本概念 

分为主设备和从设备

主设备可以发起占有权，对总线有控制权

从设备只能响应主设备发来的总线命令

那多个主设备对总线发起控制器

总线如何判断谁优先呢？

![image-20201105210415736](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201105210415736.png)

![image-20201105212417491](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201105212417491.png)

所有接口通过BR向总线拿总线权 总线通过BG按次序响应找到对应的接口 

该接口拿到总线使用权通过BS线发送总线忙

![image-20201105213521780](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201105213521780.png)

多了设备地址线 通过计数器实现

少了BG链式查询线

4丶独立请求方式

![image-20201105213922033](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201105213922033.png)

### 总线通信控制

总线传输周期指的是主设备和从设备进行完整的安全的可靠的数据传输所花费的时间

![image-20201107145317650](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201107145317650.png)

![image-20201107160441824](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201107160441824.png)

从模块向主模块发送 WAIT信号 当WAIT为低电平时表示等待 当Wait为高电平时表示已经准备好和主模块进行交互



半同步通信的时序图

允许主从设备模块的速度不同来交互

第一个时钟周期开启前 

主设备提供要与哪个从设备进行交互的地址 在第二个时钟周期开始前要读取读命令 也就是读命令保持低电平

在第三个时钟周期开始前如果从设备没有准备好与主设备进行交互 则发出一个低电平wait信号 表示我还没有准备好 当一直等待TW 直到TW变成高电平 则表示已经准备好和主设备进行交互  开始在T3前准备好数据  然后T4时钟周期前读命令信号和数据信号撤销  在T4时钟周期结束后 地址信号也撤销

![image-20201107161150835](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201107161150835.png)

### 同步通信 异步通信 半同步通信(异步同步结合)的问题

![image-20201107162110062](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201107162110062.png)

在从模块准备数据的时候 总线空闲  

因为总线上有大量接口连接 应该百分百利用总线 所以提出了其他的通信方法	 

### 分离式通信

![image-20201107163337138](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201107163337138.png)

分离式通信的特点

1.各模块有权申请占用总线

2.采用同步方式通信

3.各模块准备数据不需要占用总线

4.总线被占用时无空闲

这样的通信充分利用了总线的带宽

带宽: 单位时间内通过链路的数据量

## 存储器

### 存储器的概述

![image-20201107165723964](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201107165723964.png)

按存取方式分类

![image-20201107171356643](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201107171356643.png)

按作用分类

![image-20201107172053892](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201107172053892.png)

 ### 内存层次

![image-20201107174607403](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201107174607403.png)	



![image-20201107174922487](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201107174922487.png)

## 主存储器

### 主存储器的概述

![image-20201107180833297](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201107180833297.png)

MAR保存的是访问存储体哪个存储单元的地址

MAR必须经过译码器  MDR里面保存的数据通过读写控制电路来控制到底是读还是写

主存和CPU的关系

![image-20201107181420682](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201107181420682.png)

### 主存的技术指标

![image-20201109205540775](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201109205540775.png)

存取时间 是指存储器给出地址信号 到存储器上有稳定的输入和输出信号

![image-20201109213146584](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201109213146584.png)

65535 16k-1 此使最后的存储芯片上的片选线有效为低电平 其他片选线上为高电平 即无效

### 半导体存储芯片的译码驱动方式

![image-20201110201834337](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201110201834337.png)

线选法 地址译码器如果输出低电平 4条线经过译码器译码后16条只有一条线起作用

假设内存有1M*8位 那么地址线就是20条  20条线经过译码器译码后有百万条只有一条线 集成度很低  不适合



![image-20201110203302940](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201110203302940.png)

重合法的译码驱动方式

### 4116(16k乘以1位)芯片

![image-20201112201706385](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201112201706385.png)

地址线只有7根  经过两次输入确定行和列地址

![image-20201112203750462](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201112203750462.png)

相对一个时间段来说是集中刷新 一个时间段刷新所有

整体来看是分散刷新 所以是相结合

为什么是15.6us呢 因为2ms = 2000us 2ms要刷新128行  电容会在一段时间没电 所以需要刷新重现电荷 2000除以128=15.6 所以只要保证15.6刷新一行 

然后其中一行的死区为0.5us 因为在刷新芯片的时候内存是不能使用的

### 动态RAM和静态RAM的比较

![image-20201112204410649](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201112204410649.png)

最后一行是刷新

DRAM可以缩小一半的引脚 因为可以把地址线分为行列 来分批发送

速度教慢 

而静态RAM采用的是双稳态触发器 6个晶体管 功耗比较大 速度比较快  采用的是触发器原理存放信号

### 只读存储器

![image-20201112204921214](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201112204921214.png)

只读存储器的发展历程

可以多次写的时候需要单独购买可擦写的设备进行擦写 

![image-20201112205539075](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201112205539075.png)

由于不能满足用户需求

![image-20201112205858924](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201112205858924.png)

发明了多次性编程

可以多次修改 利用紫外线驱除浮动珊取反 让其导通变为1  没有浮动珊的可以在漏级加正电压形成浮动珊

## 存储器与CPU的连接

![image-20201112210924240](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201112210924240.png)

**位的扩展核心是把两个芯片当成一个芯片来用**

所以必须要给两个芯片上面的片选信号相同且同时被选中或者同时不被选中

**字的扩展**

![image-20201112211613923](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201112211613923.png)

其核心是多余的一条数据线如果是低电平选择第一个存储芯片

如果是高电平选择第二个存储芯片

### 字和位的同时扩展

![image-20201112212759156](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201112212759156.png)

同时扩展的核心是把两个芯片当成一组 

然后其中一组一次输出8位数据 共有4组

多出的两根线代表四种信号 00 01 10 11 分别代表四组其中的一种进行读入或者写出

## CPU和存储器的连接

![image-20201114112017119](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114112017119.png)

MREQ信号极其重要 只有他为低电平的时候有效才表示是访问的存储器

注意ROM是只读 单向

RAM是可读可写 双向



4kROM和8KRAM的CPU与存储器组合

![image-20201114114611838](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114114611838.png)

地址线A0-A11分别接每个芯片 用于确定访问哪个存储单元

A12 13 14 接译码器输入端  G1 G2 G3是译码器的控制端 G1需要一个高电平 G2A需要一个低电平  所以G1直接接电源 G2A接A15地址线  三根地址线分别接ABC的输入端用来决定到底访问的是哪个芯片 片选信号

MREQ接G2B

4K 16位地址线

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 从0开始 选4K为ROM 4k就是12位到1

0 0 0 0  1 1 1 1 1 1 1 1 1 1 1 1   临近区为用户区 8K

0 0  0 1 0 0  0 0 0 0 0 0 0 0 0 0 

0 0 0 1 1 1 1 1 1 1 1 1 11 1 1 1 

  A0-A11接每个芯片的线

然后0 0 0   Y0输出有效

​        0 1 0   Y1有效

​         1 0 0   Y2有效

三个有效的分别选择其中的某一个芯片

### 存储器的校验

什么要存储器的校验呢？

因为电容的值可能变化 

触发器保存的值可能发生偏转

![image-20201114145838468](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114145838468.png)

纠错能力和一个代码集相差的位数有关

![image-20201114150124810](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114150124810.png)

比如

{00000，11111}

比如一个集合  一个合法代码转变为另外一个合法代码需要变换5位

则

 L - 1 = D+C  等价于  5-1=2+2  

00111 可以看出来是2位代码错 从11111变为00111

11000可以看出来是2位代码错 从 00000变成11000

### 汉明码的校验

![image-20201114153552464](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114153552464.png)

1-7个位置用二进制表示 每组都有1个特有的数据 比如00001   00010 

三组的数分别进行异或校验 如果无差错 应该都是0 如果出错 则对应的10进制数就是该错误的位置

![image-20201114154505989](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114154505989.png)

k为检测位 n为要传递的数据

检测位的位置放在2的i次方 如果i从1开始 则放在2的i-1次方

### 检测位

![image-20201114160344688](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114160344688.png)

1+2 =3 共占3位 0111 4+2+1 共占第7

### 例题

![image-20201114161623012](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114161623012.png)

分组必须满足上面的公式

所以需要分三组 

三组的校验位分别放在2的i次方上

首先第一组 需要满足第一组位置的特征 即 1 3 5 7 这四个位置

然后判断这四个位置有几个1 上图除开校验位的位置上面有偶数个1 所以不用添1 直接取0 后面的组以此类推

![image-20201114163846056](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114163846056.png)

汉明码纠错过程

![image-20201114164148809](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114164148809.png)

## 提高访问速度的措施

![image-20201114165910351](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114165910351.png)

单体多字系统会有问题

比如说CPU写入16位数据的时候  先通过单字长寄存器再到数据寄存器64位 然后存放到存储体 可能会造成存储体的信息修改错误 因为CPU只改16位

为什么要这样设计系统 因为CPU和存储器速度差异较大 所以为了提高存储器速度

改变存储器结构 假设CPU的字长为16位 那么把存储器的数据寄存器扩展为64位  CPU一次可以取4个机器字长

**改进方式**

![image-20201114171423254](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114171423254.png)

更好的改进

![image-20201114171917287](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114171917287.png)

雨露均沾

#### 地位交叉的特点

![image-20201114172106406](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114172106406.png)

![image-20201114172226402](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114172226402.png)

![image-20201114172854951](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114172854951.png)

存储时间

当取第一个的时候

第二个总线传输到来  当经过一个T时

想实现流水线方式存取 应满足 T=4t

M1已经进行了3t  M2已经就行了2t M3进行了1t 

所以当CPU连续读写4个写需要的时间为

一个存储周期   T+3t   

取两个字就是

 T+1t 

### 高性能存储芯片

![image-20201114173921210](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114173921210.png)

## 高速缓冲存储器

![image-20201114180006249](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114180006249.png)

主存和缓存按块存储 快的大小相同

### 缓存的命中和未命中

![image-20201114180413180](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201114180413180.png)

### 访问效率

![image-20201115130729930](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201115130729930.png)



### 基本结构



![image-20201115131752045](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201115131752045.png)



主存和Cache主要是通过块来进行传输

块基本分位块号和块内地址

地址映射决定了主存的块如何放入到Cache块 或者说主存的块通过映射放到Cache的哪个块 Cache的替换机构决定了要替换哪个块

### Cache的读写

![image-20201115132345690](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201115132345690.png)

Cache的写操作

![image-20201115133058995](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201115133058995.png)

### Cache的改进

![image-20201115133932096](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201115133932096.png)

### Cache与主存的映射

![image-20201115134730919](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201115134730919.png)

这种直接映射简单效率高 但是可能会造成资源空闲

![image-20201115135052751](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201115135052751.png)

比如说 Cache的子块0存放的是主存区号为0并且字块为0的数据

其他字块是空闲 如果此使CPU恰好要读第二个主存区并且字块为的数据根据映像规则这个数据被直接放到Cache存储体的字块0上  造成其他的块没被使用  字块0被频繁占用 

![image-20201115135645975](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201115135645975.png)

任何主存的块都可以放到Cache存储器里面的块

### 组相联映射

![image-20201115140730301](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201115140730301.png)

让Cache的组 和内存的某个区的块数相等 如果要操作主存储器的字块0

直接放到Cache的第0组

### Cache的替换算法

![image-20201115141922417](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201115141922417.png)

## 辅助存储器

![image-20201115143309330](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201115143309330.png)

![image-20201115143505306](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201115143505306.png)

## 输入输出系统

### 概述



![image-20201116202826729](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201116202826729.png)

### 组成

![image-20201116203931880](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201116203931880.png)

IO指令的操作码是指标记  标记是IO的指令  命令码是要执行的操作 比如是输出操作

设备码是地址 如果把某个内存的地址数据输出出去

或者说是给出io的地址 要对某个io地址进行输入输出

IO硬件  设备通过I/O接口连接总线

如果是不是连接的I/O接口 则设备连接设备控制器 设备控制器连接子通道 子通道连接通道

### I/O设备于主机的联系方式

![image-20201116204946605](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201116204946605.png)

统一编址 直接把内存和I/O一起进行编译 看作一个整体 CPU访问落到IO地址区间上就算是读写IO

![image-20201116205512736](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201116205512736.png)

### I/O设备与主机的连接方式

![image-20201116205934655](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201116205934655.png)

辐射式连接嵌入到芯片 可移植性太差

### I/O设备与主机信息传送的三种控制方式



![image-20201116210600131](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201116210600131.png)

**程序查询方式**

![image-20201116211342615](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201116211342615.png)

CPU先向I/O发出指令 然后一直查询I/O状态 等待I/O准备数据 直到I/O把状态置为ready

才可以从I/O接口中读取数据 读取完数据存放到CPU寄存器里面 再通过CPU从寄存器输入到主存 

实际上I/O很慢 CPU发出读命令 一直在等待I/O准备数据 踏步等待效率低

2.程序中断方式

![image-20201116212247957](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201116212247957.png)

CPU向I/O发出指令 然后开启继续执行他之前的现行程序 让I/O去准备数据 数据准备好后I/O接口向CPU发出一个中断请求 请求CPU中断现行程序 协助I/O一起传输数据 

输出完数据之后恢复到之前程序断电， 比如执行到K的地方I/O发出中断请求 处理完以后CPU回到程序K+1处开始继续执行

CPU要保护正在执行的程序 还要恢复程序 消耗也会比较大

具体流程如下图：

![image-20201116212732721](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201116212732721.png)

CPU不需要等待 并行执行

### DMA方式

![image-20201117203428732](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201117203428732.png)

图从左到右

CPU会预读取 把多条指令缓冲到缓冲器里面

DMA实现I/O与内存之间直接访问和进行数据传输 但是在传输过程中总线占用权被占用因此CPU不能访问内存

### 三种方式对比

![image-20201117204230647](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201117204230647.png)

### I/O设备

![image-20201117204715962](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201117204715962.png)

![image-20201117205110364](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201117205110364.png)

![image-20201117205426424](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201117205426424.png)

![image-20201117210013555](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201117210013555.png)

### I/O接口

![image-20201117211525224](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201117211525224.png)

主机和外部设备电平不一致

#### 接口的组成

![image-20201117211917327](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201117211917327.png)

设备选择线  选择哪个I/O设备进行数据的输入和输出 

实际上就是给的设备的地址

![image-20201117212325320](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201117212325320.png)

完成触发器D 表示I/O接口数据是否准备好

工作触发器表示外部设备忙碌还是空闲

**I/O接口的基本组成**

![image-20201117212651101](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201117212651101.png)

#### 接口类型分类

![image-20201117212922428](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201117212922428.png)	

## 程序查询方式

![image-20201118201603223](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201118201603223.png)

### 查询方式的接口电路

![image-20201118202021608](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201118202021608.png)

此使B去启动设备 D为0因为数据还未准备好

然后外部设备数据数据到DBR缓冲器里面 然后向设备选择电路发出设备关闭信号并且关闭设备 此时D为1 B为0 表示设备已经工作完成 不忙碌了

此使的CPU一直在查询D这个状态 直到D状态等于1

![image-20201118202232617](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201118202232617.png)

如果查询到等于1 此使CPU通过数据线从DBR中读入

## 程序中断方式

![image-20201118202530085](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201118202530085.png)

![image-20201118203122572](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201118203122572.png)

![image-20201118203309780](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201118203309780.png)

造成CPU中断的为中断源

部分并行

![image-20201118204933091](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201118204933091.png)

当mask的Q非等于1 D表示设备准备状态 也为1时 然后与操作 

### 硬件排队器

![image-20201118211821120](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201118211821120.png)

上图假设INTR2为高电平 其他都为低电平无效

![image-20201119201533656](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201119201533656.png)

中断向量地址可以生成向量地址 向量地址是指存放中断服务程序入口地址的地址

中断向量形成部件可以相当于一个设备编码器   

中断向量就是该类型中断的服务程序的入口地址

DSP控制器给每个中断分配了一个特定的入口地址，称为中断向量

### 接口电路基本组成

![image-20201119202359620](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201119202359620.png)

设备编码器相当于那个中断向量地址生成部件 来生成中断服务程序的入门地址 通过数据总线发送给CPU

在INTR接口到中断请求时同时MASK屏蔽触发器没有屏蔽该信号同时中断查询信号查询时，该Q端会输出有效信号

![image-20201119203155822](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201119203155822.png)

设备选择电路是接口和相应设备被选择的信号 只有这个信号有效，接口电路才会开始有效

![image-20201119204038049](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201119204038049.png)

启动设备之后将数据放入DBR寄存器中，同时发送设备工作结束信号 将D端置1 B端置0

![image-20201119210647964](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201119210647964.png)

然后通过设备编码器发送中断服务程序入口地址

![image-20201119212249841](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201119212249841.png)

恢复中断程序的流程

![image-20201119212612990](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201119212612990.png)

### 单重中断和多重中断

![image-20201121155053199](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121155053199.png)

![image-20201121155608277](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121155608277.png)

## DMA方式

### DMA方式的特点

DMA和程序中断两种方式的数据通路

![image-20201121160256992](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121160256992.png)

DAM方式进一步把cpu脱离了出来

![image-20201121160726314](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121160726314.png)

如果CPU的缓存器没有其他指令的时候 这个时候CPU可能会处于保持状态 没有发挥CPU对主存的利用率

![image-20201121161250100](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121161250100.png)

![image-20201121161454259](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121161454259.png)

### DMA接口的功能和组成

![image-20201121161807376](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121161807376.png)

第一步向CPU申请总线的控制权

4是每次传送一个字要变化长度和地址 便于读取下一个字或者存入下一个字

![image-20201121164818698](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121164818698.png)

WC为数据计数器的负数用的反码  每次传输一个字数据+1 直到为0向中断机构发出溢出信号告诉中断机构数据发送完毕 中断机构向CPU发出中断请求让CPU处理数据传输完毕的后续工作

### DMA的工作过程

![image-20201121165347305](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121165347305.png)

![image-20201121165916002](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121165916002.png)

CPU和DMA完全并行

CPU首先进行预处理

给DMA控制逻辑指明数据传送方向是输入(主存写)还是输出(主存读)

向DMA设备地址寄存器AR存入访问主存的地址

向DMA设备地址寄存器DAR存入访问设备的地址

同时给出此次数据需要传输的长度 

利用补码计算出WC计数器的值

CPU预处理完后 都是通过输入输出指令完成的

然后接着数据传送过程中继续执行其他执行后续数据真正的传输由DMA接口来处理

处理结束后DMA向CPU申请程序中断

CPU做后处理器

同时接着执行接下来的程序

设备准备好数据将数据放入DMA的BR寄存器 通知DMA接口 通过该寄存器访问数据总线传输数据

![image-20201121171120679](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121171120679.png)

AR是存放的主存的内存地址

每次存或读取完一个字主存内存地址+1 因为主存地址连续

![image-20201121171626642](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121171626642.png)

### ![image-20201121172157986](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121172157986.png)DMA接口与系统的连接方式

![image-20201121172321615](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121172321615.png)

## 中断方式和DMA方式比较

![image-20201121172548519](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121172548519.png)

### 接口类型的选择

![image-20201121172735983](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121172735983.png)

只可以同时有一个

多路型

![image-20201121172951221](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121172951221.png)

每个通道子通过具有和DMA接口相似的功能 如各种寄存器

CPU输入多个输入和输出指令 如果相应的设备在不同的子通道 则可以同时并行控制

但是真正数据传输的时候还是只可以有一个 

上面的选择型 在数据准备的时候也只能有一个

![image-20201121173734069](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121173734069.png)

为什么只需要5us呢？ 因为所以磁盘磁带的间隔的时间包括数据准备 数据放入接口的寄存器等待  而5us只是完成数据从寄存器的交换 所以时间短

## 计算机的运算方法

### 无符号数和有符号数

#### 无符号数

![image-20201121174942603](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121174942603.png)

#### 有符号数

![image-20201121175644909](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121175644909.png)

#### 源码表示法

![image-20201121181620473](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121181620473.png)

原码的小数表示方式

![image-20201121183417846](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121183417846.png)

真值的0和原码的0代码意义不一样

原码的小数点前的0和1代表符号位 

![image-20201121183921809](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121183921809.png)

![image-20201121184303477](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121184303477.png)

假设4位数据位

![image-20201121184641397](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201121184641397.png)

有加有减 会使得操作复杂 

### 补码

![image-20201123163630610](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123163630610.png)

一个负数加上模即得到该负数的补数

![image-20201123174822103](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123174822103.png)

#### 补码定义

![image-20201123180054804](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123180054804.png)

以上是整数表示法

![image-20201123181140282](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123181140282.png)

以上是小数

#### 快捷方式

![image-20201123181923038](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123181923038.png)

求一个负数的补码 

先求原码  

-1010 他的原码为 1,1010 补码为符号位不变 数值位取反加1 则 补码为 1,0101+1=1,0110

![image-20201123182924180](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123182924180.png)

以上为小数 

先到原码 补码到原码 减一取反 符号位不变

**注意 正数 无论是小数还是整数 他们的原码和补码都一样**

**负数的话 原码到补码 取反+1**

​              **补码到原码  -1取反**

![image-20201123183541677](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123183541677.png)

![image-20201123201304921](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123201304921.png)

### 反码

![image-20201123201918196](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123201918196.png)

以上为整数

![image-20201123202408958](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123202408958.png)

以上为小数

### 三位机器数的小结

![image-20201123203251902](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123203251902.png)

![image-20201123204646364](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123204646364.png)

补码的+0和-0相等 其他都不等 

补码有-128

![image-20201123204935842](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123204935842.png)

假设y是正数 则因为正数的补码反码原码表示都相等 则如以上图

-y的补则两边都加负号  然后y-的补码 如图

![image-20201123205120355](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123205120355.png)

**以上的前提条件是Y大于0**

### 移码

由于补码大小特别难判断 所以为了简便观察补码两个数值的大小 出现了移码

![image-20201123210838155](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123210838155.png)

x+2的n次方 																																																																																																																																																																																																																																																																									 	 ![image-20201123211645462](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123211645462.png)

移码不管是正数还是负数都加上2的n次方

简单记忆的话就是 

 正数符号位为1 数值位不变

负数符号位为0 数值位取反+1

![image-20201123212106260](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123212106260.png)

移码和补码只差一个符号位 

所以判断大小起来特别方便

### 真值丶补码和移码的对照表

![image-20201123212728972](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123212728972.png)

![image-20201123212952572](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201123212952572.png)

## 数的定点表示和浮点表示

### 定点表示

![image-20201127111336930](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201127111336930.png)

### 浮点表示

![image-20201127111824571](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201127111824571.png)

![image-20201127112557779](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201127112557779.png)

### 浮点数的表示形式

![image-20201127135127511](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201127135127511.png)

![image-20201127141344029](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201127141344029.png)

参考最小的正数

要求最小的正数

首先让阶码的阶符为负数也就是1 阶码的数值位为全1   阶码表示为 2的-(2的m次方整体-1)*2的-n次方

参考最大的正数

首先让阶码的符号为正数 也就是1 阶码的数值部分位全为1 阶码表示为 

**例题1. 若浮点数ｘ的二进制存储格式为(41360000)16进制，求其32位浮点数的值。**

**将16进制数转换为2进制 0100 0001 0011 0110 0000 0000 0000 0000**

**则e = 10000010 - 01111111 = 3(十进制)**

**M = 01101100000000000000000**

**则x = (-1)^0 × 1.011011× 2^3 = 1011.011(2进制)**

**= 11.375(十进制)**

**[例**2] 将十进制数20.59375转换成32位浮点数
**[解:] 首先分别将整数和分数部分转换成二进制数：**
       **20.59375＝10100.10011**
　　**然后移动小数点，使其在第1，2位之间**
　　　　**10100.10011＝1.010010011 × 2^4　　　e＝4**
　　**于是得到：**
       **S＝0，E＝4＋127＝131，M＝010010011**
　　**最后得到32位浮点数的二进制存储格式为：**
      **0100 0001 1010 0100 1100 0000 0000 0000**
    ＝41A4C000(16进制)

### 机器零

![image-20201129134632205](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201129134632205.png)

###  IEEE 754标准

![image-20201129135004108](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201129135004108.png)

## 定点运算

![image-20201129135856423](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201129135856423.png)

移位运算 相对于小数点 小数点不动

### 算术移位规则

![image-20201129141111158](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201129141111158.png)

补码左移和原码一致  右移的时候最高位因为原码补0 而补码是非 所以补1

### 例子

![image-20201129142123375](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201129142123375.png)

![image-20201130201014089](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201130201014089.png)

![image-20201130204611195](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201130204611195.png)

### 移位的硬件实现

![image-20201130211806698](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201130211806698.png)

### 算术移位和逻辑移位

![image-20201130212242276](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201130212242276.png)

算术移位算符号， 符号不参与移位运算 

逻辑移位所以位数参与移位	

## 加减法运算

![image-20201130213525412](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201130213525412.png)

![image-20201130214117659](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201130214117659.png)

![image-20201201203748158](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201201203748158.png)

![image-20201201210443478](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201201210443478.png)

上面的练习1和练习2都出现移除 

小数超过1 负数超过-128  因为7位数值位 补码范围在-128-+127之间

### 溢出判断

![image-20201201211535930](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201201211535930.png)

![image-20201201212409354](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201201212409354.png)

高位才是真正的符号

如 10 代表两个负数符号相加进行溢出为10  负溢出

如01 代表两个整数数值最高位1+1 进位为1  正溢出

![image-20201201212819003](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201201212819003.png)

## 乘法运算

![image-20201202205042257](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201202205042257.png)

![image-20201202210722994](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201202210722994.png)

### 改进后的笔算乘法过程

![image-20201202212203032](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201202212203032.png)

### 小结

![image-20201202212950793](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201202212950793.png)

## 原码乘法

![image-20201203201010833](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201203201010833.png)

![image-20201203201438031](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201203201438031.png)

进行N次加上N次移位可以实现乘法

例题

![image-20201203202541891](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201203202541891.png)

x*指的是x的绝对值 符号位先不管 先算数值部分 然后符号位通过异或电路来确定

![image-20201203202952581](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201203202952581.png)

![image-20201203211353060](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201203211353060.png)

X存放被乘法数 Q首先存放乘数 计算器每次执行移位-1 S是符号位 GM是乘法标志

控制们控制用MQ寄存器的最低尾来判断要不要打开X寄存器将被乘数相加 如果是0则不想加 

每次执行加法以后存入A寄存器 同时右移 将部分积的低位放入MQ寄存器 直到MQ寄存器的乘数右移完成



A,X,Q都是N+1位

## 除法

![image-20201203213213895](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201203213213895.png)	

![image-20201203213724711](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201203213724711.png)

## 原码除法

![image-20201204200258663](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201204200258663.png)

很明显 x>y 对于小数来说的话 商肯定会大于0 又因为处于小数定点机 不能超过1 所以溢出

![image-20201204202521197](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201204202521197.png)

采用的是 正数+(-正数) 所以采用的是-y的补码

余数为负的时候说明商给大了  所以要恢复余数 然后左移

![image-20201204203208981](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201204203208981.png)

### 加减交替法

![image-20201204203819412](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201204203819412.png)

![image-20201204204552126](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201204204552126.png)

![image-20201204204943133](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201204204943133.png)

![image-20201204205205438](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201204205205438.png)

# 浮点的四则运算

## 浮点数的加减法

![image-20201205105732499](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201205105732499.png)

总体来说小阶向大阶看齐  为什么呢？ 因为数值位左移的时候可能高位1会被丢掉 造成数据错误

右移丢掉1只是会影响数据的精度而已

![image-20201205194611911](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201205194611911.png)

这样计算简单，但是可能会有问题 因为丢失了精度 并且x+y的补码不是规格化 因为计算机里面存储浮点数都是经过规格化的  为什么要经过规格化？ 因为提高数据的精度 

![image-20201205195205012](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201205195205012.png)

![image-20201205200700082](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201205200700082.png)

## 规格化的两种方式

![image-20201205201025965](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201205201025965.png)

## 溢出例子

![image-20201205201500413](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201205201500413.png)

符号位其实是最高位的0  1是数值后的溢出 需要右规

![image-20201205201631045](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201205201631045.png)

![image-20201205202011062](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201205202011062.png)

![image-20201205203429140](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201205203429140.png)

让x的原码先右移一位 然后再求补码 不能直接对补码右移

![image-20201205204205867](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201205204205867.png)

![image-20201205204226000](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201205204226000.png)

## 溢出判断

![image-20201205205242477](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201205205242477.png)

# 算术逻辑单元

![image-20201206174953496](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206174953496.png)

Si的产生结果和Ci的产生结果

![image-20201206181758944](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206181758944.png)

![image-20201206182815568](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206182815568.png)

但是电路复杂性太高 不是很好

## 延申出单重分组跳跃进位链

![image-20201206184359527](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206184359527.png)

![image-20201206184614558](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206184614558.png)

![image-20201206184925873](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206184925873.png)

![image-20201206185104493](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206185104493.png)

![image-20201206185517585](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206185517585.png)

![image-20201206185920489](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206185920489.png)

# 指令系统

​	一个处理器能够执行所有的指令构成的集合称为指令集

![image-20201206190509810](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206190509810.png)

任何汇编或者高级语言程序都需要编译为计算机可以识别的01代码

![image-20201206191006226](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206191006226.png)

硬件和软件的交互靠指令

## 机器指令

指令的格式是什么?

操作码 地址码 寻址方式

指令的字长

-固定字长，可变字长 

![image-20201206191654572](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206191654572.png)

### 指令的一般格式

![image-20201206191704153](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206191704153.png)

长度固定便于译码 将二进制代码转换为高级语言

长度可变就是我们现在使用的x86机器

RISC(精简指令计算机)是一种架构 代表：arm CISC(复杂指令计算机)架构的代表：x86

### 扩展操作码

![image-20201206192624433](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206192624433.png)

为什么需要扩展呢？ 假设如上图OP是操作码 A1A2A3是地址码 每个槽是4位 那么OP操作码只有4位 代表计算机最多只能表示16条指令 这是远远不够的 所以需要扩展

扩展的方式就是保存码点  0000-1110 表示15条指令 最后一条指令做标记位 如果需要扩展则扩展 不需要则直接显示  **前提是短操作码一定不能是长操作码的前缀 这样就有了二义性**

比如8位的操作码 那么就是 11110000 11110001 一次类推

## 地址码

![image-20201206225846898](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206225846898.png)

PC是程序计数器PC  存放的是计算机下一条指令 使其地址减少 寻址范围变大

取指令，取两个操作数，存入操作数  4次访存

ACC是累加寄存器，可以存数

![image-20201206231101667](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206231101667.png)

该过程其实是一直扩大寻址访问，减少访存次数

## 指令字长

![image-20201206231703222](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206231703222.png)

分为固定和可变 如果指令字长可变 那么操作数地址的个数也决定于指令字长

##  小结



![image-20201206232919972](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201206232919972.png)

## 操作数类型和操作种类

![image-20201209202930175](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201209202930175.png)

左边是大端方式，右边是小端方式

数据有多种，如地址，数字，字符等等

### 数据在存储器的存放方式

![image-20201209203442651](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201209203442651.png)

从任意位置开始存取，上图描述一次最多计算机最多可向内存存放双字长 缺点是如果不是以字节为单位的数据存储会比较麻烦，速度慢

![image-20201209203709958](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201209203709958.png)

![image-20201209204122528](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201209204122528.png)

上图是解决浪费空间和速度比较好的一个方案 按地址的整数倍存储 如果是一个字节的那么就存放在1的倍数内存单元里面，如果是半字(2个字节)存放在偶数的字节里面 如果是单字的话存放在4的倍数 以此类推  这里假设存储字长为64位  机器字长为32位  一个字为32位 4字节

### 操作类型的指令

![image-20201209204911300](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201209204911300.png)

**如上图 寄存器-寄存器  存储器到存储器 一般数据传送都用MOVE指令 汇编指令**

​            **寄存器-存储器  STORE,MOVE,PUSH 存储器-寄存器 LOAD,MOVE,POP**

**算术逻辑操作的指令**

**加ADD 减SUB** 

![image-20201209205403795](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201209205403795.png)

#### 调用和返回指令

![image-20201209205600065](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201209205600065.png)

递归经典 CALL

![image-20201209210510745](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201209210510745.png)

陷阱指令，一般是比如说程序遇见操作码异常CPU自动调用的 如除数为0，操作数访问越界等等

输入： 把n端口的数据输出到AX寄存器种

输出：把AX寄存器的值输入到n端口中

## 寻址方式

![image-20201209211145612](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201209211145612.png)

### 指令寻址

常用的两种方式

![image-20201209212326596](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201209212326596.png)



#### 顺序寻址

#### 顺序寻址 每次取出一个指令的地址 PC+1 

#### 跳转寻址

遇见无条件跳转指令JMP 跳到对应的数进行寻址 如上图 JUM 7 跳到7取下一条指令

### 数据寻址

#### 立即寻址



![image-20201209212948516](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201209212948516.png)

形式地址和寻址特征进行一系列的运算得到有效地址

立即寻址特征# A直接就是操作数  操作码是要执行的什么操作

LDA指令：是将内存的值存储到ACC寄存器中

#### 直接寻址



![image-20201209213500253](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201209213500253.png)

直接寻址 A里面直接放该数据的地址 循环操作不易实现

#### 隐含寻址



![image-20201209213811366](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201209213811366.png)

隐含寻址 比如上图两个数 相加 但是只需要给出一个数的地址 另外一个数使用隐含寻址  隐含在ACC寄存器中 

#### 间接寻址

![image-20201210201717942](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201210201717942.png)

间接寻址可扩大寻址范围，因为PC上的位数可能很少，但是如果存放A的地址，A的地址长度很大，那么存放操作数的地址就可以实现扩大寻址范围

多次间址也是一样 但是必须要让地址的标识符为0才代表该地址存放的是真正操作数的地址

编程举例

![image-20201210202214955](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201210202214955.png)

80调用子程序 将81端点的地址保存的地址A中 那么内存地址A保存了该断点的地址，子程序执行到JMP跳转指令直接跳转到A保存的内存地址中

#### 寄存器寻址

![image-20201210202601926](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201210202601926.png)

和直接寻址蛮像的 但是速度快，空间小

#### 寄存器间接寻址

![image-20201210203009224](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201210203009224.png)

PC给的是寄存器的地址 寄存器里面存放的数据是操作数的地址

便于循环，程序员修改地址只需要修改寄存器里面的地址

#### 基址寻址

##### 专用寄存器作基址寄存器

![image-20201210204019163](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201210204019163.png)

BR相当于起始地址 A里面存放的数据相当于偏移量 结合ALU逻辑单元算出操作数的地址 然后再找到真正的操作数

##### 采用通用寄存器作基址寄存器

![image-20201210204559895](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201210204559895.png)

两者都是R0不变，形式地址可变

找到通用寄存器R0存放的数据和A中的数据相加得到操作数的地址

#### 变址寻址

![image-20201210204920860](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201210204920860.png)

A不可变，IX内容可变 遍历数组的时候非常适合 让A作为起始地址，IX作为数组下标

#### 例子

![image-20201210205854725](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201210205854725.png)

可以看出变址寻址求平均值指令很少，效率高

LDA是让ACC寄存器清0 LDX是让变址寄存器清0

ADD X,D  D为形式地址 不可变 X可变 上图为x[0],x[1],x[2]等等的地址 INX是将地址加1

CPX是比较

#### 相对寻址

![image-20201210210515287](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201210210515287.png)

应该归纳到指令寻址部分

非常适合转移指令

![image-20201210211027579](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201210211027579.png)

从内存取出直接就可以进行偏移-3再次回到M处

![image-20201210212325292](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201210212325292.png)

PC取出JMP指令后不一定会立刻执行 有可能会继续取指令 取到2002H才执行该指令，那么就会有问题

#### 堆栈寻址

![image-20201210212812462](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201210212812462.png)

![image-20201210213032407](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201210213032407.png)

SP的修改 

比如入栈之前 先把栈顶上移动 然后将值存储栈顶 修改SP地址

出栈 先把栈顶向下移动 然后将值取出  修改SP地址 SP一直是栈顶的地址

![image-20201210213627670](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201210213627670.png)



### 指令格式举例

![image-20201212114628429](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212114628429.png)

设计指令格式需要考虑的因素

![image-20201212114923007](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212114923007.png)

![image-20201212115107942](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212115107942.png)

NOP 无操作数，空操作，执行NOP指令只需要把程序计数器PC加1

### RISC技术

![image-20201212120221825](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212120221825.png)

精简指令集计算机

复杂指令集计算机

复杂的指令会影响效率

![image-20201212120717799](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212120717799.png)

只要LOAD/STORE可以访存，其他都不行

![image-20201212120954655](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212120954655.png)

### RISC和CISC的比较

![image-20201212121137044](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212121137044.png) 

![image-20201212121301736](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212121301736.png)

## CPU的结构和功能

![image-20201212121647545](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212121647545.png)

### CPU的功能

![image-20201212122210725](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212122210725.png)

需要有指令控制，操作控制，时间控制 输入和输出，处理中断，数据加工

### CPU结构框图

![image-20201212123511617](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212123511617.png)

ALU算术逻辑单元 处理数据 

PC计算器 给出指令地址

IR是从内存单元取出来的指令存入IR寄存器

操作控制和时间控制需要CU 时许电路 控制逻辑单 中断系统处理特殊请求 

### CPU的寄存器

![image-20201212131605653](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212131605653.png)

上图是用户可见寄存器条件码  如判断是否正，负，0等

#### 控制和状态寄存器

![image-20201212132233752](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212132233752.png)

PC首先取出指令的地址 存入MAR(主存地址寄存器)然后输入到主存 在到MDR(主存数据寄存器)-再把指令存入IR寄存器

程序状态字：是指程序在处理中断请求的时候要保存之前的现场，各种软硬件信息，和程序状态信息。 PSW寄存器就是存放该信息，指明CPU的状态

### 指令周期

基本概念

![image-20201212140958615](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212140958615.png)

![image-20201212142637174](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212142637174.png)

间接寻址指的是取出地址，然后通过地址再找到指令存放的地址，在找到指令进行执行

中断也是

![image-20201212143450766](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212143450766.png)

完成一条指令的指令周期流程图

![image-20201212143738581](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212143738581.png)

### 指令周期的数据流

#### 取指周期的数据流

![image-20201212144217229](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212144217229.png)

PC给出指令地址-MAR-地址总线-内存 然后CU给出读命令 CU-控制总线-内存

内存取出数据-数据总线-MDR-IR  然后CU控制PC+1取下一条指令

#### 间址周期数据流

![image-20201212144746460](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212144746460.png)

假设MDR存放的是指令需要执行操作数的地址的地址，那么将MDR取出送给MAR-地址总线-内存-内存取出数据-MDR 此时MDR存的就是操作数的地址

中断的步骤：保存程序端点，形成中断程序服务的入口地址，硬件关中断 这三步骤

![image-20201212145253474](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212145253474.png)

中断 首先要保存程序断点的地址， 这个地址由CU给出-MAR-地址总线-内存  再CU给出写命令

CU-控制总线-内存 此时PC存放的是程序需要返回的具体地址，将PC-MDR-数据总线-存储器

存储器保存该地址

中断系统服务程序的入口地址也是由CU给出，CU将值存入PC  然后CPU取出并且执行该

###  指令流水

![image-20201212150004365](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212150004365.png)

![image-20201212150303972](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212150303972.png)

系统的并行性，并行分为并发和同时

并发是指同一时间段，比如处理器给多个线程分配时间片，速度很快，用户看起来像是并行的

同时则是同一时刻，时间上重叠

![image-20201212150911678](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212150911678.png)

![image-20201212151241986](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212151241986.png)

![image-20201212151834648](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212151834648.png)

使用六级流水明显更快

![image-20201212152658190](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212152658190.png)

但是会产生资源冲突 一如上面蓝色部分

WO向内存写数据  FO读取操作数 FI读取指令 都想要使用内存，产生了资源冲突

下面给出了解决办法 指令和数据的存储器分开来

![image-20201212154207784](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212154207784.png)

解决方法 后推法 ：比如写后读 必须等待SUB指令把数据放入R1以后 第二条指令才可以执行

旁路技术:	就是不用等SUB指令完成后才执行ADD 可以直接把SUB指令后R1的值作为输入  输入到ADD![image-20201212154846392](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212154846392.png)

转移造成指令的不应该执行但是却执行了

### 流水线性能

流水线提高指令的并行度，不再串行

![image-20201212155405667](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212155405667.png)

![image-20201212155600545](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212155600545.png)

加速比是指 m段流水线的速度与非流水线速度的比值

T = m*t+(n-1)*t   T = nm*t

![image-20201212155933104](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212155933104.png)

![image-20201212160638145](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212160638145.png)

流水线速度是原来的三倍

#### 超长指令字技术

![image-20201212161101890](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212161101890.png)

从内存取出超长指令字，比如指令字有各种可以并行的运算  浮点运算，整数运算等

取出然后编译-控制多个执行单元去并行执行 ，非常快

### 指令流水线结构

![image-20201212161527921](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212161527921.png)

### 运算流水线

![image-20201212161723125](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212161723125.png)

## 中断系统

![image-20201212161913282](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212161913282.png)

![image-20201212162045473](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212162045473.png)

![image-20201212162251490](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212162251490.png)

每个请求源 一个中断请求标记INTR对应一个中断请求标记触发器 标记是否请求了中断

![image-20201212162710320](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212162710320.png)

![image-20201212162757961](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212162757961.png)

![image-20201212163046518](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212163046518.png)

硬件直接生成向量地址，CPU找到该内存单元 里面保存的是中断服务程序入口地址

![image-20201212163334551](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212163334551.png)

软件查询法

SKP是跳过下一条指令

判断完成触发器是不是1 如果是则跳转到服务程序 否则继续执行

### 中断响应

![image-20201212163726528](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212163726528.png)

响应中断的条件  CPU有一个中断触发器 EINT = 1 只有当1的时候才允许中断

响应中断的时间，在指令执行周期结束时刻由CPU发查询信号

![image-20201212164300044](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212164300044.png)

中断隐指令完成 保护程序端点，寻找程序入门地址，硬件关中断

### 保护和恢复现场

![image-20201212164614107](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212164614107.png)

恢复现场则是通过中断服务程序

![image-20201212165032629](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212165032629.png)

多重中断

![image-20201212165354903](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212165354903.png)

中断谁就要返回谁

![image-20201212165545235](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212165545235.png)

屏蔽触发器的作用就是使完成触发器(表示设备已经准备好，向CPU发出信号)无法向设备提出中断请求

![image-20201212171152512](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212171152512.png)

![image-20201212171415483](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212171415483.png)

单重中断  将断点地址-MAR-内存写入   PC取出MDR的地址 也就是断点地址来执行![image-20201212172924629](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212172924629.png)

### 操作命令的分析

![image-20201212173728481](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212173728481.png)

存数指令 STA

上图表示将ACC的内容 保存到内存单元为x的地址  x地址由IR给出 IR-MAR CU-W

ACC-MDR ACC的值写入到MAR指定的内存单元里面

LDX 取数指令

所有的指令存放在IR寄存器中  每次会将IR中的指令操作码和地址码分开传送

程序PC存放的都是指令的地址码部分 指出要操作下一条指令所在单元的地址

![image-20201212175838245](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212175838245.png)

![image-20201212180017404](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212180017404.png)

### 控制单元的功能

![image-20201212180659941](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212180659941.png)

输入信号

![image-20201212181002739](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212181002739.png)

![image-20201212181232141](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212181232141.png)

HLDA总线响应信号 响应外部设备对总线发出请求的信号

首先PC存放的是指令在内存单元的地址  然后PC-MDR-内存  CU译码后分析出是什么类型的操作 比如是读  然后读到MDR-IR IR里面存放的是指令![image-20201212181705469](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212181705469.png)

![image-20201212181833746](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212181833746.png)

![image-20201212182258541](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212182258541.png)

上图已经取出了指令  间址周期 则是通过MDR-MAR-MDR 把操作数真正的地址取出来

取出来之后通过C3 存入IR的地址码部分 覆盖该指令的形式地址 让其形式地址变为其真正的操作数地址  蓝色部分是操作数

![image-20201212182306962](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212182306962.png)

IR蓝色部分是指令的操作数 也就是指出指令要做什么样的操作  黄色的部分指出这个操作对哪个内存单元的地址做操作

![image-20201212182822993](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212182822993.png)

MDR存放的是操作数的地址 MDR-MAR-MDR 取出真正的数据

该数据和ACC寄存器里面的数据通过ALU相加 最后存入ACC![image-20201212193953281](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212193953281.png)

![image-20201212194754688](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212194754688.png)

使用CPU内存总线的执行周期![image-20201212195749630](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212195749630.png)

把取指令，存储器读，存储器写等，这每一项工作称为一个基本操作，完成一个操作所需要的时间称为机器周期

![image-20201212200543752](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212200543752.png)

![image-20201212200942652](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20201212200942652.png)

会产生时间浪费，节拍浪费