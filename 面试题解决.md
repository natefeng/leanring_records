# 面试题解决

### 3.1 操作系统基础

- ★★★ 进程与线程的本质区别、以及各自的使用场景。
- ★☆☆ 进程状态。
- ★★★ 进程调度算法的特点以及使用场景。
- ★☆☆ 线程实现的方式。
- ★★☆ 协程的作用。
- ★★☆ 常见进程同步问题。
- ★★★ 进程通信方法的特点以及使用场景。
- ★★★ 死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁。
- ★★★ 虚拟内存的作用，分页系统实现虚拟内存原理。
- ★★★ 页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法。
- ★★★ 比较分页与分段的区别。
- ★★★ 分析静态链接的不足，以及动态链接的特点。

### 3.2 Linux

- ★★☆ 文件系统的原理，特别是 inode 和 block。数据恢复原理。
- ★★★ 硬链接与软链接的区别。
- ★★☆ 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。
- ★★★ 僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因。

### 3.3 基础

- ★★★ 各层协议的作用，以及 TCP/IP 协议的特点。
- ★★☆ 以太网的特点，以及帧结构。
- ★★☆ 集线器、交换机、路由器的作用，以及所属的网络层。
- ★★☆ IP 数据数据报常见字段的作用。
- ★☆☆ ARP 协议的作用，以及维护 ARP 缓存的过程。
- ★★☆ ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。
- ★★★ UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。
- ★★★ 理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。
- ★★★ 可靠传输原理，并设计可靠 UDP 协议。
- ★★☆ TCP 拥塞控制的作用，理解具体原理。
- ★★☆ DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡。

### 3.4 HTTP

- ★★★ GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存。
- ★★☆ HTTP 状态码。
- ★★★ Cookie 作用、安全性问题、和 Session 的比较。
- ★★☆ 缓存 的Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。
- ★★★ 长连接与短连接原理以及使用场景，流水线。
- ★★★ HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用。
- ★★☆ HTTP/1.x 的缺陷，以及 HTTP/2 的特点。
- ★★★ HTTP/1.1 的特性。
- ★★☆ HTTP 与 FTP 的比较。

### 3.5 Socket

- ★★☆ 五种 IO 模型的特点以及比较。
- ★★★ select、poll、epoll 的原理、比较、以及使用场景；epoll 的水平触发与边缘触发。

​       3.1 SQL

- ★★☆ 手写 SQL 语句，特别是连接查询与分组查询。
  ★★☆ 连接查询与子查询的比较。
  ★★☆ drop、delete、truncate 比较。
  ★★☆ 视图的作用，以及何时能更新视图。
  ★☆☆ 理解存储过程、触发器等作用。
  3.2 系统原理
  ★★★ ACID 的作用以及实现原理。
  ★★★ 四大隔离级别，以及不可重复读和幻影读的出现原因。
  ★★☆ 封锁的类型以及粒度，两段锁协议，隐式和显示锁定。
  ★★★ 乐观锁与悲观锁。
  ★★★ MVCC 原理，当前读以及快照读，Next-Key Locks 解决幻影读。
  ★★☆ 范式理论。
  ★★★ SQL 与 NoSQL 的比较。
  3.3 MySQL
  ★★★ B+ Tree 原理，与其它查找树的比较。
  ★★★ MySQL 索引以及优化。
  ★★★ 查询优化。
  ★★★ InnoDB 与 MyISAM 比较。
  ★★☆ 水平切分与垂直切分。
  ★★☆ 主从复制原理、作用、实现。
  ★☆☆ redo、undo、binlog 日志的作用。
  3.4 Redis
  ★★☆ 字典和跳跃表原理分析。
  ★★★ 使用场景。
  ★★★ 与 Memchached 的比较。
  ★☆☆ 数据淘汰机制。
  ★★☆ RDB 和 AOF 持久化机制。
  ★★☆ 事件驱动模型。
  ★☆☆ 主从复制原理。
  ★★★ 集群与分布式。
  ★★☆ 事务原理。
  ★★★ 线程安全问题。

https://www.jianshu.com/p/a643838f2824

# 面试题一问一答

# 基础

## 多态

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法到底是哪个类中实现的方法，必须由程序运行期间确定

JAVA中两种方式可以实现多态：继承，接口

## ArrayList和Vector的区别

![image-20210224102319978](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210224102319978.png)

arrayList是线程不安全的,Vector是线程安全的，并且锁的粒度较大都是方法上加锁

性能：arrayList优于Vector

扩容：arrayList每次扩容50%，Vector扩容一倍 如果16需要扩容，那么ArrayList扩容值为24,Vector扩容值

## ArrayList,Vector,LikedList的存储性能和特性

arrayList是基于数组的，查询快,增删相对于LinkedList而言慢

LinkedList是基于双向链表的,插入删除性能高,查询慢

Vector也是基于数组的，但是加锁，并且锁的粒度大，属于遗留容器

## 快速失败和安全失败的区别

java.util包的集合类都属于快速失败,java.util,concurrent包下的类都是安全失败

### 快速失败

在使用迭代器对集合进行迭代的过程中，如果A线程正在对集合进行遍历，B线程同时对集合进行修改，或者A线程在遍历过程中对集合进行修改，都会抛出异常

ConcurrentModificationException 异常

每当迭代器使用HashNext()/next()遍历下一个元素之前，都会检查modCount是否和expectCount相等，如果不等那么就会抛出异常

```java
  final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
```

**总结：**
**迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量（表示修改次数）。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值（在迭代器初始化过程中会将modCount这个值赋给迭代器的expectedModCount），是的话就返回遍历；否则抛出异常，终止遍历。（如果不相等就表示已经有其他线程修改了 集合）**

### 安全失败

采用安全失败机制的容器，在迭代器遍历的时候对集合进行修改的时候不会抛出异常，因为它原理是先复制原有数组内容，然后在拷贝的集合上进行修改

由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常

比如CopyOnWriteArrayList

## HashMap什么时候进行扩容呢

如果是默认初始长度的话那么就是16*0.75 = 12

也就是在桶位被占用到12个开始扩容

## List,Map,Set三个接口,存取元素特点

List和Map都是单列元素的集合，它们有一个共同的父接口Collection

List元素是可以重复的

Set的数据结构相当于Map中的Key，所以说是不可重复的

Map是基于KV键值对的

List以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素。Map 保存key-value值

## Set里的元素不能重复，是用什么方法来区分重复与否呢？ == 还是 equlas()？ 它们有什么区别

Set元素不可以重复，并且NULL值也只允许有一个

首先进行hashCode来确定桶位，然后根据equlas来判断是否相等

==比较的是两个对象的内存地址

equlas()如果没有重写的是默认也是比较的内容地址也就是==，如果重写了可以根据业务逻辑或者JAVA类的属性判断是否相等

比如HashSet。底层其实就是HashMap的key

## 两个对象相同的(x.equals(y) == true),但却可有不同的hashCode,这句话对吗

不对，如果两个对象的使用equals进行比较的话如果相等，那么它们的hashCode也必须相等

它们的hashCode相等，但是它们的equals也可以不相等

hashMap就是基于这个特性来设计对象是否相等的

如果违背了这种约点，那么在HashMap存取元素就会有问题

## Heap和Stack的区别

数据结构中stack是先进后出的存储结构，堆是通过排序的树形数据结构，把它的所有元素都按**完全二叉树**的方式存于数组中，则称这个数组为最小堆或者最大堆

java中是线程独有的，方法都需要入栈，一个方法入栈后成为栈帧，一个栈帧上面有局部变量表，操作数栈等等信息

heap是线程共享的，对象都存于堆中，然后栈中的引用指向堆中的对象地址来操作对象

## Java集合类框架的基本接口有哪些？

Collections为顶级接口，子接口有List,Set

Map接口

## HashSet 和 TreeSet有什么区别

HashSet：
不能保证元素的排列顺序，顺序有可能发生变化
集合元素可以是null,但只能放入一个null
HashSet底层是采用HashMap实现的
HashSet底层是哈希表实现的

TreeSet：
Treeset中的数据是排好序的，不允许放入null值。不允许Null值
TreeSet是通过TreeMap实现的,只不过Set用的只是Map的key。
TreeSet的底层实现是采用二叉树（红-黑树）的数据结构。



两个都是元素不可重复的，一个是无序的，一个是有序的

hashSet取元素是无序的,而TreeSet取元素是根据插入顺序的

## hashSet的底层实现是什么

是hashMap的key，再创建hashSet的时候直接new了一个hashMap,许多方法直接是基于hashMap来写的

hashset是基于hashmap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75的hashmap。封装了一个hashmap 对象来存储所有的集合元素，所有放在 hashset中的集合元素实际上由 hashmap的key来保存，而 hashset中的 hashmap的 value则存储了一个PRESENT的静态object对象，hashset中的hashMap的value存储了一个静态object对象，key则用来作为hashSet的实现原理

## LinkedHashMap的实现原理

是基于hashMap并且再次基础上增加了一条双向链表

数组+链表+双向链表+红黑树

可以实现输出的顺序和插入的顺序是一致的

每个节点都进行了双向的连接，维持插入的顺序（默认），head指向第一个插入的结点,tail指向最后一个结点

LinkedHashMap相对于HashMap，增加了双链表的结果（即节点中增加了前后指针），其他处理逻辑与HashMap一致，同样也没有锁保护，多线程使用存在风险。

## 为什么集合类接口没有实现Cloneable和Serializable接口

克隆或者序列化的语义和含义是跟具体的实现相关的，因此应该由集合的具体实现类来决定如何被序列化和克隆，集合类的接口没有实现，但是集合类的具体实现实现了该两个接口

克隆：把一个对象里面的属性值赋值给另外一个对象，而不是引用的传递，复制

（2）实现Serializable序列化的作用

1.将对象的状态保存在存储媒体中一边可以在以后重写创建出完全相同的副本

2.按值将对象从一个应用程序域法相另一个应用程序域

实现Serializable接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想你的对象没有序列化，怎么才能在网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现序列化

假设集合类实现了这两个接口，如果我要生成一个不需要序列化，不需要clone的集合，那么集合类就强行实现，这样有违集合的设计原则。

## 什么是迭代器

迭代器是一种设计模式，它是一个对象，它可以遍历并且选择序列中的对象。

iterator为各种容器提供了公共的操作接口，隔离对容器的遍历操作和底层实现，从而解耦

缺点是增加新的集合类需要对应增加新的迭代器类，迭代器类与集合类成对增加

## iterator 和 ListIterator的区别是什么

区别：

iterator不仅可以迭代list还可以迭代set,ListIterator只能迭代List

ListIterator可以双向迭代，iterator只能单向迭代

ListIterator继承自iterator

iterator对集合只能是向前遍历，而ListIterator可以向前也可以向后

并且ListIterator可以获取前一个元素和后一个元素等等

## 数组和列表有什么区别？什么时候应该使用Array而不是ArrayList?

列表底层就是基于数组写的，但是是一个动态的数组，相当于就是底层会自动扩容

使用Array的情况一般是知道固定长度的，推荐使用Array+Arrays工具类

并且array是可以存放基本类型和对象类型，arrayList是只能存放对象类型

如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里

## Java集合类框架的最佳实践有哪些？

根据应用的需要选择合适的集合对性能是非常重要的，如果一个集合的元素数量是固定的，而且我们能够提前知道固定数量，那么就可以使用数组而不是ArrayList。如果我们可以提前预估初始容量，那么可以指定初始容量，节省扩容造成的性能降低。为了保证程序的健壮性和可读性，我们一般会使用泛型，如果是查询偏多的用数组类型的集合，如果是增删偏多的用链表类型的集合

## Comparable和Comparator接口是干什么的？列出它们的区别

两个接口都是用来排序的，列表可以基于该两个接口的某种规则来进行对数据的排序

两种方式，各有特点：使用Comparable方式比较时，直接将规则写入了需要比较的类型之中，其特点是高内聚。但是如果哪天规则需要更改，那么我们需要更改其源代码

如果使用Comparator方式比较，那么我们不需要修改比较的类，其特点是容易维护，只需要自定义一个比较器，后续更改规则只需要更改该比较器

## Collection 和 Collections的区别

Collection是顶级父接口，集合List和Set接口的父接口

Collections是集合的工具类，封装了许多对集合进行复杂操作的API,便于开发

# JVM

## JVM类加载过程

加载-》校验-》准备-》解析-》初始化-》使用-》销毁	

初始化的场景和时机：

- new关键词，调用getstatic,putstatic,invokestatic字节码指令必须对其类进行初始化

- 对一个类加载的时候，如果父类还没有加载，应该先对父类进行加载
- 启动程序所在的类 main方法所在的类加载
- 反射调用的时候需要加载类
- 当一个接口定义了jdk8中的default方法，如果它的实现类发生了初始化，那么也必须初始化

加载：

- 通过类的全限定类名来加载此类的二进制字节流，也就是该类对应的class文件
- 将字节流的静态存储结构转换为方法区的运行时数据结构
- 内存中生成代表该类的Class对象，作为方法区这个类的各种数据访问的入口

校验 ：

- 对字节码文件进行格式的校验，如是不是以0xCAFEBABE开头，主次版本号是否在虚拟机处理范围内
- 对元数据进行验证：判断是否存在继承多个类，是否将final声明的变量进行修改等(此处前端编译时候已经进行了大部分的优化)
- 字节码验证：通过数据流和控制流分析，确定程序语义是合法的，保证方法体中的类型转换是有效的，符合逻辑的(此处由于耗时太久，性能问题，被JVM优化到编译阶段，相当于从类型推导变为类型检查，给Code的属性表添加了一个StackMapTable的新属性，这项属性会开始时所有的本地变量表和操作数栈的状态)，
- 符号引用验证：判断通过符号引用是否能找到合适的类

准备：

- 对静态变量分配内存，并将其赋默认值

解析：

- 将间接引用转换为直接引用的过程，比如将全限定类名字面量转换为指向堆中的地址

校验和准备和解析式处于连接状态

## 描述一下JVM加载Class文件的原理机制？

使用类加载器加载Class文件，处于类加载的什么阶段？

属于类的加载阶段

通过类的全限定名读取读取二进制流文件

将二进制流文件的静态存储结构转换为动态存储结构

在内存中生成Class对象，作为方法区访问该类数据的入口

类装载方式有两种：

- 隐式装载：程序在运行过程中当碰到new,putstatic等方式生成对象时，隐式调用类加载器加载对应的类到JVM中
- 显式装载：通过class.forname()等方法，显式加载需要的类

**当类加载器需要加载类的时候，需要先需要parent，也就是父类加载器，如果父类加载器加载不了，那么才在自己的路径搜索该类，类确定唯一性需要该类本身和类加载器即使这两个类是同一个CLASS文件，但是只要加载它们的类加载器不同，那么它们就不相等**



## JAVA内存分配

虚拟机栈，线程私有  随着栈帧的入栈伴随操作数栈，局部变量表等信息

堆，线程共享 所有对象实例都被放在堆里面

方法区：1.8将永久代移除，改为元空间，1.7将永久代的字符串常量池移动到堆，由于永久代会造成和堆一起进行Full GC,并且还会造成内存泄漏

方法区主要存放：字面量比如final定义的变量，符号引用：如类的全限定名，方法名和属性

本地方法栈：与JAVA虚拟机栈类似，只不过JAVA虚拟机栈执行JAVA方法，本地方法栈执行本地语法方法，native

程序计数器：JVM中的指令执行顺序都是基于程序计数器进行的，它是程序分支，循环，跳转的基础

G1之前的垃圾收集器被分为 老年代和新生代

新生代又以8：1的比例被分为ed区和surivior区

G1以及ZGC,Sche是以Region区域来进行内存分配的，通常每个Region区域都一样大小

## GC是什么？为什么要有GC

GC是垃圾回收机制，如果没有垃圾回收机制那么堆里面没用的对象会一直无法被回收，造成内存一直扩大，显得是不行的。可以有效的使用可以使用的内存。

## 简述JAVA垃圾回收机制

如果一个对象没有直接指向GC ROOTS或者间接指向GC Roots，都认为该对象已经要被垃圾回收。

根据GC回收的时机可以分为：强引用，软引用，弱引用，虚引用

垃圾回收算法又有：标记清除算法，标记整理算法，标记复制算法，都有不同的应用场景

判断对象是否需要被回收有两种方式：

- 引用计数法
- 可达性分析算法

分代回收算法中，会根据对象的存活周期，将内存分为几块，一般是新生代和老年代

新生代又被分为Eden区和Survivor区

## 如何判断一个对象是否存活?(获取GC对象的判断方法)

可达性分析算法，如果一个对象没有直接指向GC ROOTS或者间接指向GC Roots，都认为该对象已经要被垃圾回收。

引用计数法，也可以用来判断，但是HotSpot没有使用该方法来判断，有一个引用计数器就+1，如果为0则进行回收，但是缺点是如果出现互相依赖，两个对象互相指向，这种情况比较难复杂处理

## 垃圾回收的优点和原理。并考虑2种回收机制

垃圾回收优点：可以有效的使用内存，并且使用内存不会无限扩大，JAVA的垃圾回收不需要程序员处理，是自动的，垃圾回收器通常作为一个单独的低级别线程(后台线程)运行，以不可预知的情况下对内存堆中已经死亡或者长时间没有使用的对象进行清除和回收

可达性分析算法，如果一个对象没有直接指向GC ROOTS或者间接指向GC Roots，都认为该对象已经要被垃圾回收。 缺点：需要枚举所有的GC roots，枚举过程需要暂停用户程序

引用计数法，也可以用来判断，但是HotSpot没有使用该方法来判断，有一个引用计数器就+1，如果为0则进行回收，但是缺点是如果出现互相依赖，两个对象互相指向，这种情况比较难复杂处理

## 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收

不可以马上回收内存，因为必须要等待安全点VM线程才可以进行垃圾回收

对于GC来说，创建对象后就开始监控这个对象的地址和大小等

采用有向图的方式来记录和管理堆中每个对象

分析出哪些对象是可达的，哪些是不可达的，不可达即认为该对象已经死亡即将准备进行垃圾回收

System.gc()主动通知虚拟机进行垃圾回收，这种方式也仅仅只是通知，具体还要看JVM内部如何处理

## JAVA中会存在内存泄露吗,请简单描述

存在,比如ThreadLocal就会有内存泄漏问题，threadlocal里面会存在一个threadlocalMap，里面的key保存的是弱引用的threadlocal,如果threadlocal在外部被回收了，那么key也就为null，里面的value值永远不会被取出来，存在问题

还有一种问题hashSet，当添加元素到hashSet中，那么这些元素的hashCode就不能再修改，否则与之前的hashCode值就不相同了，那么就无法取出该集合的元素和删除该元素

## 深拷贝和浅拷贝

浅拷贝复制值和地址

浅拷贝复制值，如果属性值是基本类型，那么拷贝的是值，如果是引用类型，那么拷贝的是地址

两个对象其中一个的引用类型更改地址，另外一个也会随之改变

**浅拷贝的实现：实现对象拷贝的类需要实现Cloneable,并且覆盖clone()方法。**

浅拷贝会造成数据安全方面的引用，比如只想修改A类里面的引用类型。造成拷贝对象的属性也发生变化，所以需要深拷贝

深拷贝，在拷贝引用类型的属性时候，为引用类型的成员另辟了一个独立的内存空间，实现真正内容上的拷贝

深拷贝的实现：对于有多层对象的，每个对象都应该实现Cloneable，并且覆盖clone()方法

 深拷贝相比于浅拷贝速度较慢并且花销较大。

比如说对象的引用类型成员变量也需要实现Cloneable方法

## System.gc() 和 Runtime.gc()会做什么事情？

会建议垃圾回收器进行收集，仅仅只是建议，具体还要看JVM内部

两者的作用没什么区别

System.gc()和runtime.gc()用于提示jvm进行垃圾回收，但是否立即回收还是延迟回收由java虚拟机决定

## finalize()方法什么时候被调用？析构函数的目的是什么？

在释放对象占用的内存之前，目的是可以使得对象在即将被垃圾收集的时候做一些回收工作,比如释放对象中持有的资源

## 如果对象的引用被置为null，垃圾回收器是否会立即释放对象对象占用的内存？

不会，垃圾回收是运行在后台的线程，只有用户线程运行到安全点或者安全区域的时候才会扫描对象引用关系，扫描到对象没有被引用则会标记，然后标记后才会开始清理内存

## 什么是分布式垃圾回收(DGC)?它是如何工作的？

当客户端创建远程引用时，会在服务器DGC上调用dirty()。客户端完成远程引用后，会调用对应的clean方法

并且客户端想要继续使用远程引用，必须调用dirty()进行续约

## 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？

串行收集器不支持垃圾收集器线程并行，而吞吐量支持与垃圾收集器并行，更关心程序的吞吐量

吞吐量 = 用户程序/用户程序+垃圾收集时间

serial新生代的使用标记复制算法，serial-old老年代使用标记整理算法

分别是控制最大垃圾收集器停顿时间 和 直接设置吞吐量大小的两个参数

-XX : MaxGCPauseMilis参数 最大GC暂停毫秒数 

-XX : GCTimeRatio 参数  设置吞吐量大小

## 在JAVA种，对象什么时候可以被垃圾回收?

在没有任何直接指向GC Roots的引用或者间接指向GC roots的引用就会被回收，也就是指当一个对象到GC Roots不可达的时候，在下一个垃圾回收周期会尝试回收该对象，如果这个对象重写了finalize()方法，并且成功自救(将自身赋值给某个引用)，那么就不会被回收，否则还是会被回收

## 简述JAVA内存分配与回收策略以及Minor GC和 Major GC

Minor GC : 指的是新生代的垃圾收集

Major GC : 指的是老年代的垃圾收集，目前只有CMS收集器会有单独收集老年代的行为

在进行垃圾回收的时候，刚创建的java实例会被放到eden区域，如果经历了一次垃圾回收还存在的话，那么就会被移动到survior区域，如果再经历几次的话，就会从新生代移动到老年代区域。泛指G1之前的垃圾收集器 G1之后的是移动Region区域

提供了-XX : PretenureSizeThreShold(门槛大小)参数 指定大于该数直接放入老年代

**对象优先在Eden区分配，大对象直接进入到老年代，长期存活的对象会进入老年代**

每个对象都有一个年龄计数器，存储在对象头，当第一次没有被收集后，会从Eden区域挪到survivor区域，同时把计数器加1，以后经过每一次垃圾收集都会加1，直到临界值默认为15会从新生代移动到老年代

如果survivor年龄相同大于该区域的一半，也会进入到老年代

## JVM的永久代种会发生垃圾收集么？

不会 1.8之前 堆和永久代的空间总是一起进行FULL GC的。 如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。

## JAVA中的垃圾收集的方法有哪些

该算法用于判断对象是否可被回收：可达性分析算法，引用计数法

回收算法：标记-清除，整理，复制

**当前的垃圾收集器，大多遵循了分代收集的理论进行设计 即** 

**弱分代假说：指的是认为绝大多数对象都是朝生熄灭的**

**强分代假说：对象经过越多的垃圾收集器回收越难消亡**

**跨代引用假说：跨代引用相对于同代引用来说占极少数**

## 什么是类加载器，类加载器有哪些？

实现通过类的全限定名获取该类的二进制字节流的代码块称为类加载器

类加载器有：

- 启动类加载器：加载rt.jar，加载最上层核心的类库

- 扩展类加载器：加载扩展的jar,lib/ext

- 系统类加载器，加载类路径下的class文件 classpath
- 用户自定义类加载器，通过继承ClassLoader实现

启动->扩展->系统->自定义

## 类加载器双亲委派模型机制? 有什么用？

类加载器有是三个：启动类加载器、扩展类加载器、应用程序加载器（系统加载器）

如果一个类被不同的类加载器加载，那么就会被认为不是同一个对象

并且在加载一个类的时候首先会从下向上寻找哪个类加载器可以加载类，便于管理和类层次的隔离

避免重复加载+避免核心类被篡改

如果发现父类加载器已经加载该类，那么没必要子类再加载一次

JAVA核心类api不会被随一替换，比如网络传递一个Integer的类，当找到启动类加载器发现该类已经加载，并不会核心类库的Integer

##  类似-Xms、-Xmx这些参数的含义？

-Xmx最大分配的内存由-Xmx指定

-Xms 初始分配的内存由-Xms指定

## 有什么方法来避免Full GC？

System.gc()调用

参数设置合理

老年代空间不足，可能大对象进入老年代的时候没有连续的内存空间，可以选择标记整理的垃圾收集算法

缩短对象生命周期，避免对象加入到old代

## CMS垃圾收集的原理

分为初始标记，并发并发，重新标记，并发清理

CMS是针对于老年代区域进行垃圾收集的，

初始标记：首先会暂停用户程序，枚举出所有的GC Roots，

并发标记：然后与用户程序并发执行，使用三色遍历法遍历标记出老年代所有的对象，

白色也就是没有被标记过，黑色是指已经标记过并且引用对象也已经处理完毕

灰色是指标记过但引用对象还没有标记完毕

重新标记：如果出现并发问题后，可以使用增量更新和原始快照来修复标记，这段时间暂停所有用户程序

并发清理：然后使用标记清除算法清除死亡的对象，由于是清除算法不需要移动对象，所以可以和用户程序并行

缺点：长时间运行，造成严重的内存碎片化,cpu资源敏感

## G1收集器原理

与之前的垃圾收集器有非常大的不同，G1则是根据Region区域来进行垃圾收集的，原始快照算法，存在跨引用解决办法为双向引用，哈希表，记录了我指向谁，还记录了谁指向我

也有初始标记的短暂停顿，枚举所有GC Roots

并发标记：标记区域中存活的对象，选取回收价值最高的一些区域进行回收，同时处理原始快照下有变动的记录

重新标记：暂停处理原始快照下的记录

回收：移动对象，把需要清理的存活对象移动到其他Region区域，暂停用户程序

## Shenadoah收集器原理

sheep的那个开头辅音,sh的音bai，she'nandou， shei nei dao rua

更像是G1的继承者，很多地方与G1类似，但是放弃了G1大量耗费内存的记忆集，使用了连接矩阵

只是在回收的时候不需要暂停用户程序，实现原理是在对象添加一个引用字段，放置自己的引用，如果移动了那么就同时更改对象里面的引用，相当于句柄，每次用户程序访问对象，先访问对象头，再通过对象头去访问到真正的对象地址

**其实也就是三个最重要的并发阶段(并发标记，并发回收，并发引用更新)**

## ZGC垃圾收集的原理

基本上所以过程都支持与用户程序进行并发处理，是一款低延迟垃圾收集器著称的产品，使用了**动态Region**，**读屏障**，**内存多重映射**，**染色指针**。可并**发标记的-标记-整理算法**，主要特点回收TB级内存(最大4TB)，停**顿时间不超过10ms**

大致分为基本步骤为：并发标记，并发预备分配，并发重分配，并发重映射

并发标记：也有初始标记的短暂停顿，枚举所有GC Roots，并发标记主要是基于整堆的，标记所有的存活对象，可与用户线程并发

并发预备重分配：选取需要收集的Region，这些区域形成一组重分配集，ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。

并发重分配：为这些重分配集的每个区域维护一张转发表(维护移动关系，旧地址到新地址)，每当用户程序访问这些对象的时候，会提前被读屏障截获，然后根据转发表去寻找新的内存地址，同时修正该引用

并发重映射：将修改该引用的情况称为指针的自愈，一次慢，不会每次都慢，这个阶段可以留到下一次垃圾回收再进行	

## 绑定，动态绑定，静态绑定？

绑定：将一个方法的调用与方法所在的类绑定起来，即决定调用哪个方法和变量

动态绑定：在运行期，虚拟机根据具体的对象类型进行绑定

静态绑定：在编译器，虚拟机就进行绑定

java当中的方法只有final、static、private修饰的的方法和构造方法是静态绑定的。

字节码指令层面：也就是invokestatic,和invokevirtual的private方法

动态绑定：是指普通方法，实例方法 对应的字节码指令 invokevirtual

## 说说逃逸分析和栈上替换

是指一个方法里面的对象会不会逃逸到其他方法或者逃逸到其他线程，比如说将方法里面的对象调用其他方法将该对象作为参数调用其他方法，这属于方法级别的逃逸

**如果对象不发生逃逸可以优化：**

- **栈上替换(不允许方法逃逸到方法之外),并且打散后分配到栈上，也就是依赖标量替换**
- **标量替换(不允许方法逃逸到方法之外)**
- **同步消除(不允许方法逃逸到线程之外)**

栈上替换是指如果没有逃逸到方法之外，那么就可以进行栈上替换，也就是指不在堆里面分配对象，直接在栈里面分配对象，随着栈帧的移出该对象就可以消失，减轻垃圾收集的压力

# 并发编程

## Synchronized用过吗？其原理是什么？

对应的字节码指令是monitorentry和moiterexit指令，虚拟机在执行monitorentry指令的时候会请求获取对象的monitor锁，也就是监视器锁，准确的来说是ObjectMonitor管程对象，然后锁里面有关于计数器的字段

当执行monitorenter时，若对象未被锁定时，或者当前线程已经拥有了此对象的monitor锁，则锁计数器+1，该线程获取该对象锁。 

当执行monitorexit时，锁计数器-1，当计数器为0时，此对象锁就被释放了。那么其他阻塞的线程则可以请求获取该monitor锁。

原理jdk1.6之前使用的是操作系统的mutex指令，互斥原语。

1.6之后进行了锁升级  无锁-偏向锁-轻量级锁-重量级锁

## 你刚才提到获取对象的锁，这个锁到底是什么?如何确定对象的锁？

每个对象都有一个唯一的监视器锁，锁指的就是对象的监视器锁，在对象的markword上保存关于锁的信息

如果Synchronized明确指定了锁对象 比如 Synchronized(对象)或者Synchronized(this) 表明的是锁的该对象的ObjectMonitor管程对象

如果直接标在方法上并且是实例方法，表明锁的是当前类的对象

如果标在方法上，并且方法是静态方法，表明锁的是当前类，锁的范围更大

## 什么是可重入性，为什么说Synchronized是可重入锁？

就是在一个加锁的逻辑方法进入另外一个带相同对象锁的方法，称为可重入性

就是指一个对象的锁被重复进入了多次

因为Synchronized底层是默认支持可重入的，通过两个字段 一个是当前属于对象哪个占有锁，一个是计数器，每次进入锁+1，退出锁-1，直到完全释放锁 该计数器为0才认为已经释放锁

## JVM对java的原生锁做了哪些优化？

1.6之后进行了锁升级  

无锁-偏向锁-轻量级锁-重量级锁

## 为什么说 Synchronized 是非公平锁？

因为线程抢占是可以不按照顺序的，比如entryList字段里面有许多个线程在等待占有锁的线程释放锁，此时占有锁的线程释放后，又过来一个线程，如果是公平锁就会加入到阻塞队列的队尾，但Synchronized 可能会直接抢占到锁，所以说是非公平锁，目的是为了提高性能，但缺点是可能会产生线程饥饿现象

## 什么是锁消除和锁粗化？

锁消除：是指虚拟机即时编译器在运行时，对一些代码要求同步，但检测到不可能有共享数据，那么就会进行锁消除

程序员为什么会向没有共享数据的程序加锁呢？ 很多不是程序员自己加入的

锁粗化：是指增大锁的作用域

## 为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？

因为他总是在进入临界区的时候先进行加锁，然后再修改，是一个悲观的，认为每次都会有人抢占锁

而乐观锁的CAS实现原理 内存地址，预期值，和修改后的值

每次修改的时候是一种乐观的心态，每次都认为没有人抢占，先比较想修改的值是否和预期值相等，如果是则修改，如果不是则修改失败，也就是先操作，如果没有其他线程征用数据，那么就操作成功了

底层基于汇编指令的比较并替换指令，cmpxchg

CAS缺点

- 循环时间长CPU开销大
- 只能保证一个共享变量的原子操作
- 会引发ABA问题

## 乐观锁一定就是好的吗？

不一定，乐观锁首先不支持一段临界区的加锁逻辑，只是针对于单个变量或者单个对象而言

并且如果频繁的造成与预期值不符合，造成频繁的重试，那么可能还不如悲观锁

因为CPU会存在不停重试，不停的自旋，造成CPU资源浪费

ABA

## 跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？

**其实锁的实现原理基本上都是为了让所有线程看到某种标记**

实现很类似，但是提供了更强大的功能，比如绑定多个条件，Synchronized只能绑定一个条件，还有根据指定时间获取，jdk1.6之前性能ReentrantLock跟更强大，1.6之后Synchronized做了优化，性能差不多，因为是基于JVM底层做的，甚至比ReentrantLock性能更好

Synchronized 是基于对象头设置标记，是JVM原生的锁实现方式

ReentrantLock 是基于volatile的int变量设置标记，是实现了Lock接口，内部类实现了AQS框架

ReentrantLock 并且是基于AQS同步框架来进行构建的

## 那么请谈谈 AQS 框架是怎么回事儿？

AQS是一个用来构建锁和同步器的框架，比如可重入锁，读写锁，信号量，CountDownLatch等

AQS在内部定义了一个volatile的state变量，用来控制并发，比如排他锁并且不支持重入的话，只需要设置state变量初始化为1，如果获取到锁减为0，其他线程必须判断为1才可以获取锁，否则就进入队列等待

里面封装了Node类，Node类表示的是对要访问同步代码块的线程封装，每个Node结点关联Pre和Next，用来方便释放锁后，快速唤醒下一个线程，是一个FIFO模式

Node类内部有两个Node对象，分别为Shared和EXCLUSIVE，共享和排他，用来实现不同的逻辑

共享是指多个线程可以同时访问，必须Sempahore就是使用共享锁来实现的

ReentrantLock就是使用排他锁来实现的

AQS是一个同步框架，使用的是模板方法模式，内部定义好了许多已经的架构，实现锁的人只需要编写适合自己的重写方法，比如共享锁或者排他锁，然后进行逻辑的实现，不需要写一些加入队列，唤醒等复杂功能，AQS已经提供好

## 请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。

同为排他锁，ReentrantLock有公平锁和非公平锁两种逻辑，Synchronized 只有非公平锁

ReentrantLock条件是基于Condition对象，可以获取多个条件

Synchronized的等待和唤醒是基于Object的wait()方法和notify()和notifyall()方法

而ReentrantLock是基于Condition的await()方法和signal()

Condition底层是基于park和unpark的LockSupport类

ReentrantLock拥有比Synchronized 更强大的功能：

- 实现公平锁
- 可以绑定多个条件来进行await()
- 带超时的锁尝试获取
- 可以响应中断请求

jdk6以后，竞争不激烈的时候Synchronized 优于ReentrantLock。竞争激烈的时候相差不大

## ReentrantLock 是如何实现可重入性的？

根据一个state字段和一个owner字段

每次线程进行判断是否是当前线程，如果是将state字段加1，如果不是加入阻塞队列队尾

在进行重入的适合，首先判断owner字段是不是空，如果不是空并且还等于当前线程，那么则认为是锁的重入，进行state再加1，以此类推

直到锁释放的时候，当state字段为0，将owner字段清空，否则不清空

## 除了ReentrantLock，你还接触过JUC中哪些并发工具？

读写锁，ConcurrentHashMap,CopyOnWriteList，信号量Semphore，线程池

阻塞队列，volatile，原子类，LongAddr,解决CAS的ABA问题的工具类(额外加版本号)，循环屏障

CyclicBarrier,CountDownLatch

强大的Executor框架

## CyclicBarrier和CountDownLatch看起来很相似，请对比下呢

CountDownLatch是指定一个变量，每被一个线程执行一次就减1，然后直到0，才可以继续执行,适用于线程一起处于某行代码，同时执行的场景

CountDownLatch的基本操作是 countDown/await()

CyclicBarrier是可循环利用的 

CyclicBarrier的基本操作是 await()

而CyclicBarrier目的是让多个线程同时达到某种状态，然后再各自去执行后续的代码，而CountDownLatch更偏向于等待某一时刻，同时去并发执行

## JAVA中的线程池是如何实现的？

JAVA中所谓的线程池的线程，其实被抽象为一个静态内部类Worker类，它基于AQS实现。存在在线程池的HashSet<Worker> workers成员变量中

核心思想就是从workQueue中不断取出任务放在workers中处理

## 创建线程池的几个核心构造参数？

corePoolSize ：核心线程数大小，线程池里面首先会创建该指定大小的线程，不会加入到阻塞队列，除非该指定线程数满

阻塞队列 workQueue：核心线程数满了以后，会将任务放入到阻塞队列中

最大线程数 maximumPoolSize：当从核心线程都处于忙碌的适合，如果阻塞队列还存在任务无法被执行，那么会创建该线程，直到该线程数满

拒绝策略：当普通线程数满了阻塞队列也满的时候，就需要一些策略

- 扔掉提交来的任务
- 报错
- 扔掉阻塞队列头的任务，将新任务加入到队尾

## 线程池的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？

显然不是的。线程池默认初始化后不启动 Worker，等待有请求时才启动。

每当我们调用 execute() 方法添加一个任务时，线程池会做如下判断：

	如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；
	
	如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；
	
	如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； //队列满，并且线程数量小于maximumPoolSize
	
	如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。

当一个线程完成任务时，它会从队列中取下一个任务来执行。 当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断。

如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。



## 既然提到可以通过配置不同参数创建出不同的线程池，那么 Java 中默认实现好的线程池又有哪些呢？请比较它们的异同

1.SingleThreadExecutor 线程池

这个线程池只有一个核心线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，
那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。

	corePoolSize：1，只有一个核心线程在工作。
	maximumPoolSize：1。
	keepAliveTime：0L。
	workQueue：new LinkedBlockingQueue<Runnable>()，其缓冲队列是无界的。

2. FixedThreadPool 线程池

FixedThreadPool 是固定大小的线程池，只有核心线程。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。

FixedThreadPool 多数针对一些很稳定很固定的正规并发线程，多用于服务器。

```java
corePoolSize：nThreads
	maximumPoolSize：nThreads
	keepAliveTime：0L
	workQueue：new LinkedBlockingQueue<Runnable>()，其缓冲队列是无界的。
```

3. CachedThreadPool 线程池

CachedThreadPool 是无界线程池，如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）线程，
当任务数增加时，此线程池又可以智能的添加新线程来处理任务。

线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。SynchronousQueue 是一个是缓冲区为 1 的阻塞队列。

缓存型池子通常用于执行一些生存期很短的异步型任务，因此在一些面向连接的 daemon 型 SERVER 中用得不多。
但对于生存期短的异步任务，它是 Executor 的首选。

```java
	corePoolSize：0
	maximumPoolSize：Integer.MAX_VALUE
	keepAliveTime：60L
	workQueue：new SynchronousQueue<Runnable>()，一个是缓冲区为 1 的阻塞队列。
```



4. ScheduledThreadPool 线程池

ScheduledThreadPool：核心线程池固定，大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。
创建一个周期性执行任务的线程池。如果闲置，非核心线程池会在 DEFAULT_KEEPALIVEMILLIS 时间内回收。

```java
	corePoolSize：corePoolSize
	maximumPoolSize：Integer.MAX_VALUE
	keepAliveTime：DEFAULT_KEEPALIVE_MILLIS
	workQueue：new DelayedWorkQueue()
```



## 如何在 Java 线程池中提交任务？

execute()方法用来提交一个Runnable任务

submit()方法提交任务后返回一个Future对象，可以使用isDone,isSuccess方法用来判断任务是否已经完成，可以使用get()来获取结果。并且get()还是阻塞的

## 什么是JAVA的内存模型，JAVA中各个线程是怎么看到彼此对方的变量的？

JAVA内存模型是屏蔽操作系统的内存模型构建的，实现了自己的内存模型逻辑，主要是为了解决线程互相访问造成的可见性和安全性问题

JAVA中将线程的分为工作内存，独占的。共享的为主内存，线程需要从主内存读取数据到自己的工作内存，然后写回数据的时候将工作内存写回到主内存供其他线程访问

## 请谈谈Volatile有什么特点?为什么它能保证变量对所有线程的可见性？

volatile解决了线程的有序和可见性。

操作系统层面底层使用的是Lock前缀指令，该指令相当于每次操作volatile变量，都会造成缓存了volatile变量的缓存行失效，去主内存读取最新的数据，保证每次读到的都是最新的数据

JVM层面使用的是 从主内存读取到工作内存并且使用，这一系列操作不可中断  read,load,use

read：从主内存变量读到工作内存

load：将从主内存过来的值放入本地内存的变量副本中

use：将本地内存的变量副本的值输出给执行引擎

从工作内存写入到主内存，再从主内存写入到主内存变量，这一系列也必须是连续的 assign,store,write连续

assign：执行引擎赋值给工作变量

store：变量传递给主内存

write：将本地内存传来的值赋值为主内存变量

有序性是因为会插入内存屏障来保证，

读读屏障：指的是在进行读第二个volatile变量的时候，必须保证第一个的读已经全部完毕

读写屏障,写读屏障 StoreLoadBarrie 是全能屏障，写写屏障

## 既然Volatile能够保证线程间的变量可见性，是不是意味这基于volatile的运算就是并发安全的？

不是，没有实现运算原子性，也会造成线程安全问题

## 请对比下volatile和synchronized的异同？

同：都实现了线程的二大特性 可见性和有序性

异：如果是运算或者是临界区代码，volatile是会出现线程安全问题的，synchronized则不会，因为还实现了原子性

## 请谈谈ThreadLocal是怎么解决并发安全的?

是隔离每个线程，相当于每个线程都可以保存一份数据，互相不影响

ThreadLocal类中有一个ThreadLocalMap，会从线程获取ThreadLocalmap，如果为Null则创建

然后保存，map的key为弱引用的ThreadLocal，value就为值

## 很多人都说要慎用ThreadLocal,谈谈你的理解，使用ThradLocal需要注意什么？

我认为没有什么慎用不慎用的，结合需求 如果有的场景使用ThreadLocal解决更合适那还是需要用的。

ThreadLocal需要注意的是内存泄漏，如果使用完毕没有remove掉，会造成内存泄漏，永远无法移除该变量

## CountDownLatch和CyclicBarrier和Semaphore使用场景？三者有什么区别？

CountDownLatch是一个倒计数

- 适用于让所有线程去同时并发
- 跑步比赛，裁判需要等到所有的运动员（“其他线程”）都跑到终点（达到目标），才能去算排名和颁奖。

被等待线程调用 countDown将计数器减1，等待线程调用await()进行线程等待

CyclicBarrier循环栅栏，和CountDownLatch非常相似，只不过可以反复循环使用

比如调用await()每次调用计数器减1，直到减为0，阻塞解除，上面的线程可以开始运行，

如果再继续调用await()，又会变为n-1,以此循环

基于ReentrantLock + Condition条件队列 trip实现

Semaphore是用来控制并发数的，同一时刻最多有多少线程执行临界区代码

# Spring面试专题

## 什么是Spring框架？Spring框架有哪些主要模块？

核心容器，数据访问，WEB,AOP 我们通常所说的Spring指的是SpringFramework，测试等

目的是为了简化JAVA后端开发工作

## 使用Spring框架能带来哪些好处？

优点：

- 使我们的程序方便解耦，简化开发
- 声明事务的支持,非常方便
- 方便集成各种优秀框架
- AOP编程的支持
- 轻量级
- 控制反转
- MVC框架
- 异常处理
- 容器

便于管理，自动注入，AOP等等

好处：

- Spring能够有效的组织我们的对象
- Spring简化我们访问数据库

## 什么是控制反转(IOC)？什么是依赖注入？

就是将以前我们主动new的对象交给容器帮我们创建，便于统一管理，我们需要的时候从容器中取。基于一种面向对象编程中的一种设计原则，用来降级对象之间的强耦合性，由自己主动创建，变为被动获取

依赖注入相当于从容器中获取对象实例，像这种非自己主动初始化依赖，而通过外部传入依赖的方式，称为依赖注入，方便解耦

- **控制反转是一种思想**
- **依赖注入是一种设计模式**

## 请解释下Spring框架中的IOC?

相当于就是一个单例池，所有的对象经过BeanDefineion包装后会放入到SingleonObjects,是一个MAP对象	

BeanFactory是Spring IOC容器的具体实现，用来包装和管理各种放在容器中的Bean，BeanFactory接口是Spring IoC 容器的核心接口

## BeanFactory和ApplicationContext有什么区别？

BeanFactory是顶级接口，提供了容器最简单的功能，比如从容器中获取Bean，判断bean是否在容器中，判断是否是单例的，管理Bean的加载和实例化等

ApplicationContext是BeanFactory的子接口

ApplicationContext通过能完成比BeanFactory更强大的功能，比如

- 国际化
- 访问资源 如URL和文件
- AOP
- 同时加载多个配置文件

而BeanFactory主要则是管理Bean的，BeanFactory采用的是延迟加载的形式来注入Bean，只有使用到某个Bean的时候(调用getBean())，才对该Bean进行实例化

ApplicationContext在容器启动的时候就加载了所有的Bean，便于错误尽早的发现

## Spring有几种配置方式？

- 基于XML配置的方式
- 基于JAVA配置的方式
- 基于注解配置的方式

## 如何用于XML配置的方式配置Spring？

如果Bean不是自己编写的类，比如第三方的某个类，就需要使用XML方式来将该类注入到容器

```xml
<beans>

    <!-- JSON Support -->
    <bean name="viewResolver" class="org.springframework.web.servlet.view.BeanNameViewResolver"/>
    <bean name="jsonTemplate" class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/>

    <bean id="restTemplate" class="org.springframework.web.client.RestTemplate"/>

</beans>
```



## 如何用于JAVA配置的方式配置Spring

@Bean 用于方法上，表示返回值是要一个bean

@Configuration 相当于告诉Spring该类是一个配置类，相当于配置文件的XML

## 如何用于注解配置的方式配置Spring？

@Controller

@Service

@Compoent

@Repository

注解和JAVA配置的话，涉及业务的话推荐使用注解配置

如果是全局配置，数据库配置等推荐使用JAVA配置

## 请详细解释下Bean的生命周期？

Bean的完整声明周期经历了各种方法调用，这些方法可以划分为以下几类：

- Bean自身的方法
  - init-method()方法和destory-method指定的方法 也就是PostConstruct注解和PreDestory注解

- Bean级生命周期接口方法
  - 这个包括了**BeanNameAware**,**BeanFactoryAware**,InitializingBean和DiposableBean这些接口的方法

- 容器级生命周期的接口方法
  - **BeanPostProcessor**,**InstantiationAwareBeanPostProcess**，一般称它们的实现类为后置处理器

- 工厂后处理器接口方法
  - ConfigurationClassPostProcessor,CustomAutowireConfigur等等

完整版生命周期：

- 我们先在我们需要获取bean对象的方法中调用ApplicationContext容器，该容器和BeanFactory不同，会在容器启动时初始化IOC容器，也就是初始化所有组件，会读取资源文件，注册国际化功能，注册后置处理器等等
- **FinishBeanFactorysInitiailzation**方法完成初始化所有单实例非懒加载的Bean
- 会根据List集合里面所有的BeanName循环遍历根据每个Name从BeanDefinetionMap中获取每个BeanDefineion详细详细
- 判断是否是单例的，是否不是懒加载的等，然后先尝试从容器中拿，如果没有则调用创建Bean对象
- 然后还会判断是否允许循环依赖，是否没有在创建中等，如果允许循环依赖并且该类还正在创建中，则开始循环依赖的逻辑
- 否则，调用createBean()方法创建Bean,
- resolveBeforeInstantiation()方法循环调用InstantionBeanPostProcessor接口，则开始执行该接口的**postProcessorBeforeInstantion**()方法，一般用于Spring的扩展
- 然后开始调用doCreateBean()方法创建Bean的实例，并且被包装成一个实例对象，此时的Bean是普通的JAVA Bean，属性注入，和PostContruct方法都没有生效，也就是通过反射创建一个普通的JAVA对象
- 然后调用populationBean()方法进行属性注入，比如标注了AutoWire注解就是该方法进行赋值的，该方法还会执行InstantionBeanPostProcessor的**postProcessorafterInstantion**()方法
- **initializeBean**()调用该方法，开始判断该类是否实现了Aware接口，又判断是否实现了BeanNameAware等接口，然后循环执行BeanPostProcessor()的postProcessorBeforeInitlization()方法，也用于Spring的扩展，同时该方法也是进行判断是否配置了Init-method()方法或者标注了PostConstruct方法，然后再执行postProcessorAfterInitization()方法

**即Bean的生命周期：**
**postProcessBeforeInstantiation（实例化前置处理器{前提是返回null}）--->  postProcessAfterInstantiation（实例化后置处理器） ---> postProcessPropertyValues（实例化的属性值） ---> Aware(BeanNameAware、BeanFactoryAware...) ----> postProcessBeforeInitialization（初始化前处理器） ---> lnitializingBean接口的afterPropertiesSet ---> init-method(自定义配置的初始化init-method方法) ---> postProcessAfterInitialization（初始化后处理器）**


首先获取实例封装为BeanDefinetion对象，放入集合

然后拿到所有的BeanPostProcessor，循环调用beforeInitzation方法

然后创建对象实例，只是通过反射单纯的创建对象，然后通过包装类包装

还会判断是否是单例的，支持循环依赖的

然后进行populaion bean方法进行依赖注入，依赖注入的时候首先会拿到所有的InstantAwareBeanPostProcessor去调																			用它的afterInstant方法，如果该类没有循环依赖，

那么再进行 initMethod()对标注了postConstruact方法，完成之后再调用BeanPostProcessor的after方法

然后将对象放入的单例池中 循环依赖的三个Map？

**SingleonObjects 单例池**

**earlySingleOnObjects**

**SingleonFactories**

扩展的用处可能是一些提前注入资源文件啊，自定义注解注入一些值啊，反射调用什么的

## Spring Bean的作用域之间有什么区别？

可以通过scope属性来指定Bean的作用域

- singleton：默认值，单例的，每次得到的都是同一个对象
- prototype：原型的，当IOC创建的时候不会实例化该bean，每次getBean()方法都会得到一个新的对象
- request : 每次请求实例化一个Bean
- session ：在一次会话中共享一个Bean

## 什么是Spring inner beans？

```xml
<bean id="CustomerBean" class="com.somnus.common.Customer">
         <property name="person">             
		         <!-- This is inner bean -->             
		         <bean class="com.howtodoinjava.common.Person">                 
				         <property name="name" value="lokesh" />                 
				         <property name="address" value="India" />                 
				         <property name="age" value="34" />
		        </bean>         
        </property>     
</bean>
```

就是类里面的实例变量有其他类

## Spring框架中的单例Beans是线程安全的么？

Spring框架没有对单例Bean进行任何多线程的封装处理。关于单例Bean的线程安全问题和并发问题需要自己去搞定。但是大多数部分的SpringBean并不会变(Service,Dao)所以某种程度上可以说是线程安全的. 如果你的bean有多种状态的话(比如View Model)对象,就需要自行去保证线程安全

最明显的解决办法就是将Bean的作用域从 Singleton改为原型对象,这样都是不同Bean,不会出现线程安全问题

## 	请举例说明如何在Spring中注入一个JAVA Collections？

Spring提供了集合类的配置元素

<list></list>标签

```xml
 <property name="customList">
        <list>
           <value>INDIA</value>
           <value>Pakistan</value>
           <value>USA</value>
           <value>UK</value>
        </list>
      </property>
```

## 如何向Spring Bean中注入一个JAVA.Util.Properties？

<props></props> 标签

还可以注入Set集合,Map对象 

<set></set>

map标签

     <!-- java.util.Properties -->
    <property name="customProperies">
        <props>
            <prop key="admin">admin@nospam.com</prop>
            <prop key="support">support@nospam.com</prop>
        </props>
    </property>
## 请解释Spring的自动装配?

首先解释一下Spring的自动装配,那么就是在xml中把每个属性都手动设置值

自动装配有两种方式,xml和注解方式

```xml
<bean id="people" class="com.kuang.pojo.Peopel" autowire="byName">
        <property name="name" value="张三"/>
</bean>
```

声明bean的装配方式,可选值为byName,byType,Construct,defalut,no;

如果是根据byName,会根据People类的get和set方法 比如 setDog,那么name就为dog,然后寻找id = dog的类进行属性装配

![img](https://img2020.cnblogs.com/blog/1965263/202003/1965263-20200320134846404-787247076.png)

byType:

![image-20210312110306518](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210312110306518.png)

如果是根据type来进行属性注入,那么会寻找一个与属性的类型相同的Bean注入进来,使用ByType这种方式,必须保证配置文件中所有的bean的class属性值是唯一的,否则就会报错

方式二 : 通过注解实现自动装配

底层是通过反射来实现的,

使用注解前的准备:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans>

    <context:annotation-config/>

</beans>
```

2.使用**Autowired**注解

**注解方式寻找方式首先优先去根据属性类型去寻找,如果找到多个则再根据属性的名称作为Id去容器中查找**

可以使用@Qualifier注解可以和该注解搭配使用

@Qualifier需要指定属性的id,而不是属性名

@Autowired是Spring定义的

@Resource是JAVA规范

**@Resource默认是按照组件名称来进行装配,按照组件名称作为id找不到就根据属性类型去查找,再找不到就报错**

## 请解释自动装配模式的区别？

在Spring 框架中共有5 种自动装配，让我们逐一分析。

1.no：这是Spring 框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean 定义中用标签明确的设置依赖关系。

2.byName：该选项可以根据bean 名称设置依赖关系。当向一个bean 中自动装配一个属性时，容器将根据bean 的名称自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。

3.byType：该选项可以根据bean 类型设置依赖关系。当向一个bean 中自动装配一个属性时，容器将根据bean 的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。

4.constructor：造器的自动装配和byType 模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。

5.default默认使用no方式

byType,byName,Construct,default,no

## Spring的事务实现方式？

核心接口

![img](https://images.cnblogs.com/cnblogs_com/zengweiming/590190/o_20160324011156424.png)

事务平台管理器,PlatformTranscationManager

Spring并不会直接管理事务,而是提供了多种事务管理器,将具体的实现委托给Hibernate或者JTA,JPA等持久化机制相关的平台

**PlatformTranscationManager**通过这个接口,Spring为各个平台JDBC,Hibernate都提供了对应的事务管理器,具体的实现就是各个平台的事情了

主要定义了获取事务,提交事务,回滚事务的方法

**getTransaction(TransactionDefinition definition) //获取事务,**

**commit() //提交,**

**rollback() //回滚**

比如具体实现的 DataSourceTranscationManager对jdbc进行事务管理

```xml
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"> <property name="dataSource" ref="dataSource" /> </bean>
<bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"> <property name="sessionFactory" ref="sessionFactory" /> </bean>
```

基础事务属性定义

getTranscation获取一个事务,参数TransactionDefinition类型,里面主要包括了一系列的事务属性,可以理解为事务的一些基本配置 

比如 

- **传播规则**
- **隔离级别**
- **回滚机制**
- **是否只读**
- **事务超时**

![image-20210312121741132](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210312121741132.png)



```java
getPropagationBehavior() //获取事务传播行为
getIsolationLevel() //获取事务隔离级别,
getTimeout() //获取超时时间,
isReadOnly() //事务是否只读
```

```java
public interface TransactionDefinition {
    int PROPAGATION_REQUIRED = 0; //要求必须运行在事务中,如果没有则开启一个事务
    int PROPAGATION_SUPPORTS = 1;
    int PROPAGATION_MANDATORY = 2;
    int PROPAGATION_REQUIRES_NEW = 3;
    int PROPAGATION_NOT_SUPPORTED = 4;
    int PROPAGATION_NEVER = 5;
    int PROPAGATION_NESTED = 6;
    int ISOLATION_DEFAULT = -1; //使用数据库默认的隔离级别
    int ISOLATION_READ_UNCOMMITTED = 1;
    int ISOLATION_READ_COMMITTED = 2;
    int ISOLATION_REPEATABLE_READ = 4;
    int ISOLATION_SERIALIZABLE = 8;
    int TIMEOUT_DEFAULT = -1;

    int getPropagationBehavior(); //获取事务的传播行为	

    int getIsolationLevel(); 获取隔离级别

    int getTimeout(); 

    boolean isReadOnly(); 是否只读

    String getName();
}
```

事务7种传播规则

- **PROPAGATION_REQUIRED,表示当前方法必须运行在事务之中,如果当前事务存在,方法将会在该事务中运行,否则开启一个新的事务**
- PROPAGATION_SUPPORTS : 表示方法不需要事务,但是如果存在当前事务的话,那么该方法会在这个事务中运行
- PROPAGEATION_MANDATORY : 表示方法必须在事务中运行,如果事务不存在,则抛出一个异常,也就是说，只能被一个父事务调用。否则，他就要抛出异常
- **PROPAGEATION_REQUIRED_NEW : 表示方法必须运行在它自己的事务中,一个新的事务将被启动,如果已经存在事务,那么会挂起,然后新建一个事务**

- PROPAGEATION_NOT_SUPPORTED : 表示方法不应该运行在事务之中,如果存在当前事务,事务则会被挂起
- PROPAGEATION_NEVER : 表示当前方法不应该运行在事务上下文中,如果有一个事务正在运行,则抛出异常
- **PROPAGEATION_NESTED :  如果已经存在了一个事务,那么该方法会在嵌套事务中运行,嵌套的事务可以独立,单独进行提交和回滚操作,如果不存在事务那么则以REQUIRED方式来执行**

嵌套事务他是已经存在事务的一个真正的子事务,于REQUIRED不同的是,REQUIRES_NEW不同在于NEW完全是一个新的事务,与外部事务隔离的,而嵌套事务则是外部事务的子事务,外部事务提交,那么内部事务也提交,这个规则同样适用于回滚

```java

ServiceA {
       
     void methodA() {
         ServiceB.methodB();
     }
  
}
  
ServiceB {
       
     void methodB() {
     }
       

```

比如说MehtodA是REQUIRED事务级别,methodB是NESTED嵌套级别,那么当调用A的时候,ServiceB调用methodB(),此时外部事务会挂起,ServiceB.methodB会新建一个子事务,并且设置保存点**savePoint**,等待ServiceB.methodB提交后,它才继续执行,如果这个子事务失败,将会回滚到**savePoint**

1、如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，**ServiceB.methodB也将回滚**。本质上也就是只有ServiceA.methodA提交后,ServiceB.methodB才能正常提交
2、如果ServiceB.methodB失败回滚，如果他抛出的异常被ServiceA.methodA的try..catch捕获并处理，ServiceA.methodA事务仍然可能提交；如果他抛出的异常未被ServiceA.methodA捕获处理，ServiceA.methodA事务将回滚。

只读

事务第三个特性它是否为只读事务,如果是则可以利用事务的特性来进行一些特定调用优化

事务超时

为了使应用更好的进行,事务不能运行太长时间 如果时间太久,则进行回滚

事务状态

```java
TransactionStatus接口的内容如上图：
主要定义了
isNewTransaction(); // 是否是新的事物
hasSavepoint(); // 是否有恢复点
setRollbackOnly(); // 设置为只回滚
isRollbackOnly(); // 是否为只回滚
isCompleted; // 是否已完成
```

**事务的实现方式**

- **声明式事务**
- **编程式事务**

声明式事务(基于AOP)有助于用户将操作与事务规则进行解耦

编程式事务侵入到了代码里面,但是提供了更详细的事务管理;声明式事务由于基于AOP,所以更能起到事务管理的作用,又可以不影响业务代码的具体实现

## Spring框架的事务管理有哪些优点？

支持声明式事务管理,为各个事务平台提供了一个不变的编程模式,如JPA,JDBC,Hibernate

和Spring各种数据访问抽象层很好得集成

## Spring事务的传播规则？

事务7种传播规则

- **PROPAGATION_REQUIRED,表示当前方法必须运行在事务之中,如果当前事务存在,方法将会在该事务中运行,否则开启一个新的事务**
- PROPAGATION_SUPPORTS : 表示方法不需要事务,但是如果存在当前事务的话,那么该方法会在这个事务中运行
- PROPAGEATION_MANDATORY : 表示方法必须在事务中运行,如果事务不存在,则抛出一个异常,也就是说，只能被一个父事务调用。否则，他就要抛出异常
- **PROPAGEATION_REQUIRED_NEW : 表示方法必须运行在它自己的事务中,一个新的事务将被启动,如果已经存在事务,那么会挂起,然后新建一个事务**

- PROPAGEATION_NOT_SUPPORTED : 表示方法不应该运行在事务之中,如果存在当前事务,事务则会被挂起
- PROPAGEATION_NEVER : 表示当前方法不应该运行在事务上下文中,如果有一个事务正在运行,则抛出异常
- **PROPAGEATION_NESTED :  如果已经存在了一个事务,那么该方法会在嵌套事务中运行,嵌套的事务可以独立,单独进行提交和回滚操作,如果不存在事务那么则以REQUIRED方式来执行**

嵌套事务他是已经存在事务的一个真正的子事务,于REQUIRED不同的是,REQUIRES_NEW不同在于NEW完全是一个新的事务,与外部事务隔离的,而嵌套事务则是外部事务的子事务,外部事务提交,那么内部事务也提交,这个规则同样适用于回滚

## Spring事务底层原理？

## Spring面向切面编程(AOP)

面向对象编程是把程序抽象为各个层次的对象，而面向切面编程是把程序抽象成各个切面，AOP是一种编程思想。

![image-20210315100406944](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210315100406944.png)

为什么需要AOP？

开发者可以在不修改源代码的前提下，去为系统增加某种通用功能。

并且AOP实现可以分为两类

- 静态AOP
- 动态AOP

静态AOP是指在编译期直接就修改class文件，直接生成静态的AOP代理类，需要特定的编译器，比如AspectJ

动态AOP是指在运行阶段动态生成代理对象(在内存中以JDK动态代理，或者CGlib动态代理生成AOP代理类)，如SpringAop

![image-20210315101300853](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210315101300853.png)

![image-20210315101606198](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210315101606198.png)

**JDK必须通过实现接口，而CGlib通过继承所以不能代理final修饰的类和final修饰的方法**

AOP领域的术语：

- 通知：通知会在目标方法的运行前后执行
- 连接点：可以说切点是连接点的子集，如果我们没有配置条件，那么就是全部方法就是连接点。可以连接到的点
- 切点：就是定义要进行增强的方法，相当于我们配置的满足我们条件的目标方法
- 切面：定义一个切面，里面定义切点方法或者标签
- 引入：引入允许我们向现有的类添加新的方法或者属性
- 织入 : 将增加处理添加到对象上，并且创建一个被增强的对象，这个过程就是织入。

通知 : 

简单例子：

这个例子是基于gradle创建的，首先 build.gradle 文件添加依赖：

```java
dependencies {
    compile 'org.springframework:spring-context:5.0.6.RELEASE'
}
```

首先创建一个接口 IBuy.java

```java
package com.sharpcj.aopdemo.test1;

public interface IBuy {
    String buy();
}
```

Boy 和 Gril 两个类分别实现了这个接口：
Boy.java

```java
package com.sharpcj.aopdemo.test1;

import org.springframework.stereotype.Component;

@Component
public class Boy implements IBuy {
    @Override
    public String buy() {
        System.out.println("男孩买了一个游戏机");
        return "游戏机";
    }
}
```

Girl.java

```java
package com.sharpcj.aopdemo.test1;

import org.springframework.stereotype.Component;

@Component
public class Girl implements IBuy {
    @Override
    public String buy() {
        System.out.println("女孩买了一件漂亮的衣服");
        return "衣服";
    }
}
```

配置文件, AppConfig.java

```java
package com.sharpcj.aopdemo;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration //表明是一个配置类
@ComponentScan(basePackageClasses = {com.sharpcj.aopdemo.test1.IBuy.class})
public class AppConfig {
}
```

```java
package com.sharpcj.aopdemo;

import com.sharpcj.aopdemo.test1.Boy;
import com.sharpcj.aopdemo.test1.Girl;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class AppTest {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        Boy boy = context.getBean("boy",Boy.class);
        Girl girl = (Girl) context.getBean("girl");
        boy.buy();
        girl.buy();
    }
}
```

![image-20210315102423787](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210315102423787.png)



这里运用SpringIOC里的自动部署。现在需求改变了，我们需要在男孩和女孩的 buy 方法之前，需要打印出“男孩女孩都买了自己喜欢的东西”。用 Spring AOP 来实现这个需求只需下面几个步骤：
1、 **既然用到 Spring AOP, 首先在 `build.gralde` 文件中引入相关依赖：**

```java
dependencies {
    compile 'org.springframework:spring-context:5.0.6.RELEASE'
    compile 'org.springframework:spring-aspects:5.0.6.RELEASE'
}
```

2、 **定义一个切面类，BuyAspectJ.java**

```java
package com.sharpcj.aopdemo.test1;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class BuyAspectJ {
    @Before("execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))")
    public void haha(){
        System.out.println("男孩女孩都买自己喜欢的东西");
    }
}
```

3、 **在配置文件中启用AOP切面功能**

```java
package com.sharpcj.aopdemo;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan(basePackageClasses = {com.sharpcj.aopdemo.test1.IBuy.class})
@EnableAspectJAutoProxy(proxyTargetClass = true)
//proxyTargetClass参数决定了代理的机制，当这个值为false时，使用的是JDK动态代理，当为true时，使用的是CGlib代理
public class AppConfig {
}
```

![image-20210315102519786](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210315102519786.png)

![image-20210315103457612](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210315103457612.png)

修改BuyAspectJ

```java
package com.sharpcj.aopdemo.test1;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class BuyAspectJ {
    @Before("execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..)) && within(com.sharpcj.aopdemo.test1.*) && bean(girl)")
    public void hehe(){
        System.out.println("男孩女孩都买自己喜欢的东西");
    }
}
```

![image-20210315103804920](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210315103804920.png)

简化写法

```java
ackage com.sharpcj.aopdemo.test1;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class BuyAspectJ {

    @Pointcut("execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))")
    public void point(){}

    @Before("point()")
    public void hehe() {
        System.out.println("before ...");
    }

    @After("point()")
    public void haha() {
        System.out.println("After ...");
    }

    @AfterReturning("point()")
    public void xixi() {
        System.out.println("AfterReturning ...");
    }

    @Around("point()")
    public void xxx(ProceedingJoinPoint pj) {
        try {
            System.out.println("Around aaa ...");
            pj.proceed();
            System.out.println("Around bbb ...");
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }
}
```

```java
  @Around("gif(price)")
    public String hehe(ProceedingJoinPoint pj, double price){
        try {
            pj.proceed(); //方法直接 可以在该前后来定义通知方法
            if (price > 68) {
                System.out.println("女孩买衣服超过了68元，赠送一双袜子");
                return "衣服和袜子";
            }
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        return "衣服";
    }
```

可以使用@Before,@After,@AfterReturning,@AfterThrowing。

还可以使用Around注解来直接定义一个环绕通知，直接写完所有

![image-20210315105228641](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210315105228641.png)

这是一个强制类型转换异常。为什么会抛出这个异常呢？或许已经能够想到，这跟Spring AOP 动态代理的机制有关，**这个 `proxyTargetClass` 参数决定了代理的机制。当这个参数为 false 时，**通过jdk的基于接口的方式进行织入，这时候代理生成的是一个接口对象，将这个接口对象强制转换为实现该接口的一个类，自然就抛出了上述类型转换异常**。
反之，`proxyTargetClass` 为 `true`，则会使用 cglib 的动态代理方式。这种方式的缺点是拓展类的方法被`final`修饰时，无法进行织入。

## Spring AOP实现原理？

动态代理，proxyTargetClass为false时候，为CGlib动态代理，GClib动态代理底层使用ASM字节码编译库通过继承的方式来生成代理类

**SpringAop属于运行时增加，而AspectJ属于编译时增强**

为true的时候，为JDK动态代理，代理类底层通过实现被代理类接口的全部方法来通过反射执行目标方法。

## 如何开启基于注解的自动装配？

要使用@Autowired注解，需要注册AutowiredAnnotationBeanPorcessor，有两种注册方式：

```xml
<beans>
    <bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/>
</beans>
<beans>
    <context:annotation-config></context:annotation-config>
</beans>
```

## 请举例解释@Required注解?

RequiredAnnotationBeanPostPorcessor后置处理器来处理该注解，所以需要使用该注解需要先向容器中注册该类

```java
<bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" />
```

```java

public class Person {
   private Integer age;
   private String name;
   @Required
   public void setAge(Integer age) {
      this.age = age;
   }
   public Integer getAge() {
      return age;
   }
   @Required
   public void setName(String name) {
      this.name = name;
   }
   public String getName() {
      return name;
   }

```

```java
  <bean id="person" class="com.tutorialspoint.Person">
      <!-- <property name="name"  value="张三" />-->
      <!-- property name="age"  value="11">-->
   </bean>
```

```java

public class MainApp {
   public static void main(String[] args) {
      ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
      Person person = (Person) context.getBean("person");
	  person.setName("张三");
      person.setAge(11);
      System.out.println("Name : " + person.getName() );
      System.out.println("Age : " + person.getAge() );
   }
}

```

![image-20210315115843233](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210315115843233.png)

标注了该注解代表属性必须要被正确的设置到值，比如标注在setter方法上。否则会抛出Bean的初始化异常

## 请举例解释@Autowired注解？

AutowireAnnotationBeanProcessor，可以标注在属性上，或者标注在构造器上，默认寻找规则首先根据ByType属性类型找，如果找到多个再根据byName找。

注册AutowireAnnotationBeanProcessor后置处理器，或者开启context : annotation-config，为自动注册该后置处理器

## 请举例解释@Qualifier 注解？

当注入一个Bean的时候，但是有多个Bean，使用该注解来确定到底哪个具体Bean

```java
public class Customer{
    @Autowired
    @Qualifier("personA")
    private Person person;
}
```

## FactoryBean

该类是一个工厂类接口，用户可以实现自己的复杂逻辑和业务逻辑的初始化工作，利用了工厂模式和装饰者模式。

BeanFactory是提供了IOC容器最基本的形式，给具体的IOC容器的实现提供了规范

FactoryBean可以说为IOC容器中Bean的实现提供了更加灵活的方式，FactoryBean在IOC容器的基础上给Bean的实现加上了一个简单工厂模式和装饰模式，我们可以在getObject()方法中灵活配置。

## 循环依赖

```java
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
  
  // 尝试从缓存中获取成品的目标对象，如果存在，则直接返回
  Object singletonObject = this.singletonObjects.get(beanName);
  
  // 如果缓存中不存在目标对象，则判断当前对象是否已经处于创建过程中，在前面的讲解中，第一次尝试获取A对象
  // 的实例之后，就会将A对象标记为正在创建中，因而最后再尝试获取A对象的时候，这里的if判断就会为true
  if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
    
    synchronized (this.singletonObjects) {
      singletonObject = this.earlySingletonObjects.get(beanName);
      if (singletonObject == null && allowEarlyReference) {
        
        // 这里的singletonFactories是一个Map，其key是bean的名称，而值是一个ObjectFactory类型的
        // 对象，这里对于A和B而言，调用图其getObject()方法返回的就是A和B对象的实例，无论是否是半成品
        ObjectFactory singletonFactory = this.singletonFactories.get(beanName);
        if (singletonFactory != null) {
          
          // 获取目标对象的实例
          singletonObject = singletonFactory.getObject();
          this.earlySingletonObjects.put(beanName, singletonObject);
          this.singletonFactories.remove(beanName);
        }
      }
    }
  }
  return singletonObject;
}
```

比如A和B对象相互依赖 假设先初始化对象A

判断A对象是否是单例的，不是抽象类，不是懒加载等等，然后调用getSingleton()方法首先先从单例池中拿，然后经过一系列的判断，比如是否正在创建中，如果成立再从二级缓存拿，第一次拿肯定不成立，因为判断是否在容器中是通过后面的代码向一个容器中添加的该对象

然后再判断是否支持循环依赖，并且会将该类标记为正在创建中。也就是向集合中添加该对象，

然后创建Bean对象同时包装，再判断是否是单例的，是否允许循环依赖，是否正在创建中，如果条件都满足，则加入到三级缓存中。也就是key为beanName,value为一个工厂。

然后当执行到PopulationBean方法的时候进行AutoWire属性注入的时候，会发现依赖B，然后尝试去获取对象B，对象B也和上面A获取的方式一样，当执行到属性注入的时候发现也依赖A，然后又去初始化A的逻辑，调用getSingleton()方法，然后再判断是否正在创建中，这个时候就成立了，成立了之后先从earlySignletonObjects二级缓存拿，这个时候也为空，再从三级缓存singletonFactories中拿，这个缓冲就可以拿到该类对应的工厂，然后调用getObject()方法获取该实例，然后再从第三缓存remove掉，加入到二级缓存。

为什么要remove？因为性能，getObject()方法可能会很复杂，每次调用可能会导致性能下降，所以放到二级缓存，直接get对象，而不是get出来工厂

**为什么需要三级缓存？直接放入到二级缓存不就好了吗？**

**主要为了解决对象动态代理的。因为可能会需要代理对象。**

什么时候加入到三级缓存的？

一级缓存其实就可以解决，但是为了拿到该对象的代理对象才有了`singletonFactories`三级缓存，为什么需要二级缓存呢？理由是符合设计模式，**单一职责设计模式**

一级缓存`singletonObjects`是完整的bean，它可以被外界任意使用，并且不会有歧义。

二级缓存`earlySingletonObjects`是不完整的bean，没有完成初始化，它与`singletonObjects`的分离主要是职责的分离以及边界划分，可以试想一个Map缓存里既有完整可使用的bean，也有不完整的，只能持有引用的bean，在复杂度很高的架构中，很容易出现歧义，并带来一些不可预知的错误。

三级缓存`singletonFactories`，其职责就是包装一个bean，有回调逻辑，所以它的作用非常清晰，并且只能处于第三层。

## 构造方法注入和属性注入有什么不同？

属性注入：解决了循环依赖

构造方法注入：如果相互依赖，那么在A对象创建前B对象不能创建的，反之亦然。

构造器不允许生成依赖关系不完整的对象，属性注入可能会，设值注入灵活性更强。

构造方法注入只有在组建的时候才能改变组件的依赖关系，更符合高内聚规则

## Spring框架中有哪些不同类型的事件?

ApplicationContext提供了支持事件和代码中监听的功能

```java
public class AllApplicationEventListener implements ApplicationListener < ApplicationEvent >{
    @Override
    public void onApplicationEvent(ApplicationEvent applicationEvent){
        //process event
    }
}
```

如果实现了ApplicationListener该接口，并且关注的是ApplicationEvent事件，那么当该事件发布以后，bean会被自动通知

spring提供了以下五种标准的事件：

- **上下文更新事件（ContextRefreshedEvent）：ApplicationContext会在被初始化或者更新的时候发布，或者在调用ConfigurbaleApplicationContext的refresh()方法调用**
- **上下文开始事件（ContextStartedEvent）：容器启动的时候ConfigurbaleApplicationContext的start方法**
- **上下文停止事件：容器停止的的时候ConfigurbaleApplicationContext的stop方法**
- **上下文关闭事件 ：当`ApplicationContext`被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。**
- **请求处理事件：Web应用中，当一个Http请求结束触发该事件**

## FileSystemResource 和 ClassPathResource有何区别？

**FileSystemResource** 中需要给出**spring-config.xml**文件在你项目中的相对路径或者绝对路径，而**ClassPathResource**则会默认从ClassPath也就是类路径下查找。

## Spring框架中都用了哪些设计模式？

工厂设计模式 : 比如BeanFactory,FactoryBean都使用到了工厂设计模式

单例设计模式：Spring中bean的作用域默认就是单例的。

代理设计模式：比如AOP就用到了代理设计模式

模板方法设计模式：是一种行为设计模式，定义了一系列算法的骨架，而将一些步骤延迟到子类中。Spring中jdbcTemplate，hibernateTemplate等以Template结婚的都使用到了模板方式设计模式

观察者模式：Spring中的事件驱动模型，当对象之间有依赖关系，那么可以使用观察者模式通知对方。ApplicationEvent

适配器模式：就是Spring中的各种的Adapter抽象类，接口方法太多所以使用Adpater可以不用实现全部方法。

装饰者模式：Spring用到的装饰着模式在类名上还有Wrapper或者Decorator，在spring利用反射创建普通JAVAbean的时候，就对普通Bean进行了装饰。不对本身类中的方法做修改，而是在类的外面再包装一个类然后对里面的类进行增强。

策略设计模式：如BeanPostProcessor。每次会获取所有的BeanPostProcessor，然后依次调用它的before方法和after方法，每个类可能执行的策略都不一样。好比商场打折一样，普通会员95者，高级会员90者，普通群众不打折等等

那么就可以使用父接口定义统一打折方法，多个会员和群众去实现打折方法，实现不同的打折逻辑。

# 设计模式

## 什么是设计模式？你是否在你的代码里面使用过任何设计模式？

设计模式是一种编程思想或者说编程规范，遵守这种规范可以写出更高效的代码，解耦程度高，不冗余的代码，维护和扩展都方便。是在前辈们长期的软件设计过程中，经过总结得到的。

使用过，单例，观察者，适配器模式。

## JAVA中什么叫做单例设计模式？请写出线程安全的设计模式

就是在程序运行过程中只存在一个Bean，每次获取的时候只有该一个Bean。

**而使用单例模式能够保证整个应用中有且只有一个实例**

分为懒汉式和饿汉式。饿汉式更偏向于占用内存，但是实现简单

懒汉式实现线程安全的比较复杂，但是只有在第一次使用的时候才创建。根据业务需求编写到底使用懒汉式还是饿汉式。

```java
package design;

/**
 * @program: dataStructure
 * @description:
 * @author: Mr.Feng
 * @create: 2021-03-17 10:56
 **/
public class SingletonDCL {

    private static  volatile Object object;
    
    private SingletonDCL(){
        
    }
    
    public static Object getInstance(){
        if (object == null){
            synchronized (object){
                if (object == null){
                    object = new Object();
                }
            }
        }
        return object;
    }
}

```



## 使用工厂设计模式最主要的好处在哪里？在哪里使用？

可以对JAVA生成的对象进行增强和加工处理，形成更复杂的JAVA对象。

并且如果程序中频繁的被new的话，并且如果构造器参数非常多的时候，或者说当需要new多个不同的对象来完成某一个功能的时候，并且他们往往是一起出现的，那么可以使用工厂设计模式，比如说JUC里面的Executors框架，创建ThreadPool的时候就使用工厂设计。解耦。防止用来实例化一个类的数据在多个类里面到处都是。

在哪里使用？比如说Spring中的IOC，BeanFacotry，FactoryBean

## 举一个用JAVA实现的装饰者模式？它是作用于对象层次还是类层次?

装饰者模式增加了对单个对象的增强能力，JAVA IO到处使用了装饰模式，经典的例子就是BufferedReader和BufferedWrite，它们增强了Write和Reader对象，以提升Buffer层次的读取和写入。

## 在JAVA中，为什么不允许从静态方法中访问非静态变量

因为静态方法是和类绑定的，当类会被初始化的时候而静态方法也会被初始化，非静态变量是和对象绑定的，只有在创建对象的时候才会被初始化，那么静态方法被初始化的时候也就无法调用非静态方法。因为静态方法先于非静态方法存在。

类在<client>的时候进行初始化，编译器会为每个类生成一个类构造器，也就是程序启动的时候。

## 在JAVA中什么时候用重载，什么时候用重写？

子类进行重写父类的方法，用于修改或者扩展业务逻辑。

而重载则是方法名相等，参数不同。可以使用重载简化方法形参，使得对内封装复杂功能，对外开发简单API调用参数。

并且重载可以使得方法功能类似，但是可以提供更多的参数来扩展功能。比如jdbcTmplate的query方法，nio中bytebuffer的 put和get方法，都使用了重载。

## 举例什么情况下会更倾向于使用抽象类而不是接口？

使用适配器模式的时候，但是jdk1.8增加了default默认接口实现。

需要使用构造器或者成员变量进行一些初始化工作的时候。

## 设计一个ATM机，请说出你的设计思路？

ATM应该保证事务，加锁，错误条件，错误如何回滚，边界条件等等。

## 设计模式7大原则

**单一职责原则**：一个类只负责一个功能领域中的响应职责。

比如说登录，加入购物车，购买商品，支付。如果都写在一个类中，那么就特别复杂，比较难以维护。

**开闭原则**：对修改关闭，对扩展开放。

好处是提供系统的维护性和复用性。使得原有的代码功能依然存在。

如何使用 参数对象尽量使用接口或者抽象类。抽象层尽量保持稳定，不修改。

**接口隔离原则**：使用多个专门的接口，而不是单一的总接口，客户端不需要依赖那些不需要的接口。类之间的依赖关系应该建立在最小的接口上。

**依赖倒转原则**：抽象不依赖于细节，细节依赖抽象。换言之针对接口编程。

**里氏代换原则**：所有引用基类的地方可以用子类来替换，反过来就不行。比如动物是狗，不能说狗是动物。因此尽量使用多态，使用父类来定义对象，运行时确定其子类型。

约束：子类必须实现基类的抽象方法，不得重写父类的非抽象方法，子类中可以添加特有父类不存在的方法。

**合成复用原则**：尽量使用对象组合，而不是集成来达到复用的目的。

**迪米特法则**：也称为最少知道原则，即一个对象应该对其他对象保持最少的了解。

举个例子：家人：家人只与犯人是亲人，但是不认识他的狱友

## 工厂设计模式

**简单工厂设计模式**: 

使用说明：先将产品类抽象出来，比如，苹果和梨都属于水果，抽象出来一个水果类Fruit，苹果和梨就是具体的产品类，然后创建一个水果工厂，分别用来创建苹果和梨；代码如下：

```java
public interface Fruit {
    void whatIm();
}
public class Apple implements Fruit {
    @Override
    public void whatIm() {
        //苹果
    }
}
public class Pear implements Fruit {
    @Override
    public void whatIm() {
        //梨
    }
}	
public class FruitFactory {

    public Fruit createFruit(String type) {

        if (type.equals("apple")) {//生产苹果
            return new Apple();
        } else if (type.equals("pear")) {//生产梨
            return new Pear();
        }

        return null;
    }
}

 FruitFactory mFactory = new FruitFactory();
 Apple apple = (Apple) mFactory.createFruit("apple");//获得苹果
 Pear pear = (Pear) mFactory.createFruit("pear");//获得梨
```

就这样，一个非常简单的工厂设计模式就完成了，但是有没有发现什么问题呢？
对，那就是如果我想吃香蕉，想吃橘子呢，我万一什么都想吃呢？？所以，以上的这种方式，每当我想添加一种水果，就必然要修改工厂类，这显然违反了开闭原则，亦不可取；所以简单工厂只适合于产品对象较少，且产品固定的需求，对于产品变化无常的需求来说显然不合适；所以我们来看下一种方式；

**工厂方法设计模式**

定义：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；
角色：
**抽象产品类**
**具体产品类**
**抽象工厂类**
**具体工厂类**

```java
public interface FruitFactory {
    Fruit createFruit();//生产水果
}
public class AppleFactory implements FruitFactory {
    @Override
    public Fruit createFruit() {
        return new Apple();
    }
}
public class PearFactory implements FruitFactory {
    @Override
    public Fruit createFruit() {
        return new Pear();
    }
}
AppleFactory appleFactory = new AppleFactory();
PearFactory pearFactory = new PearFactory();
Apple apple = (Apple) appleFactory.createFruit();//获得苹果
Pear pear = (Pear) pearFactory.createFruit();//获得梨
```

以上这种方式，虽然解耦了，也遵循了开闭原则，但是问题根本还是没有解决啊，换汤没换药，如果我需要的产品很多的话，需要创建非常多的工厂，所以这种方式的缺点也很明显

**抽象工厂设计模式**

为创建一组相关或者是相互依赖的对象提供一个接口

抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列；举个例子，假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了；用抽象工厂来实现：

```java
public interface Cpu {
    void run();

    class Cpu650 implements Cpu {
        @Override
        public void run() {
            //625 也厉害
        }
    }

    class Cpu825 implements Cpu {
        @Override
        public void run() {
            //825 处理更强劲
        }
    }
}
```

```java
public interface Screen {

    void size();

    class Screen5 implements Screen {

        @Override
        public void size() {
            //5寸
        }
    }

    class Screen6 implements Screen {

        @Override
        public void size() {
            //6寸
        }
    }
}
```

```java
public interface PhoneFactory {

    Cpu getCpu();//使用的cpu

    Screen getScreen();//使用的屏幕
}
public class XiaoMiFactory implements PhoneFactory {
    @Override
    public Cpu getCpu() {
        return new Cpu.Cpu825();//高性能处理器
    }

    @Override
    public Screen getScreen() {
        return new Screen.Screen6();//6寸大屏
    }
}
public class HongMiFactory implements PhoneFactory {

    @Override
    public Cpu getCpu() {
        return new Cpu.Cpu650();//高效处理器
    }

    @Override
    public Screen getScreen() {
        return new Screen.Screen5();//小屏手机
    }
}
```





## 观察者模式

观察者模式面向的需求是：A对象（观察者）对B对象（被观察者）的某种变化高度敏感，需要在B变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者、小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会错过任何瞬间。程序里的观察者和这种真正的【观察】略有不同，观察者不需要时刻盯着被观察者（例如A不需要每隔1ms就检查一次B的状态），二是采用**注册**(*Register*)或者成为**订阅**(*Subscribe*)的方式告诉被观察者：我需要你的某某状态，你要在它变化时通知我。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。

```java
/**
* 主题（发布者、被观察者）
*/
public interface Subject {

    /**
     * 注册观察者
     */
    void registerObserver(Observer observer);

    /**
     * 移除观察者
     */
    void removeObserver(Observer observer);

    /**
     * 通知观察者
     */
    void notifyObservers(); 
}
```

```java
/**
 * 观察者
 */
public interface Observer {
    void update();
}
```

```java
public interface DisplayElement {
    void display();
}
```

```java
public class WeatherData implements Subject {

    private List<Observer> observers;

    private float temperature;//温度
    private float humidity;//湿度
    private float pressure;//气压
    private List<Float> forecastTemperatures;//未来几天的温度

    public WeatherData() {
        this.observers = new ArrayList<Observer>();
    }

    @Override
    public void registerObserver(Observer observer) {
        this.observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        this.observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }

    public void measurementsChanged() {
        notifyObservers();
    }

    public void setMeasurements(float temperature, float humidity, 
    float pressure, List<Float> forecastTemperatures) {
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        this.forecastTemperatures = forecastTemperatures;
        measurementsChanged();
    }

    public float getTemperature() {
        return temperature;
    }

    public float getHumidity() {
        return humidity;
    }

    public float getPressure() {
        return pressure;
    }

    public List<Float> getForecastTemperatures() {
        return forecastTemperatures;
    }
}
```

```java
//显示当前天气的公告牌CurrentConditionsDisplay
public class CurrentConditionsDisplay implements Observer, DisplayElement {

    private WeatherData weatherData;

    private float temperature;//温度
    private float humidity;//湿度
    private float pressure;//气压

    public CurrentConditionsDisplay(WeatherData weatherData) {
        this.weatherData = weatherData;
        this.weatherData.registerObserver(this);
    }

    @Override
    public void display() {
        System.out.println("当前温度为：" + this.temperature + "℃");
        System.out.println("当前湿度为：" + this.humidity);
        System.out.println("当前气压为：" + this.pressure);
    }

    @Override
    public void update() {
        this.temperature = this.weatherData.getTemperature();
        this.humidity = this.weatherData.getHumidity();
        this.pressure = this.weatherData.getPressure();
        display();
    }
}
```

```java
//显示未来几天天气的公告牌ForecastDisplay
public class ForecastDisplay implements Observer, DisplayElement {

    private WeatherData weatherData;

    private List<Float> forecastTemperatures;//未来几天的温度

    public ForecastDisplay(WeatherData weatherData) {
        this.weatherData = weatherData;
        this.weatherData.registerObserver(this);
    }

    @Override
    public void display() {
        System.out.println("未来几天的气温");
        int count = forecastTemperatures.size();
        for (int i = 0; i < count; i++) {
            System.out.println("第" + i + "天:" + forecastTemperatures.get(i) + "℃");
        }
    }

    @Override
    public void update() {
        this.forecastTemperatures = this.weatherData.getForecastTemperatures();
        display();
    }
}
```

```java
public class ObserverPatternTest {

    public static void main(String[] args) {

        WeatherData weatherData = new WeatherData();
        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);
        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);

        List<Float> forecastTemperatures = new ArrayList<Float>();
        forecastTemperatures.add(22f);
        forecastTemperatures.add(-1f);
        forecastTemperatures.add(9f);
        forecastTemperatures.add(23f);
        forecastTemperatures.add(27f);
        forecastTemperatures.add(30f);
        forecastTemperatures.add(10f);
        weatherData.setMeasurements(22f, 0.8f, 1.2f, forecastTemperatures);
    }
}

//输出结果
当前温度为：22.0℃
当前湿度为：0.8
当前气压为：1.2
未来几天的气温
第0天:22.0℃
第1天:-1.0℃
第2天:9.0℃
第3天:23.0℃
第4天:27.0℃
第5天:30.0℃
第6天:10.0℃
```



## 装饰者模式

代理模式和装饰器模式非常相近，本文通过举例，针对俩者的区别进行探讨。

示例：孩子会吃饭

```java
public interface IChild {

    void eat();
}
```

创建孩子类，实现吃饭接口：

```java
public class Child implements IChild{

    @Override
    public void eat() {

        Log.e("TAG","孩子吃饭");
    }
}
```

如果孩子太小，不会做饭，连吃饭都需要引导，这时候就需要一个代理帮助孩子正确处理吃饭流程：

创建父母(代理)类：

```java
public class Parent implements IChild{

    private Child child;

    private Parent(Child child){

        this.child = child;
    }

    @Override
    public void eat() {

        Log.e("TAG","父母做饭");
        child.eat();
        Log.e("TAG","父母收拾餐具");
    }
}
```

其中**有些**孩子长大了，学会了自己做饭、自己吃饭，生活独立自主：

创建孩子扩展(装饰)类：

```java
public class ChildWrapper implements IChild{

    private Child child;

    public ChildWrapper(Child child){

        this.child = child;
    }

    @Override
    public void eat() {

        Log.e("TAG","孩子做饭");
        child.eat();
        Log.e("TAG","孩子收拾餐具");
    }
}
```

以上是代理和装饰的简化写法，如果不探究其表达的意义，俩者是没有区别的。

但是从实际意义出发，就可以看出俩者的区别：

代理，偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制。
 装饰，

这样说有些抽象，继续接着上例：

孩子长大了，需要去上学读书，新增学生接口

```java
public interface IStudent {

    void readBook();
}
```

```java
//孩子多了一重身份--学生，故要实现学生接口：
public class Child implements IChild, IStudent {

    @Override
    public void eat() {

        Log.e("TAG", "孩子吃饭");
    }


    @Override
    public void readBook() {

        Log.e("TAG", "孩子读书");
    }
}
```

```java
//此时，上述部分独立自主的孩子（装饰类），因为身份的增加，也要相应的扩展：
public class ChildWrapper implements IChild, IStudent {

    private Child child;

    public ChildWrapper(Child child) {

        this.child = child;
    }

    @Override
    public void eat() {

        Log.e("TAG", "孩子做饭");
        child.eat();
        Log.e("TAG", "孩子收拾餐具");
    }

    @Override
    public void readBook() {

        child.readBook();
    }
}
```

孩子成为了学生，但读书不是宅家里自学这么简单，需要有人教学，这显然不是父母的任务，而是学校的事情。于是新增学校代理：

```java
public class School implements IStudent {

    private ArrayList<IStudent> students;

    public void addStudent(IStudent student) {

        students.add(student);
    }

    @Override
    public void readBook() {

        for (IStudent student : students) {
            
            student.readBook();
        }
    }
}
```

学校招收学生入学，独立自主的孩子作为装饰类，本质还是孩子，肩负学生这一身份，可以作为学生入学，而原先的父母作为代理类不能入学：

```java
Child child = new Child();
ChildWrapper wrapper = new ChildWrapper(child);
Parent parent = new Parent(child);

School school = new School();
school.addStudent(wrapper);
```

**代理模式，注重对对象某一功能的流程把控和辅助，它可以控制对象做某些事，重心事为了借助对象的功能完成某一流程，而非对象的访问。**

**装饰者模式：注重对对象功能的扩展，只关心对象的增强，装饰后还是对象本身。**

**对于代理类，如何调用对象的某一功能是思考重点，而不需要兼顾对象的所有功能；**

**对于装饰类，如何扩展对象的某一功能是思考重点，同时也要兼顾对象的其他功能，因为再怎么装饰，本质也是对象本身，要负担起对象应有的责任**



## 责任链模式

【例1】用责任链模式设计一个请假条审批模块。

分析：假如规定学生请假小于或等于 2 天，班主任可以批准；小于或等于 7 天，系主任可以批准；小于或等于 10 天，院长可以批准；其他情况不予批准；这个实例适合使用职责链模式实现。

责任链模式为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者形成一条链表，请求发送者只需要通过调用第一个请求处理者来处理就可以了，可将请求沿着这条链传递。

好处

- 降低了对象的耦合度
- 增加了可扩展性
- 责任分担，每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围

```java
package chainOfResponsibility;
public class ChainOfResponsibilityPattern {
    public static void main(String[] args) {
        //组装责任链
        Handler handler1 = new ConcreteHandler1();
        Handler handler2 = new ConcreteHandler2();
        handler1.setNext(handler2);
        //提交请求
        handler1.handleRequest("two");
    }
}
//抽象处理者角色
abstract class Handler {
    private Handler next;
    public void setNext(Handler next) {
        this.next = next;
    }
    public Handler getNext() {
        return next;
    }
    //处理请求的方法
    public abstract void handleRequest(String request);
}
//具体处理者角色1
class ConcreteHandler1 extends Handler {
    public void handleRequest(String request) {
        if (request.equals("one")) {
            System.out.println("具体处理者1负责处理该请求！");
        } else {
            if (getNext() != null) {
                getNext().handleRequest(request);
            } else {
                System.out.println("没有人处理该请求！");
            }
        }
    }
}
//具体处理者角色2
class ConcreteHandler2 extends Handler {
    public void handleRequest(String request) {
        if (request.equals("two")) {
            System.out.println("具体处理者2负责处理该请求！");
        } else {
            if (getNext() != null) {
                getNext().handleRequest(request);
            } else {
                System.out.println("没有人处理该请求！");
            }
        }
    }
}

程序运行结果如下：
具体处理者2负责处理该请求！
```



## 建造者模式

什么时候使用建造者模式呢？

**当一个类的构造参数超过四个，而且这些参数有些是可以选的，考虑使用**

必须有一个计算机Computer类，CPU和内存是必选。其他是可选，普通方法有两种。

```java
public class Computer {
    private String cpu;//必须
    private String ram;//必须
    private int usbCount;//可选
    private String keyboard;//可选
    private String display;//可选
}
public class Computer {
     ...
    public Computer(String cpu, String ram) {
        this(cpu, ram, 0);
    }
    public Computer(String cpu, String ram, int usbCount) {
        this(cpu, ram, usbCount, "罗技键盘");
    }
    public Computer(String cpu, String ram, int usbCount, String keyboard) {
        this(cpu, ram, usbCount, keyboard, "三星显示器");
    }
    public Computer(String cpu, String ram, int usbCount, String keyboard, String display) {
        this.cpu = cpu;
        this.ram = ram;
        this.usbCount = usbCount;
        this.keyboard = keyboard;
        this.display = display;
    }
}
public class Computer {
        ...

    public String getCpu() {
        return cpu;
    }
    public void setCpu(String cpu) {
        this.cpu = cpu;
    }
    public String getRam() {
        return ram;
    }
    public void setRam(String ram) {
        this.ram = ram;
    }
    public int getUsbCount() {
        return usbCount;
    }
...
}
```

两种方式不易于阅读，并且构造对象容易发生错误。

下面是Builder模式

1. 在Computer 中创建一个静态内部类 Builder，然后将Computer 中的参数都复制到Builder类中。
2. 在Computer中创建一个private的构造函数，参数为Builder类型
3. 在Builder中创建一个`public`的构造函数，参数为Computer中必填的那些参数，cpu 和ram。
4. 在Builder中创建设置函数，对Computer中那些可选参数进行赋值，返回值为Builder类型的实例
5. 在Builder中创建一个`build()`方法，在其中构建Computer的实例并返回

```java
public class Computer {
    private final String cpu;//必须
    private final String ram;//必须
    private final int usbCount;//可选
    private final String keyboard;//可选
    private final String display;//可选

    private Computer(Builder builder){
        this.cpu=builder.cpu;
        this.ram=builder.ram;
        this.usbCount=builder.usbCount;
        this.keyboard=builder.keyboard;
        this.display=builder.display;
    }
    public static class Builder{
        private String cpu;//必须
        private String ram;//必须
        private int usbCount;//可选
        private String keyboard;//可选
        private String display;//可选

        public Builder(String cup,String ram){
            this.cpu=cup;
            this.ram=ram;
        }

        public Builder setUsbCount(int usbCount) {
            this.usbCount = usbCount;
            return this;
        }
        public Builder setKeyboard(String keyboard) {
            this.keyboard = keyboard;
            return this;
        }
        public Builder setDisplay(String display) {
            this.display = display;
            return this;
        }        
        public Computer build(){
            return new Computer(this);
        }
    }
  //省略getter方法
}
```



## 静态代理

**静态代理，代理类和被代理的类实现了同样的接口**，**代理类同时持有被代理类的引用**，这样，当我们需要调用被代理类的方法时，可以通过调用代理类的方法来做到。举例如下：
假设领导的工作是开会和给员工考评。
先定义一个接口：

```java
package com.sharpcj;

public interface IWork {
    void meeting();

    int evaluate(String name);
}
```

然后定义领导类：

```java
package com.sharpcj;

import java.util.Random;

public class Leader implements IWork {

    @Override
    public void meeting() {
        System.out.println("领导早上要组织会议");
    }

    @Override
    public int evaluate(String name) {
        int score = new Random(System.currentTimeMillis()).nextInt(20) + 80;
        System.out.println(String.format("领导给%s的考评为%s分", name, score));
        return score;
    }
}
```

秘书类：

```java
package com.sharpcj;

public class Secretary implements IWork {
    private Leader mLeader;

    public Secretary(Leader mLeader) {
        this.mLeader = mLeader;
    }

    @Override
    public void meeting() {
        System.out.println("秘书先给老板准备材料");
        mLeader.metting();
    }

    @Override
    public int evaluate(String name) {
        return mLeader.evaluate(name);
    }
}
```

测试类：

```java
package com.sharpcj;

public class TestApp {
    public static void main(String[] args) {
        Leader leader = new Leader();
        Secretary secretary = new Secretary(leader);
        secretary.meeting();
        secretary.evaluate("Joy");
    }
}
```

![image-20210313120125841](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210313120125841.png)

在调用Secretary类的meeting()方法的时候,我们调用了Leader类的meeting的方法,在此之前我们还扩充了该方法,有点像装饰者模式

**与装饰着模式的区别 **:

装饰者模式关注的是在一个对象上动态的添加方法,然而代理模式关注于控制对象的访问,比如对某对象进行前后的增强补充和说明,**而装饰者模式可以在一个对象上动态的添加方法**

伪代码 : 

代理模式:

```java
Interface Subject {
    void doAction()
}

public class RealSubject implements Subject{
    @Override
    public void doAction() {};
}


public class Proxy implements Subject{
       private RealSubject realSubject;

       public Proxy(RealSubject realSubject) {
             //关系在编译时确定
            this.realSubject = realSubject;
       }

       @Override
       public void doAction() {
             ….
             realSubject.doAction();
             ….
       }
}
```

// 装饰者模式

```java
Interface Component {
    void doAction()
}

public class ConcreteComponent implement Component {
    @Override
    public void doAction() {};
    
    public void addMethod(){}
}

public class Decorator implements Component {
       private Component component;

       public Decorator(Component component) {
             //关系在编译时确定
            this.component = new component;
       }
       public void doAction() {
             ….
             component.doAction();
             ….
             component.addMethod();    
       }
}
```

侧重点不同,代理模式重点在于明确了被代理的类,如上例中,秘书很明确的要代理的是领导.  而装饰着模式侧重于拓展类的方法,也就是说装饰类可以根据在调入时传入的参数,装饰一个任意实现了Compoent接口的类

在客户端使用链式调用，一步一步的把对象构建出来。

```java
Computer computer=new Computer.Builder("因特尔","三星")
                .setDisplay("三星24寸")
                .setKeyboard("罗技")
                .setUsbCount(2)
                .build();
```

## 动态代理

动态代理的根据实现方式的不同可以分为JDK动态代理和CGlib动态代理

J**DK动态代理 : 利用反射机制生成一个实现代理接口的类,在调用具体方法前调用invokeHandle来处理**  InvocationHandle 调用处理器

**CGlib动态代理 : 利用ASM (开源的JAVA字节码编辑库,操作字节码)开源包,将代理对象的Class文件加载进来,通过修改其字节码生成子类来处理**

区别: JDK代理只能对实现接口的类进行代理,CGlib是针对类实现代理,对指定的类生成一个子类,并覆盖其中的方法,这种方式通过继承类的实现方法,不能代理final修饰的类

### JDK动态代理

```java
package com.sharpcj;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class WorkInvocationHandler implements InvocationHandler {
    private Object object;

    public WorkInvocationHandler(Object object) {
        this.object = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("object: " + object.getClass().getSimpleName());
        System.out.println("proxy: " + proxy.getClass().getSimpleName());

        if ("meeting".equals(method.getName())) {
            System.out.println("代理先准备会议材料...");
            return method.invoke(object, args);
        } else if ("evaluate".equals(method.getName())) {
            if(args[0] instanceof String) {
                if ("James".equals(args[0])) {
                    System.out.println("James 犯过错误，所以考评分数较低...");
                    return 70;
                }
            }
            return method.invoke(object, args);
        }
        return null;
    }
}
```

然后通过 `Proxy.newProxyInstance()` 方法创建代理对象：

```java
package com.sharpcj;

import java.lang.reflect.Proxy;

public class TestApp {
    public static void main(String[] args) {
        /*Leader leader = new Leader();
        Secretary secretary = new Secretary(leader);
        secretary.meeting();
        secretary.evaluate("Joy");*/

        Leader leader = new Leader();
        IWork proxy = (IWork) Proxy.newProxyInstance(Leader.class.getClassLoader(),
                new Class[]{IWork.class}, new WorkInvocationHandler(leader));
        proxy.meeting();
        proxy.evaluate("Joy");
        proxy.evaluate("James");
    }
}
```

![image-20210313143528187](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210313143528187.png)

InvocationHandle接口的invoke方法的第一个参数Proxy,实际是代理对象本身,意义在于可以连续进行方法调用. 级联模式

```java
package com.sharpcj.proxytest;

public interface IWork {
    IWork work(String subject);
}
```

```java
package com.sharpcj.proxytest;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class WorkInvocationHandler implements InvocationHandler {
    private Object object;

    public WorkInvocationHandler(Object object) {
        this.object = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if ("work".equals(method.getName())){
            System.out.println("--- work: " + args[0]);
            return proxy;
        }
        return null;
    }
}
```

```java
package com.sharpcj.proxytest;

import java.lang.reflect.Proxy;

public class TestApp {
    public static void main(String[] args) {
        IWork worker = (IWork) Proxy.newProxyInstance(IWork.class.getClassLoader(), new Class[]{IWork.class},
                new WorkInvocationHandler(new IWork() {
                    @Override
                    public IWork work(String subject) {
                        return null;
                    }
                }));
        worker.work("AAA").work("BBB").work("CCC");
    }
}
```

![image-20210313143941383](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210313143941383.png)

### CGlib代理

首先添加 cglib 依赖
build.gradle 文件：

```java
dependencies {
    // 引入 cglib 库
    compile 'cglib:cglib:3.1'
    testCompile group: 'junit', name: 'junit', version: '4.12'
}
...
```

前面说了，cglib 针对类进行代理，我们以上面的 Leader 类为例，先创建一个类实现 `MethodInterceptor`接口：

```java
package com.sharpcj;

import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class LeaderMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        if ("meeting".equals(method.getName())) {
            System.out.println("代理先准备会议材料...");
            return methodProxy.invokeSuper(o, objects);
        } else if ("evaluate".equals(method.getName())) {
            if(objects[0] instanceof String) {
                if ("James".equals(objects[0])) {
                    System.out.println("James 犯过错误，所以考评分数较低...");
                    return 70;
                }
            }
            return methodProxy.invokeSuper(o, objects);
        }
        return null;
    }
}
```

```java
package com.sharpcj;

import net.sf.cglib.core.DebuggingClassWriter;
import net.sf.cglib.proxy.Enhancer;

import java.lang.reflect.Proxy;

public class TestApp {
    public static void main(String[] args) {
        // System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "D:\\temp\\code");  //保存生成的 class 文件
        Enhancer enhancer = new Enhancer(); // 通过CGLIB动态代理获取代理对象的过程
        enhancer.setSuperclass(Leader.class); // 设置enhancer对象的父类
        enhancer.setCallback(new LeaderMethodInterceptor()); // 设置enhancer的回调对象
        Leader proxy= (Leader)enhancer.create(); // 创建代理对象

        // 通过代理对象调用目标方法
        proxy.meeting();
        proxy.evaluate("Joy");
        proxy.evaluate("James");
    }
}

```

![image-20210313145534496](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210313145534496.png)

`MethodInterceptor` 接口只有一个 `intercept` 方法，这个方法有4个参数：
1）obj表示增强的对象，即实现这个接口类的一个对象；
2）method表示要被拦截的方法；
3）args表示要被拦截方法的参数；
4）proxy表示要触发父类的方法对象；

**需要注意的是，实际调用是 `methodProxy.invokeSuper()`, 如果使用 `invoke()` 方法，则需要传入被代理的类对象，否则出现死循环，造成 stackOverflow 。**

# SpringBoot

## 什么是SpringBoot？

整个JAVA EE的整体解决方案，一系列的大整合。

- 嵌入式的tomcat无需部署war文件
- 自动配置功能
- 约定大于配置

## SpringBoot有哪些优点？

自动配置，便与与第三方应用整合。并且自定义了许多starter。开箱即用，少去了整合第三方应用程序Spring中大量的配置文件。并且SpringBoot+SpringClound可以实现微服务，各服务之间没有关系，一个服务宕机不影响另外其他服务，服务与服务之间通过Http或者远程调用RPC之间来通信。将所有服务可以注册到SpringCloud Nacos上。

优点  ：

- 快速构建项目
- 项目可独立运行，内嵌Servlet容器
- 自动配置，无代码生成，简化开发
- 极大提高了开发和部署效率
- 提供运行时候的应用程序监控

缺点：

- 深入较难，因为隐藏了太多的细节。脚手架
- 版本迭代快。

## 什么是JAVAConfig？

JAVAConfig组件是通过注解和类来构建组件的，而不是通过xml配置方式。

比如说@bean注解。向容器中添加一个组件

导入devTools热部署。

## Spring Boot中的监视器是什么？

spring boot actuator监视器可帮助查看当前应用程序的当前状态，比如JVM垃圾收集次数，停顿时间，CPU占用率等等。

## 如何在Spring Boot中禁用 Actuator端点安全性？

关闭Actuator端点的自动配置类

## 如何在自定义端口上运行 Spring Boot 应用程序？

修改配置文件，因为端口默认是8080，可以创建application.yaml来修端口

server.port = xxxx;

## 什么是YAML?

是一种可读的数据序列化语言，常用于配置文件，相比properties更加结构化。

## 如何实现SpringBoot 应用程序的安全性？

整合Spring Security，使用spring-boot-starter-securtiy依赖项。

## 如何集成Spring Boot 和 ActiveMq?

导入相应的starter依赖项。

## 如何使用 Spring Boot 实现分页和排序？

使用Spring-Data-JPA可以实现将可分页的传递给存储库

## 什么是 Swagger？你用Spring Boot实现了它吗？

不需要实现，导包就行。和PostMan有点像，模仿前端发送数据。用于生成RestFul Web的可视化工具，规范和完整框架实现。

## 什么是Spring Profils？

可以用来环境切换，避免在切换环境的时候修改配置文件，比如将测试环境修改到生成环境，可能需要更换一大堆配置，比如端口，IP等等

Spring Profils就可以使得不同的环境使用不同的配置文件。

比如生产环境在主配置文件中配置dev，需要使用测试环境的时候配置test。

## 什么是Spring Batch？

为批处理功能提供一系列的函数，可以实现高性能批作业处理，比如日志跟踪，事务管理，应用程序统计等。

## 如何使用 Spring Boot实现异常处理？

提供了一种使用ControllerAdvice处理异常非常有用的方法，我们需要一个实现ControllerAdvice类，来处理控制器抛出的所有异常

## 您使用了哪些 starter maven 依赖项？

spring-boot-starter-web

spring-boot-starter-data

mybaits-spring-boot-starter

spring-boot-starter

spring-boot-starter-redis

spring-boot-starter-mq

等等

## 什么是 CSRF 攻击？

CSRF是一种跨站请求伪造，是一种攻击，迫使用户在通过当前身份验证的Web中执行不需要的操作。CSRF专门针对状态改变请求。利用Cookie实现。

## 什么是 WebSockets？

长连接，不像Http发送完请求就断开连接，而是一直保持长时间通信，并且通信方式更偏重于推送数据，而不是拉取数据。计算机通信协议，全双工通信通道。

## 什么是 Apache Kafka？

是一个分布式发布-订阅消息系统。是一个可扩展，容错的发布-订阅消息系统

## 我们如何监视所有的 Spring Boot微服务？

Actuator。

## SpringBoot自动配置原理

SpringBoot的启动类上的注解，该注解是一个合成注解，与自动配置原理相关的是EnableAutoConfiguration，该注解的作用相当于扫描应用程序里面所有的类路径下的Meta/INF/springfactories文件，然后导入相应的自动配置类，自动配置类一般都会和某个配置文件的前缀进行绑定，必须spring.mvc前缀就是配置springMav的自动配置类，然后里面有特别多的@Conditional注解，经常用到的就是@ConditionOnMissBean，容器中没有该Bean的时候才向容器中添加类，每个自动配置类都标注了Configuration注解，代表是一个配置类,@bean向容器中根据Conditional注解来判断是否需要添加Bean。

## RequestMapping和GetMapping的不同之处？

GetMapping注解只会响应路径下前端发来的Get请求，而RequsetMapping则会响应路径下前端发来的所有Request请求。

## SpringBoot的核心注解是哪些？主要由什么注解构成？

@SpringBootApplication注解。他也是SpringBoot的核心注解，主要组合包含了以下3个注解

@EnableAutoConfiguration 自动配置注解。	

@ComponentScan 包扫描

@SpringBootConfigruation,组合了@Configuration，实现配置文件的功能。



## 保护你的SpringBoot应用有哪些方法？

整合Spring Securtiy

启用CSRF保护。

使用内容安全策略防止XSS攻击

## SpirngBoot如何解决跨域？

```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowCredentials(true)
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .maxAge(3600);
    }

}
```

写一个自动配置类，然后实现addCorsMapping方法。

# Mysql

## Mysql索引的优缺点?

**优点**：

- 索引可以大大减少了服务器需要扫描的数据量

- 索引可以帮助服务器避免排序和创建临时表

- 索引可以将随机IO变为顺序IO

**缺点**

- 索引虽然可以提高查询速度，但是也会降低更新表的速度，因为不仅要对表进行插入，删除，修改，同时也要保存索引文件。
- 对于非常小的表，全文扫描更高效
- 如果某个列有非常重复的内容，索引没有多大用
- 必须注意各种索引失效的场景，防止索引失效

## Mysql各种索引的一些差异？

**聚集索引**：一个表只能有一个聚集索引。推荐将自增ID作为主键，也就是聚集索引，不会造成数据数据页频繁断裂的情况，B+树不饱和的情况。(原因聚集索引是按照顺序进行排序的)。聚集索引不一定是主键，但是主键一定是聚集索引。

- Inoodb对主键建立索引W
- 如果不指定主键，Innodb会用一个非空且唯一的索引当作是聚集索引
- 如果也没有找到非空且唯一的列，Innodb会默认定义一个隐藏的主键，然后对其进行建立聚簇索引。
- 聚集索引中的每个叶子结点包含主键的值，事务ID，用于事务和MVCC的回滚指针。

**非聚集索引**：除了聚集索引以外的索引都是非聚集索引，又可以被细分为普通索引，唯一索引，全文索引，组合索引等。Innodb也会根据该索引创建一个B+树，但是叶子结点只可以根据该索引获取到该列数据和主键id，然后再进行回表去主键的B+树上寻找整行数据。除非是覆盖索引不需要回表。

**Hash索引**：自适应哈希索引，当某些索引值被查找非常频繁的时候，会在内存中基于B+树索引再创建一个哈希索引，加快数据的查找速度。只能用于等值比较，例如=， <=>，in

**全文索引**：Mysql允许在char,varchar,text上建立全文索引。全文索引的底层为**倒排索引**，比如对于查询字符串，如果进行顺序扫描那么速度会很慢，假如我们想搜索的信息是哪些行数据包含该字符串，也就是已知字符串欲求行数据，也就是字符串到文件的映射。但是如果我们总是能存储文件到字符串的映射，那么就能大大提高查询数据。**字典+倒排表**。每个字典都指向包含此字符串的文档链表，称为**倒排表**。并且还可以查询多个条件使用合并链表。

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210407115637757.png" alt="image-20210407115637757" style="zoom:50%;" />



**普通索引**：最基本的索引，没有任何限制。唯一任务就是加快数据的访问速度。

**唯一索引**：与普通索引的区别就是列值必须唯一，允许有空值，如果是组合索引那么列值的组合必须唯一。

**组合索引**：多个列组成一个索引。必须满足最左前缀规则。

**覆盖索引**：是使用组合索引时候的最优情况，不需要再回表查询

## Innodb怎么保证崩溃恢复能力的？

先写redo日志再写磁盘数据，并且缓冲区里面会有日志缓冲和数据页面缓冲。

先写到内存的日志缓冲，然后再写到数据页面缓冲，当写到数据页面缓冲的时候必须保证日志缓冲已经同步到磁盘。然后根据redo日志文件可以恢复数据。

redo日志文件保存的是逻辑数据，相当于保存的就是sql语句，会以此执行redo里面的sql语句，进行数据恢复。

**lsn** ： 可以理解为数据库从创建以来产生的redo日志量，这个值越大，说明数据库的更新越多。此外，每个数据页上都有一个lsn，表示最后被修改lsn，值越大越晚被修改。比如，数据页A的Lsn为100，数据页B的Lsn为200，checkPoint lsn为150，系统lsn为300，表示系统已经更新到300，小于150的数据页已经被刷新到磁盘上。因此数据页A的最新数据一定在磁盘上，而数据页B则不一定，有可能还在内存中。

**redo**：修改一条数据，先写redo日志，再写数据。再写完redo日志后直接返回修改成功，并且还把磁盘的随机写入(写数据)变为了顺序写入(redo日志)，性能有很大提高。并且redo日志在缓冲区里面也有日志缓冲。当数据库挂了以后，就能找到那些没有数据没有刷新到磁盘的数据页，然后进行恢复，保证数据不丢失。

**undo日志**：当你发现修改错误一条数据的时候，可以通过rollback指令回滚之前的操作，这个功能需要undo日志来支持，此外 为了数据库的并发实现了MVCC的机制，undo日志在缓冲池中也有对应的数据页，与普通的数据页一起进行管理，根据LRU算法刷新，对undo页的修改也需要先写undo日志

**检查点**：checkPoint，数据库为了提高性能并不是每一次修改后都会刷新到磁盘，而是根据checkPoink的值就女性刷新。并且宕机后，数据库不需要重做所有的日志，因为CheckPoint之前的页已经刷新回磁盘，只需要对CheckPoint之后的重做日志进行恢复。

## Innodb的优缺点？(围绕索引数展开讲)

支持事务ACID。

查询的时候可能会比Myisam效率低一些。

B+数

## 回表？最左原则？

回表就是当前B+树索引树里面保存的字段找不到想要的数据，需要去其他B+树去查找。比如说先根据当前B+树拿到主键id，然后根据主键id再去主键的B+树上去查找整行完整数据，这个过程称为回表。

最左匹配原则：如果是联合索引，比如同时为a，b，c三个字段建立了一个索引，那么会根据a的顺序先排序，排序后在a排序好的基础上再根据b的顺序来排序，然后在ab排序好的基础上再根据c的顺序来排序。

所以再使用该三个字段的索引查询的时候，比如保证b出现的时候a位于前面，c出现的时候b位于前面，否则可能会造成查询整个B+树，导致性能教低。

## explain有哪些字段？

id：查询序号

Id列数字越大越先执行，如果数字一样大，那么就从上向下执行。

select_type：

- SIMPLE_TYPE : 简单的select(不使用union或者子查询)
- UNIO：如果第二个seleclt出现在union之后，则被标记为Union
- SUBQUERY：在select或者where列表中包含了子查询

有可能使用索引的列possibale_key，实际使用索引的列key，Type(查询的速度级别)，其他的忘了。

**type**相当于是最重要的，可以看索引的效果好不好。

key的常见的参数类型有：

- const : 只经过一次查找就找到了，只有一条数据。比如 where a = 20 ，a还是聚集索引。

- eq_ref，相当于很快，在多条数据中找到了唯一一条数据,常见于唯一索引。eq_ref则是用于连表查询的情况下，按联表的主键或者唯一索引联合查询；

- ref，表中多条数据中找到了多条数据。

- range：根据范围查找的数据，比如 where a > 20 并且a还是聚集索引。就会出现该情况

- index：根据索引找到了数据，非聚集索引，想根据索引找到了相应的列，再去根据该列获取到整行数据。

- all ：整个B+树查找，效率最低。相当于索引没有使用到，进行了全表扫描。

- 速度排序  const > eq_ref > ref > range > index > all

- row：预计可能查出来的行数

- ref：显式索引的哪一列被使用了

- Extra：额外信息，比如是否使用了索引，where条件，firesort，是否创建了临时表等等信息。

**简单来说 const是直接按照主键或者唯一索引读取，而eq_ref则是用于连表查询的情况下，按联表的主键或者唯一索引联合查询**

## 一个Sql查询很慢，从哪些地方进行优化？

一般来说程序查询慢的话原因一般都有：

- **没有使用索引查询**
- **IO吞吐量小，有瓶颈**
- **内存不足**
- **返回了不必要的行和列**
- **没有正确规划的使用索引，导致索引失效**
- **锁或者死锁**
- **硬件配置低下**

可以优化的：

- **正确的使用索引,使用explain字段提前分析SQL语句**
- **提升配置**
- **尽量需要什么列和行就查询需要的，不造成数据冗余**
- **避免死锁和锁的大量竞争，可以使用分库分表，读写分离**
- **使用Profile来跟踪查询，找出SQL问题的所在**
- **提升网络带宽和IO吞吐量**

## 自增ID和UUID的区别？(页分裂)



## 自增ID申请完了会发生什么事情？

如果int类型的自增ID申请完了以后，再插入数据将会报错重复的主键的key。

解决方案也就是mysql主键改为bigint，也就是long 八个字节。

自增ID申请完了以后，分为两种情况

- **如果设置了主键，那么将会报错主键冲突**
- **如果没有设置主键，并且表中还没有唯一索引并且不为NULL的列，那么数据会帮助我们生成一个6字节大小的row_id,新数据会覆盖老数据**

一般来说表都要设置主键，如果表中行数据会多的话，可以设置long类型。

## 数据库热点查询的数据，怎么做性能优化？

建立缓存，比如redis缓存，并且Innodb底层也会在缓冲池缓冲热点查询数据，根据LRU算法缓存。

## Innodb的索引树数据结构？为什么用B+树？

文件很大，不可能全部存储在内存上，所以要存在磁盘上。

根据业务场景，不可能每次只查询一条数据，所以Hash索引不适合。

根据磁盘的IO读取次数，B+树比B树更适合用做索引树,红黑树更是要排除在外。

并且如果要查询多条连续的数据，B+树不用跨层，并且叶子结点通过链表相连接，可以直接查询到多条数据。而B树可能需要跨层查询。

**B+树除了叶子结点其他结点并不存储数据，所以可查询范围大，磁盘IO次数小**

**B+树所有的data都在叶子结点，会有优化，可以将所有的叶子结点用链表连接起来，这样遍历就能获取到所有数据。**

## BinLog有几种录入格式？区别是什么？

**三种格式** 

- **statement 陈述**
- **row 行**
- **mixed 混合的**

statement：每一条会修改数据的SQL都会被记录到binlog中

优点：不需要记录每一行数据的变化，减少binlog日志量，节约了IO，提升了性能。但是不是一定的，如果表中有update多条表操作，或者alter table表这种操作，那么row模式就不适合，因为会产生大量的日志。

缺点：由于记录的只是执行语句，为了让slave从机上正确运行，可能还需要保存执行SQL一些需要的上下文信息，并且该模式下可能会造成从机不能正确复制数据，比如使用了一些函数不能被正确复制，比如sleep函数等。

row ：记录的是每一行数据被修改

优点：binlog中可以不记录执行的sql语句的上下文相关信息，仅需要记录数据被修改为什么样子了，并且一些特定的存储过程和函数也不用担心不被正确复制

缺点：所有的执行语句，都以每行记录的修改来记录，可能会产生大量的日志文件，比如update多条语句，那么会记录每一行被修改的数据，比如alter table删除某一列，那么会记录每一行的某一列都被删除了，造成大量的日志文件

mixed ：顾名思义，混合的使用statement模式和row模式

一般的语句修改使用statement格式来保存binlog，如一些函数，比如sleep函数等，statement无法完成主从复制，则采用row格式保存binlog。

新版本的Mysql中row_level也做了优化，并不是所有的修改都会以row来记录，像表结构更改就会以statement模式来记录。

## 为什么会有最左匹配原则？

因为有联合索引的出现，并且还要为联合索引做优化，比如 a,b建立一个索引，那么就需要先给a排序，在a的基础上再给b排序，以此来优化查询速度，否则就不知道应该怎么对联合索引进行优化。

**Mysql创建联合索引首先会对最左边，也就是第一个索引字段进行排序**

**在第一个排序的基础上，再对第二个进行排序，依次类推。**

**所以第一个字段一定是绝对有序的，而第二个字段无须。**

**所以才要强调最左匹配原则。**

## 如何减少回表？

尽量不要使用select * from where a = 20这种语句，并且a还不是聚集索引，这种情况的话，会造成回表，如果减少回表的话就是尽量需要什么数据就查询什么数据，比如说创建了三个索引，a,b,c 再根据条件查询的时候，select * from where a = xx and b= xx and c = xx;这种情况会额外造成一次回表，select a,b,c from where a = xx and b= xx and c = xx，可以使用这样来不回表。因为Innodb会为个索引创建一个B+树，并且它们是非聚集索引的话，它们是不存放数据的，只存放索引列和主键自增列。

使用覆盖索引。尽量不先定位主键，再定位行记录。将需要的字段建立到联合索引上。

## 缓冲池里面有什么？ 通过什么来管理缓冲池里面的页面？

**数据页，索引页，插入缓冲页，undo页，自适应哈希索引，锁信息。**

**主要存放的是数据页面和索引页面，还有插入缓冲页等等。**

**根据LRU算法来管理缓冲区的页面。**

**LRU列表，FREE列表**

mysql刚启动的时候没有数据，没有任何的数据页，当需要保存数据页的时候页是怎么申请的呢？其实是去Free列表也称为空闲页，判断里面是否还有空闲页，如果有则去申请一个页，然后将该页删除。插入到LRU列表。Free列表会被操作系统按照默认的缓存页大小分配多个页记录到Free列表中。

如果当Free列表中没有可用的空闲页的时候，那么会根据LRU算法(最近最少使用算法)，移除对应的数据页，如果该数据页的数据还是脏页的话，那么首先会进行数据的持久化操作。

## 插入缓冲是什么？二次写是什么？

插入缓冲是为了提高辅助索引的性能，因为辅助索引在进行插入的时候需要查找自己需要插入对应的位置，是随机IO，查找的时候可能会导致多次IO操作，因为可能不处于连续的页，那么多次合并插入将相同页的辅助索引一起插入，则会提高效率。插入缓冲也是使用B+树来管理的。可以将多个相同页的索引合并插入，提升性能。

对于非聚集索引的插入和更新操作，首先会判断对应的索引页是否在内存之中，如果在那么就进行直接插入，否则插入到插入缓冲来进行合并插入。可以将多个插入操作合并为1个插入操作。

索引是唯一的话，还需要判断是否唯一，造成离散IO读取，插入缓冲本来就是为了减少离散IO磁盘读取次数的。

索引如果是聚集索引的话，那么就是顺序IO了，根本不需要离散读取IO了，也就没必要进行插入缓冲了。

想要使用插入缓冲的前提必须是

- **索引是辅助索引**
- **索引不是唯一的**

插入缓冲的坏处：

**1.可能导致数据库宕机后恢复时间过长，因为可能存在大量的插入缓冲还未插入。**

**2.在写密集的情况下，可能会造成缓冲池的内存被占用过多，最大可以被占用1/2。**

插入缓冲是为了提升性能，二次写是为了提高可靠性，牺牲了一点点性能。

由于文件系统页的大小是4k，而Mysql默认页的大小是16K，磁盘IO的最小单位是512MB。

如果数据库正从内存向磁盘写一个数据页的时候，数据库宕机，造成数据页的损坏和数据的丢失，redo是没有办法来恢复的，因为redo只是记录对页的物理修改，如果页本身已经损坏，重做日志也无能为力。

二次写原理

- **当刷新缓冲池脏页的时候，并不直接写磁盘，而是先将数据拷贝到两次写的缓冲区里面**
- **将这从两次写缓冲区分两次写入到磁盘共享表空间中每次写1KB。**
- **写完之后呢，再将两次写缓冲区数据写入到数据文件**

二次写是防止页的错误，虽然可以通过redo日志文件来恢复数据，但是数据都是以页的方式来保存的，那么如果页坏了呢？数据也就消失了，而二次写就是为了防止页出现错误。



## Master Thread在Innodb里面都干了什么事情？

合并插入缓冲，将热点数据放置在缓冲队列根据LRU算法，同步缓冲页的数据到磁盘文件，同步日志缓冲到磁盘文件等等

主要分为主循环(loop),后台循环(background)

大致分为每秒的操作和每10秒的操作

1.每秒一次的操作包括：

**1)  合并插入缓冲(可能)**

**2）日志缓冲刷新到磁盘，即时这个事务还没有提交(总是)**

**3）将脏页同步到磁盘**

2.每10秒的操作包括：

**1）刷新100个脏页到磁盘(总是)**

**2）合并至多5个插入缓冲(总是)** 

**3）将日志缓冲刷新到磁盘(总是)**

**4）删除无用Undo页(总是)**

## Mysql的事务是怎么实现的？

- **事务的原子性是通过undo log来实现的**
- **事务的持久性是通过redo log来实现的**
- **事务的隔离性是通过(读写锁+MVCC)来实现的**
- **事务的一致性是通过原子性+持久性+隔离性实现的**

原子性是通过undo log来实现的，记录的是逻辑日志，比如增删查改的SQL语句，可以理解为记录的是反反向的SQL语句，比如修改id为5的名字从小红变为小花,那么undo log日志文件记录的是修改id为5的名字从小花变为小红。记录的是与**操作数据相反的SQL语句**，除此以外还用来实现**多版本并发控制**，然后将Commit提交失败的通过undo日志回滚数据。并且也是有undo日志缓冲的，并且在OS操作系统层面也有文件系统缓冲，如果突然宕机了呢？那么就无法进行数据的回滚了，所以inndob提供了一个参数可以进行选择不同的策略。等会说

事务的持久性是通过redo log来实现的，记录的是数据页的物理数据，记录被修改为了什么，也具有和undo一样的日志缓冲和OS文件系统缓冲。循环写的方式，通过LSN标记来判断写到哪里了。先写数据，再写日志，当Commit成功的话，将日志缓冲刷新到磁盘，数据缓冲按照LRU算法来刷新进脏页。

undolog 和 redo log都不是直接写道磁盘的，而是先写到缓冲池的log buffer 再看OS的 osbuffer，再由操作系统决定什么时候刷新到磁盘。

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210412225906002.png" alt="image-20210412225906002" style="zoom:50%;" />

Innodb提供了一个参数，**Innodb_flush_xxx。可选数字为0，1，2**

0 ：每秒将缓冲池的日志数据刷新到os buffer，再调用系统函数 fsync()刷新到磁盘 期间要经过 log-buffer(缓冲池的日志缓冲)->osbuffer->磁盘

1：将数据先写到logbuffer，每次当进行Commit事务提交的时候，直接将数据写入到操作系统文件缓冲区再调用系统函数fsync()将数据同步到磁盘。

2：每次当进行Commit事务提交的时候将数据刷新到os buffer，再写入到磁盘，减少了一次数据拷贝的过程(log buffer->os buffer)

数据库崩溃后重启，此时数据库处于数据不一致的状态，首先读取redo日志，将那些已经提交但是还未刷新到磁盘的脏页刷新到磁盘，再读取undo log页将那些没有成功提交的事务进行回滚，保证了原子性。数据被恢复为一致性。

## 隔离级别的区别？都是怎么实现的？

读未提交 -> 脏读 (直接修改表中数据)

已提交读 -> 不可重复读  (两次读取的数据不一致)，另外一个事务提交了以后会同步到表中，然后该事务一直读表

可重复读 -> 幻读 innodb下可以通过mvcc+行锁+间隙锁解决。 相当于快照，首先去使用当前读读取表中对应的数据，然后添加版本号，第二次再去读取如果版本号一致则从表中数据，否则去undo日志文件读取快照的数据。

串行化(通过锁表来实现的)

## 事务数组是什么？高水位指的是什么？低水位指的是为什么？

不知道

## SQL语句执行流程？分析器优化器执行器都是什么？

select * from user where id = 1 group having

FORM ->  JOIN -> WHERE -> IN/EXIST-> GROUP->Having->ASC/DESC

执行器就是执行SQL语句的，优化器就是对你的SQL进行优化，比如说看你的SQL语句可不可以使用索引，或者整理你的SQL。

分析器就是分析你的SQL语句是否合法，是否正确。 

## 索引下推？

## 什么是 “当前读”？

- **当前读** ：

像select for update,update,insert,delete,select lock in shared mode,这些操作都是当前读，为什么是当前读？因为它读取的是记录的最新版本，读取时候还要保证读的时候其他事务不能写，会对读加共享锁，写加排他锁。

- **快照读**

像不加锁的select就是快照读，非阻塞的读；快照读的前提是事务的隔离级别不是串行级别，串行级别下的快照读会变为当前读，之所有出现快照读是出于性能的考虑，快照都的实现是基于多版本并发控制MVCC，既然是基于多版本，那么快照图可能读到的并不一定是当前数据的最新版本，而有可能是之前的历史版本

- 准确的说，MVCC多版本并发控制指的是维持一个数据的多个版本，使得读写没有冲突。仅仅是一个理想概念
- 而快照读就是Mysql为我们实现Mvcc理想模型中的一个具体实现，相对而言当前读就是悲观锁的具体功能的实现。
- MVCC具体实现是由三个隐式字段，undo日志，Read View等去完成的。



## MVCC实现原理？事务的实现原理？

- **MVCC+悲观锁**

**MVCC解决读写冲突，悲观锁解决写写冲突**

- **MVCC+乐观锁**

**MVCC解决读写冲突，乐观锁解决写写冲突**

每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段

- **DB_TRX_ID**
   6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID
- **DB_ROLL_PTR**
   7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）
- **DB_ROW_ID**
   6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引
- 实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了

当插入一条数据的时候，首先对该数据加行锁，然后写入到undo log日志。比如说插入一个名字为Jenny，age等于24的一行，假设没有主键，那么下列的图，但是一般来说事务ID不是NULL，事务会向mysql申请一个ID

![image-20210413115001744](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210413115001744.png)

然后打算修改该条记录的名字为Tom

那么会进行的操作就是首先对该行加行锁，然后针对该行操作的相反操作拷贝到undo日志文件，作为旧记录，即在undo log中有针对当前SQL语句操作相反的操作，保存的反操作sql解析后的逻辑。

然后再去修改数据并且修改name，事务ID为新事务ID，DB_ROLL_PTR回滚指针保存的是undo log针对当前操作相关的相反操作。然后释放锁。

![image-20210413115531529](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210413115531529.png)

又来新的事务修改该行的age字段，将age字段修改为30

此时也是先加锁，拷贝当前行数据，发现已经该行记录已经有undo了，然后采用头插法，插在undo log的最前面，修改该行age为30，回滚指针指向undo log的头链表旧记录。

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210413115748058.png" alt="image-20210413115748058" style="zoom:50%;" />



undo log的链首就是最新的旧记录，链尾就是最老的旧记录。

undo log主要分为两种

- **insert undo log 仅在回滚的时候需要，并且在事务提交后可以立刻被丢弃。**(可以被purge线程清理)
- **update undo log 不仅在回滚的时候需要，在快照读的时候也需要**

![img](http://xpbag.com/wp-content/uploads/2020/09/wp_editor_md_5579afd7aa714c6faf5eaa32a6645365.jpg)

**读未提交**，性能最好，相当于根本就没有加锁，可以理解为没有隔离

**串行话**，读的时候加共享锁，写的时候加排他锁，可以并发读，不可以并发写，也不可以并发读写。实现是在每个select 后面加 lock in shared mode ，也就是共享锁。

再说**读已提交和可重复读的实现原理**

是通过一个叫做 read view的结构来实现的，

reda_view中维护了系统中当前活跃事务集合的快照，并且还有一个事务ID的最小值 up_limit_id和事务的最大值low_limit_id。

并且每行都会有三个隐藏的列，DB_TRX_ID,DB_ROOL_PTR,DB_ROW_ID。每次开启事务的时候会分配一个事务ID向DB_TRX_ID,当更新该行的时候，会递增该行的事务ID，并且同时将旧行拷贝到undo log,然后新修改的行数据的DB_ROOL_PTR的指针会指向undo log的旧数据，就这样形成一个链表

select操作返回结果的可见性是根据以下规则的：

当DB_TRX_ID < up_limit_id的时候代表在创建read view的时候该行数据是最后一次修改，可见。

当DB_TRX_ID > low_limit_id的时候代表在创建read view后该行被修改，不可见，然后根据该行的DB_ROLL_PRT去undo log里面去寻找旧的记录重新再次进行判断。

当 up_limit_id <= DB_TRX_ID <= low_limit_id ->需要进一步判断

read_view通过一个集合来来管理所有正在活跃的事务

如果判断集合中包含当前行的DB_TRX_ID，那么就代表当前事务还未提交，不可见，后根据该行的DB_ROLL_PRT去undo log里面去寻找旧的记录重新再次进行判断。

如果判断集合中不包含当前行的DB_TRX_ID，那么就代表当前事务可见，说明该DB_TRIX_ID是在read view创建之前的。

如果这条记录的delete_flag为true，说明这条记录已经被删除，不返回

否则进行返回。

用MVCC这一种手段可以同时实现RR和RC隔离级别

RR：read view 是再 **first touch read** 第一次读的时候创建的，也就是执行事务中第一条select语句的一瞬间，后续的所有select都是复用这个read view，所以能保证数据的一致性

RC：每次读取，都会创建一个新的read view，所以每次一个新的查询，都相当于一个新的read view，所以能查询到其他事务已经提交的数据。



## 说说Innodb的四大特性？

插入缓冲，二次写，异步IO，自适应哈希索引，刷新临近页

## 索引什么时候会失效?

or会失效，范围 比如 > < 会失效，limit一开始有%的失效，字符串不加单引号的失效，对索引进行函数操作的失效，没有符合最左匹配原则会失效。

# NIO+NETTY

## 面向流和面向块你是怎么理解的？

而流则是以字节为大小单位的，速度偏慢，因为是以字节一个一个的写入socket缓冲区的

BIO是面向流的，NIO是面向缓冲(块)的，NIO则底层是一个byte数组，因为数组在物理空间内是连续的，那么它就可以将数组在物理内存的起始位置和长度写入到内核的socket缓冲区，然后内存的socket缓冲区自己去以块的方式读取数据。因为数组是连续的。而BIO则是通过自己一个一个字节去写数据。

**块传输的问题**？

如果没有直接缓冲区，那么在块传输的时候如果发生了FULL GC，导致线程stop world操作，然后进行堆的内存整理工作，可能会清除内存碎片和移动对象来方便大对象存储，那么此时数组在物理内存的起始位置导致问题，造成错误。JVM解决方法就是向操作系统申请一块堆外内存，然后以DirectByteBuffer的形式去访问。网络传输的时候一定会用到堆外内存，哪怕程序没有使用，底层也会创建一个堆外内存临时缓冲区。

![image-20210327171040165](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210327171040165.png)

最后一段话会输出yes，因为当WeakReference所引用的对象被回收以后，该WeakReference对象会被加入到ReferenceQueue中。

pending 挂起 active活动  Enqueued  入队状态

![image-20210327174429194](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210327174429194.png)



## Nio的零拷贝以及Netty的零拷贝和操作系统的零拷贝区别？

首先来看一下什么是零拷贝

官方解释如下

```bash
“Zero-copy” describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. This is frequently used to save CPU cycles and memory bandwidth when transmitting a file over a network.
零拷贝描述了在CPU不需要执行从一个内存区域到其他区域拷贝数据的计算机操作。这通常用于网络上传输文件的时候节省CPU周期和内存带宽。
```

零拷贝防止了数据在内存中的复制，可以提高网络传输的性能，疑问？

- 为什么会出现数据的复制？
- 零拷贝真的是0次数据拷贝吗？

Linux系统中的零拷贝
继续往下之前，需要了解几个OS的概念：

内核空间：计算机内存被分为**用户空间**和**内核空间**。内核空间运行OS内核代码，并可以访问所有内存，机器指令和硬件资源，具有最高的权限。
用户空间：**即内核以外的所有空间，用于正常用户进程运行。用户空间的进程无权访问内核空间，只能通过内核暴露的接口----系统调用(system calls)去访问内核的一小部分。如果用户进程请求执行系统调用，需要给内核发送系统中断(software interrupt)，内核会分派相应的中断处理器处理请求。**
DMA：**Direct Memory Access(DMA)是来应对CPU与硬盘之间速度量级不匹配的问题的，它允许某些硬件子系统访问独立于CPU的主内存。如果没有DMA，CPU进行IO操作的整个过程都是阻塞的，无法执行其他工作，这会使计算机陷入假死状态。如果有DMA介入，IO过程变成这样：CPU启动DMA传输，期间它可以执行其他操作；DMA控制器(DMAC)在传输完成后，会给CPU发送中断信号，这时CPU便可以处理传输好的数据。**

DMA可以独立于CPU之外来进行与IO和内存之间的数据传输。	

网络IO的常见场景，就是文件从磁盘读取出来，并且通过网卡发送到网络。

```jva
File.read(fileDesc,buf,len) //从磁盘读取数据
//发送网络数据
socket.write(socket,buf,len)
```

简单两句话，但是深入到系统层面，分析到底做了什么

用户发起read()系统调用请求读取数据，会发送**一次**上下文切换然后内核DMA从磁盘读取数据，先通过磁盘DMA到内核空间的DMA缓冲区，经过**一次拷**贝，再通过内核空间**拷贝**到用户进程空间，然后返回read()调用，**一次上下文切换**。2次数据拷贝，2次上下文切换。

再发起write()系统调用，一次**上下文**切换，然后再将数据写入到网络，将用户进程空间数据**拷贝**到内核空间网络堆栈相关的缓冲区，内核将数据发送到网卡上，**一次数据复制**，然后返回write()系统调用，再进行一次**上下文**切换.

**合计4次的数据拷贝和4次的上下文切换。**有很多次都是不必要的。

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210326110147110.png" alt="image-20210326110147110" style="zoom:50%;" />



对于上述单纯的发送文件来说，用户空间的拷贝完全是没必要的。可以减少用户空间到内核空间的两次拷贝和两次上下文切换。

**SendFile传输**

实现了用户空间层面的零拷贝，数据直接从内核DMA缓冲区进行复制，然后直接写入到socket缓冲区，在发送到网卡。

也就是read系统调用，上下文切换，然后DMA从磁盘将数据copy到内核dma缓冲区，然后再将数据copy到socket缓冲区，然后再将数据copy到网卡，然后read系统调用返回，上下文切换。

**可以看到有2次的上下文切换和3次的数据拷贝**。彻底实现了用户空间层面的零拷贝。、

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210326111228400.png" alt="image-20210326111228400" style="zoom:50%;" />



<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210327152045828.png" alt="image-20210327152045828" style="zoom:50%;" />

为什么内核缓冲区需要拷贝到内核的socket缓冲区呢？**这是因为早期的网卡要求发送的数据必须在物理地址上是连续的，但是如果网卡支持收集和分散操作Scather-Gather，那么就可以再少一次数据的拷贝，只需要将数据的位置和长度告诉socket缓冲区。再少一次数据的拷贝**。

真正意义上的实现了**零拷贝**

网卡支持**Scatter-Gather**的sendFile传输，数据在**内存中的复制**已经完全避免。真正意义上的做到了**零拷贝**。只剩下了两次DMA复制。

**SendFile传输**的缺点是不能对数据进行额外的操作，如果想要进行额外的操作，那么将无能为力。

**内存映射(mmap)**

**采用内存映射的方式将用户空间和内核空间做了一个映射，也就是共享同一块内存空间。**

然后当mmap()发起系统调用的时候，首先CPU会陷入缺页异常，然后将指定的文件加载进该内存，然后你的程序就相当于将文件当作内存一样来访问，并且也不需要read和write()系统调用，因为已经用户空间的逻辑地址和内核空间的逻辑地址映射为了同一个物理地址。

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210327153439783.png" alt="image-20210327153439783" style="zoom:50%;" />

节省内核空间和用户空间之间的来回复制。

JDK的零拷贝是基于底层操作系统系统的，具体类为FileChannel里面的map方法，返回MappedByteBuf对象，该map方法底层调用的是OS的mmap()系统调用，也就是基于底层的内存映射。而JDK的transferTo()方法底层是对OS操作系统sendFile的封装，实现了零拷贝。

Netty底层是基于NIO的零拷贝，比如DefalueFileRegion封装了FileChanel的transfer()方法。

并且实现在**操作系统的基础上实现了JVM层面的零拷贝**，减少了JVM级别复制数据的过程，使用的是复合缓冲区，将多个缓冲区看作一个，compisiteByteBuf。	使用的是Scatther/Gather技术。**ByteBuf**

虚拟内存：

用户都是对用户的进程逻辑空间进行操作，然后MMU单元通过内核的地址映射表去找到对应真正的物理地址，并且虚拟内存是可以大于物理内存的，因为操作系统都是以页的方式管理数据的，可以根据LRU算法将最少使用的页移入到磁盘的SWAP交换区。

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210327150546042.png" alt="image-20210327150546042" style="zoom:50%;" />

将内核的文件缓冲区和用户进程的缓冲区映射为同一个物理内存，减少一次copy

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210327151339324.png" alt="image-20210327151339324" style="zoom:50%;" />

传统IO将数据从磁盘读取并且发送到网络端需要4次上下文切换和4次数据拷贝。

## 堆外内存是如何被释放的？

DirectBytebuffer在创建的时候同时创建了一个Cleaner对象，该Cleanner对象是一个虚引用，Reference类它有一个守护线程，里面不停会循环消费pending队列，如果消费到的对象是Cleanner对象，说明外部没有强引用了，此时去执行Cleanner对象的clean方法，该clean方法会首先移除自身，然后调用内存释放器的run方法，该方法就是释放堆外对内。

**pending队列的加入是被垃圾收集线程方法执行的.**

**首先需**要了解引用，虚引用，软应用，弱引用。

弱引用只要发生GC就会被垃圾回收，并且将数据加入到Pending队列，如果构造方法还传入了ReferenceQueue，则会将该WeakReference加入到你指定的队列中。WeakHashMap就使用该方法来判断哪些Entry是需要被清理的。

![image-20210327171040165](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210327171040165.png)

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210327174429194.png" alt="image-20210327174429194" style="zoom: 50%;" />

active代表引用的对象外部还有强引用，如果强引用消失，并且经过GC，垃圾收集线程会将该对象加入到pending单向链表中，然后判断你此时有没有指定队列，如果指定了则再加入到你指定的队列。

```java
//指定pending队列的头。  
//并且Reference类加载的时候会启动一个守护线程，作用是一直消费该链表里面的对象。
//并且每次都会从头开始消费
private static Reference<Object> pending = null;

//VM线程通过该字段来和Pending构成一个链表
 transient private Reference<T> discovered;  /* used by VM */
   //构造器指定的队列，虚引用必须指定。
    volatile ReferenceQueue<? super T> queue;
```

```java
 static boolean tryHandlePending(boolean waitForNotify) {
        Reference<Object> r;
        Cleaner c;
        try {
            synchronized (lock) {
                if (pending != null) {
                    r = pending;
                    // 'instanceof' might throw OutOfMemoryError sometimes
                    // so do this before un-linking 'r' from the 'pending' chain...
                    c = r instanceof Cleaner ? (Cleaner) r : null;
                    // unlink 'r' from 'pending' chain
                    pending = r.discovered;
                    r.discovered = null;
                } else {
                    // The waiting on the lock may cause an OutOfMemoryError
                    // because it may try to allocate exception objects.
                    if (waitForNotify) {
                        //当前线程释放锁，同时阻塞当前线程，直到JVM垃圾收集线程调用lock.notify唤醒。
                        lock.wait();
                    }
                    // retry if waited
                    return waitForNotify;
                }
            }
        } catch (OutOfMemoryError x) {
            // Give other threads CPU time so they hopefully drop some live references
            // and GC reclaims some space.
            // Also prevent CPU intensive spinning in case 'r instanceof Cleaner' above
            // persistently throws OOME for some time...
            Thread.yield();
            // retry
            return true;
        } catch (InterruptedException x) {
            // retry
            return true;
        }

        // Fast path for cleaners
        if (c != null) {
            //调用clean清理
            c.clean();
            return true;
        }

        ReferenceQueue<? super Object> q = r.queue;
        if (q != ReferenceQueue.NULL) q.enqueue(r);
        return true;
    }
```

## Nio的内存映射文件是怎么实现的？怎么使用？为什么需要内存映射文件？

底层依靠**mmap()系统调用**，通过FileChannel的map方法返回MappedByteBuffer来使用，相当于操作文件就像操作内存一样，底层将**用户进程虚拟空间和内核逻辑空间映射为同一个物理地址，并且在进行mmap调用的时候会产生一个缺页异常**，会去将磁盘的文件读取到内存中，然后就可以对该文件进行操作了。直接read和write可以直接对数据进行操作，**不适合大文件**因为是依靠虚拟内存的换页功能，如果太大换页频繁效率低。

**因为sendFile只能用于读取和发送数据，不能对读取来的数据进行操作，而传统的read和write调用速度偏慢，CPU复制多开销大。**

## BIO丶NIO丶AIO的区别

Bio阻塞IO，同步且阻塞。一个socket对应一个线程。

Linux的Nio 是同步非阻塞的，但是不支持多路复用。

NIO：NewIO，JAVA jdk1.4之后出现的，同步非阻塞并且支持IO多路复用，可以多个Socket对应一个线程，依靠select选择器，轮询所有的socket。

AIO：异步非阻塞，需要底层操作系统的支持，比较复杂，Mysql的Inoodb引擎大量使用了AIO。

## Netty是什么？

Netty是一款基于JDK NIO的高性能的网络通信框架。原生NIO API开发较为困难，并且粘包拆包没有良好的解决方法，客户端断连，网络安全性等等都没有可靠解决方案

**支持多种协议** 如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。

而Netty框架则为我们干了这些所有事情，并且更易于开发网络程序。

## 为什么要使用Netty？

因为需要开发高性能，高并发，高伸缩性的网络通信软件，需要使用Netty框架，底层屏蔽细节，性能高,相比于NIO更简答易用。

- 统一的API，支持阻塞和非阻塞
- 简单而强大的线程模型
- 自带编解码器解决TCP粘包拆包问题
- 社区活跃
- 比NIO的ByteBuffer更优化
- 支持SSL/TLS等等

## Netty的特点？

一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持

**使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式。**

采用多种decoder/encoder 支持，对TCP粘包/分包进行自动化处理

可使用接受/处理线程池，提高连接效率，对重连、心跳检测的简单支持

可配置IO线程数、TCP参数， TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuf

**通过引用计数器及时申请释放不再引用的对象，降低了GC频率**

使用单线程串行化的方式，高效的Reactor线程模型

大量使用了volitale、使用了CAS和原子类、线程安全类的使用、读写锁的使用

## Netty的应用场景？

游戏，大数据，微服务之间的调用RPC等等，实现消息推荐，自定义协议。

## Netty的核心组件？分别有什么用？

**ChannelHandler** 用于编写业务逻辑与数据的编解码

**ChannelPipeLine**，用于将多个ChannleHandler链接起来并且拦截Channel的入站和出战操作

**ChannelHandlerContext** ：与ChannelHandler之间一一绑定，提供了大量写数据的API，并且通过该类可以到达下一个出战或者入站的ChannelHandler，通过该类访问对应的ChannelPipeLine，然后找到下一个ChannelHnadler，

**NioEventLoopGroup**
NioEventLoopGroup，主要管理eventLoop的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个Channel上的事件，而一个Channel只对应于一个线程。

**NioEventLoop**
NioEventLoop中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用NioEventLoop的run方法，执行I/O任务和非I/O任务：

I/O任务 即selectionKey中ready的事件，如accept、connect、read、write等，由processSelectedKeys方法触发。
非IO任务 添加到taskQueue中的任务，如register0、bind0等任务，由runAllTasks方法触发。
两种任务的执行时间比由变量ioRatio控制，默认为50，则表示允许非IO任务执行的时间与IO任务的执行时间相等。

**Selector**
Netty基于Selector对象实现I/O多路复用，通过 Selector, 一个线程可以监听多个连接的Channel事件, 当向一个Selector中注册Channel 后，Selector 内部的机制就可以自动不断地查询(select) 这些注册的Channel是否有已就绪的I/O事件(例如可读, 可写, 网络连接完成等)，这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。

**Bootstrap、ServerBootstrap**
Bootstrap意思是引导，一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件，Netty中Bootstrap类是客户端程序的启动引导类，ServerBootstrap是服务端启动引导类。
**ChannelFuture**
正如前面介绍，在Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理，但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过ChannelFuture，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。

## EventLoopGroup和EventLoop什么关系？

EventLoopGroup里面会有多个EventLoop，每一个EventLoop和一个Thread进行绑定，用来处理IO读写事件和普通任何事件。并且每一个EventLoop可能会绑定多个Channel。但是一个Chnnel只会对应一个EventLoop

## Bootstrap和ServerBootstrap有什么区别？

ServerBootstrap是用于引导服务器的，并且具备handler和ChannelHandler，而Bootstrap适合于服务器或者无连接的UDP的，只有handler，因为客户端只需要连接，而服务器需要先等待连接，当连接建立后再建立新的子channel，也就是socket编程里面的socket，所以channelHandler相当于就是配置这个的。再通俗点说就是配置workergroup的，handler是配置bossGroup的。

## NioEventLoopGroup默认的构造函数会启动多少线程？

默认会开启CPU核心数*2，为什么是乘以2呢？

这要区别于看任务是CPU密集型任务还是IO任务，如果是IO的话就是CPU核心数*2，而CPU密集型任务的话说明需要大量的CPU计算工作，可以选择与CPU核心数相同。而EventLoopGroup执行的任务IO任务偏多，因为主要涉及到socket的数据读写，与IO相关。

## Netty线程模型了解吗？

属于Recator主从模型。

一个EventLoopGroup对应多个EventLoop，一个EventLoop又可以绑定多个Channel

Recator主从模型指的是

有一个处理Accept事件的Group，有一个专门处理读写事件的Group，当Accpet所对应的Channel连接建立成功后会建立一个子Chnanel，并且将Channel传递给workGroup里面的某一个EventLoop，去执行后续的读写事件，并且当真正执行业务逻辑的时候会放入到线程池，并且workerGroup向客户端返回信息的时候也不需要向bossGroup传递，直接响应。

多个线程处理连接事件如Accept，多个线程则负责读写。主从Reactor。

NIO和AIO的区别主要在于读写

NIO是内核通知，当前线程主动去读。

AIO是内核主动读到进程的数据缓冲区，进程直接操作数据。

## Netty长连接丶心跳机制了解吗？

TCP在进行读写之前,server与client首先必须建立一个连接，建立的过程就是我们常常指的三次握手，并且关闭连接的时候也需要四次挥手。所以短连接读写完成就要关闭连接了，每一次连接都需要网络资源的消耗，并且建立也需要时间。

这种情况就非常适合于长连接，长连接就是指的是读写完成之后不会关闭，后续的读写操作可以继续在该连接上进行。

对于频繁请求的客户来说，长连接是首选。

心跳机制是因为在TCP长连接的过程中，可能会出现网络中断，宕机等等异常情况。异常发生的时候，如果client与server没有交互的话，它们是无法发现双方已经掉线的。

心跳的原理机制就是在一定时间内如果没有交互的话，客户端或者服务端会发送一个特殊的数据包给对方，当对方收到后也发送响应数据，告诉在线。此刻便为一个PING-PONG交互。

TCP实际上自带长连接，本身也是有心跳机制，SO_KEEPALIVE。

## Netty的零拷贝？

**零拷贝指的是避免用户态与内核态的数据传输**

Netty 中的零拷贝体现在以下几个方面

- 使用CompositeByteBuf将多个ByteBuf看作是一个缓冲区，进行读取，减少JVM层面的拷贝
- FileRegion封装了NIO底层的transfer方法来实现更底层的sendFile文件传输零拷贝
- ByteBuf与ByteBuffer一样都支持Slice操作，可以分解多个共享同一区域的ByteBuf或者ByteBuffer

## Nio的组成？

Seletor，SelectionKey，ByteBuffer,Channel。

Channel注册到Selector会生成一个唯一的SelectionKey，一个Channel可以绑定到多个Selector。

ByteBuffer则是接受数据和传输数据的载体。

Channel相当于通道，经过通道来传输数据。

## TCP粘包/拆包的原因以及解决方案？

粘包和拆包都是TCP协议在传输数据导致的，因为每次传输数据的时候不知道是以什么结束的，所以可能会造成数据被一起发送过来，形成了粘包。

拆包就是说一个完整的逻辑数据，被拆分为多段，分批传输过来。

Netty的解决方案有：**固定长度，可变长度，分隔符，自定义分隔符**

可变长度就是将消息分为消息头和消息体，消息头指定数据的长度，然后每次先读取长度，然后再根据长度来读取对应的数据。

固定长度就是每次只读取指定的值，不可变。

分隔符就是看到某一个分隔符就认为之前的数据是一个完整的数据包。比如丶,:。还可以自定义分隔符。

## Netty中有哪些重要组件？

**ChannelHandler，ChannelPipeLine，ChannelFuture，ChannleFutureListener**

**ChannelHandlerContext，NioEventLoop，BootStrap,ServerBooststrap。**

## Netty发送消息有几种方式？

可以使用ChannelHandlerContext发送数据

也是Channel发送，也可以ChannelPipeline发送

Channel和ChannelPipeLine的发送语义是一样的。

ChannelHandlerContext的write()方法会将数据写入下一个ChannelHandler，

而writeflush不会，则是直接写入到底层socket通信队列直接到底层进行数据传输。

Channel是write()流经整个ChannelPipeLine，也就是所以的Handler。

writeflush也是直接写到底层socket。

write()和writeflush。

write()直接会写入到队列中

## 了解哪些序列化协议？

jdk原生序列化写于。 速度慢，但是兼容性高，原生的

jboss序列化协议 Marshing   速度比jdk快，并且修复了一系列jdk的bug

protobuf序列化协议 : 体积小传输快，性能最高，编写偏复杂，但是引入了jprotobuf编译插件，就可以使用注解，非常方便，适用于游戏或者RPC远程调用

Json序列化：轻量级的数据交换格式，比xml好，传输相比xml占用少，易于读写，缺点是数据描述性比XML差，并且性能不是特别好

xml：只能序列化字段，不能序列化方法，并且文件庞大，传输占带宽，优点是可读性高。

fastjson：优点简单易用，是JAVA语言中使用最多的JSON库。适用于Web输出，协议交互等。

## Netty支持哪些心跳类型设置？

Netty中为实现提供心跳机制提供了IdleStateHandler(闲置处理器)类来进行心跳的处理

一种是连接后在指定时间内没有操作则触发事件userEventTriggered，用户可以在该事件上处理自己的逻辑，比如关闭通道等等allIdleTimeSeconds

一种是在指定时间内没有触发写事件writerIdleTimeSeconds 

一种是在指定时间内没有触发读事件。readerIdleTimeSeconds

## Netty和Tomcat的区别？

一个是网络通信框架，可以基于Netty来编写各种自定义协议，自己的编解码。

TOmcat是基于Http协议的，实质上是一个基于http协议的web容器。

tomcat6.x以上也支持NIO模式。

## NioEventLoopGroup源码

底层会有多个EventLoop，每个EventLoop对应一个Thread

## Netty的零拷贝实现原理？

需要探究DefaultFileRegion源码。

## Netty的高性能表现在哪些方面？

IO多路复用，多线程并发，基于NIO，直接缓冲区，零拷贝，内存映射，主从Reactor线程模型，

内存池的实现等等

## 说一下Nio的select有什么问题？Netty怎么解决的？

## ChannelPipeLine 和 ChannelHandler 和 ChannelHandlerContext  三者之间的关系和创建过程？

首先当对应的BossGroup里面的EventLoop的Accept事件建立成功后，会创建一个子Channel，然后该子Channel被分配给workerGroup里面的某一个EventLoop，该子Channel和ChannelPipeLine绑定起来，然后ChannelHandler注册到ChannelPipeLine上，通过ChannelHandlerContext可以访问到下一个出战或者入站的ChannelHandler。

## 在实际的项目中，你们是怎么使用Netty 的？

对Netty和Spring整合，然后编写一个类似于Controller的实现，中间传输是基于protobuf，通过先到达ChnanelHandler然后进行编解码操作，数据包封装操作等等，然后再通过注解反射找到对应的Controller某个具体方法。

## Netty的零拷贝体现在哪里？与操作系统上的有什么区域？

DefaultFileRegion和ByteBuf的slice和CompositeByteBuf，对NIO的封装，NIO是对底层操作系统零拷贝的封装。

并且Netty还该基础上减少了NIO的ByteBuffer的拷贝次数，使用CompositeByteBuf。

## Nio的零拷贝和Netty的零拷贝有区别吗？

Netty减少了NIO中ByteBuffer不必要的复制，使用了CompositeByteBuffe。将多个ByteBuf逻辑上看为一个ByteBuf

## Selector选择器的原理？

底层是Epoll原理，然后通过SelectionKey来对应唯一的SocketChannel来进行管理。

当事件来的时候可以通过SelectionKey判断是哪个事件，比如读事件，还是Accept事件，

使用ready也就是以准备好进行的操作和你想要的操作进行与操作，如果不是0则代表该操作已经准备好，SelectionKey的事件必须是2的次方。

## Netty如何使用内存映射文件？

## Epoll，select和poll的区别？原理？

都是Linux内核实现IO多路复用的一种实现。IO多路复用的意思是在一个操作里同时监听多个输入输出源，当这些输入输出源可用的时候，对一个或者多个就绪的输入输出源来进行读写操作。

Epoll高效原理mmap+链表+红黑树，不会随着文件描述符增长而时间复杂度线性增长，基于回调函数

Select函数原理时间复杂度O(n),每次需要遍历所有的文件描述符来判断哪个已经准备就绪。

Epoll也是类似，但是没有长度限制，采用链表的机制，而不是bitMap,复杂度也是O(n)。

## 为什么Netty不需要同步实现了线程安全？

因为Netty的线程模型每次在处理读写事件的时候，会首先判断当前Channel是不是当前线程对应的EventLoop所绑定的Chnanel，如果是则直接执行，如果不是则加入队列等待其他的EventLoop来执行属于自己的读写事件。

## Neety的ChunkHandler为什么可以实现写大块数据不可能会造成内存堆积？

## Netty服务端和客户端的启动过程源码了解吗？



## Netty的内存池是怎么实现的？

## Netty的对象池是怎么实现的？

## C++函数以及select()工作原理

```c
int select(
int maxfdp1,//最大有效位到哪 本质上是一个bitmap的数据结构，默认是1024长度，1024的比特位，理论最大支持1024个，实际上达不到1024，遍历1024长度可能会浪费多余的时间。比如想设置read事件的socket为5，6，7 则设置该值为8 有效数+1
fd_set* readfds , //指向一组可读性检查的套接口
fd_set* writefds ,//指向一组可写性检查的套接口
fd_set* exceptfds ,//指向一组等待错误检查的接口
const struct timeval* timeout //select()最多等待时间，阻塞操作为NULL，无阻塞填0
);
```

select()函数的fd_set结构解析，首先它是一组文件描述符(fd)的集合，用一位来表示一个fd，映射到Socket也就是一个socket，因为Linux下一切都是文件。有下面四个宏定义操作：

```c
fd_set set;

FD_ZERO(&set)； //将set清零，使其不保存任何fd
FD_CLR(fd,&set) //将fd从set集合中清除
FD_SET(fd,&set) //将fd从set集合中加入
FD_ISSET(fd,&set)//判断fd是否在set集合中
```

现在,UNIX系统通常会在头文件<sys/select.h>中定义常量FD_SETSIZE，它是数 据类型fd_set的描述字数量，其值通常是1024，这样就能表示<1024的fd。根据fd_set的位矢量实现，我们可以重新理解操作 

```c
fd_set的四个宏：
fd_set set;
FD_ZERO(&set); /*将set的所有位置0，如set在内存中占8位则将set置为
00000000*/
FD_SET(0, &set); /* 将set的第0位置1，如set原来是00000000，则现在变为10000000，这样fd==1的文件描述字就被加进set中了 */
FD_CLR(4, &set); /*将set的第4位置0，如set原来是10001000，则现在变为10000000，这样fd==4的文件描述字就被从set中清除了 */
FD_ISSET(5, &set); /* 测试set的第5位是否为1，如果set原来是10000100，则返回非零，表明fd==5的文件描述字在set中；否则返回0*/
```

```c++
memset(&addr,0,sizeof(addr)); //常用于内存的初始化工作，将内存位置addr后面的addr大小的字节都设置为0
sizeof(a) // 返回该值占用的内存字节大小 比如 sizeof(10) 返回4
#include <sys/types.h>
#include <sys/socket.h>
int socket（int domain , int type , int protocol）;    
//创建一个socket type是套接字类型，有流式套接字TCP，数据包套接字UDP，原始套接字sock_RAM。 protocol 是协议   
```

domain参数指定了通信的范围也可以说是通信的“域”

- AF_UNIX,AF_LOCAL 本地通信
- AF_INET IPV4网络通信
- AF_INET6  IPV6网络通信
- AF_PACKET 链路层通信

```c++
typedef struct sockaddr_in {
 
#if(_WIN32_WINNT < 0x0600)
    short   sin_family; 
#else //(_WIN32_WINNT < 0x0600)
    ADDRESS_FAMILY sin_family;
#endif //(_WIN32_WINNT < 0x0600)
 
    USHORT sin_port;
    IN_ADDR sin_addr;
    CHAR sin_zero[8];
} SOCKADDR_IN, *PSOCKADDR_IN;
```

主要成员 sin_family,sin_port,sin_addr

- sin_family ：用要用来定义是那种通信域
- sin_port : 主要用来保存端口号
- sin_addr ：主要用来保存ip地址

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210329172310715.png" alt="image-20210329172310715" style="zoom:50%;" />

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210329172515235.png" alt="image-20210329172515235" style="zoom:50%;" />



如在SOCKET编程中的函数

int bind(int sockfd,struct sockaddr*myaddr,int addrlen)中的的二个参数struct sockaddr*myaddr是一个指向结构体的指针。

```c++
bind(sockfd,(struct sockaddr*)&addr,sizeof(struct sockaddr_in))
//addr是struct socketaddr_in的结构体，是代表internet环境下套接字的地址形式，而socketaddr是通用的套接字地址，指向socketaddr_in结构的指针也可以指向socketaddr。
```

![image-20210329174555143](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210329174555143.png)



```c++
 int listen(int sockfd, int backlog);
//backlog参数详解: 队列等待总数
```

首先需要理解TCP为监听套接字维护了两个队列，一个是完成三次握手之后的队列，accept事件已经准备就绪，一个是还没有三次握手或者还没有完成三次握手的队列。一般为客户端连接的数量。

![image-20210329182920885](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210329182920885.png)

```c++
int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);
//
```

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210329202828060.png" alt="image-20210329202828060" style="zoom:67%;" />

select的缺陷就是每次需要进行置位重新注册到内核，并且每次需要遍历注册的所有socket，来判断哪些是已经置为了，是一个bitmap数据结构。

**为什么select慢**

- 首先遍历如果都没有事件的时候，需要将进程加入到每个socket的等待队列中
- 如果此时有数据到来的时候，不知道是哪个具体的socket数据到来，必须还要重新再次轮询一次，通过dma中断处理程序处理数据包的端口号唤醒进程，然后使用Bitmap将对应的socket置为为1
- 将整个bitmap复制给用户空间，用户空间还需要再次遍历寻找就绪的socket
- 用户层面操作的时候并且每次循环还要重置fd_set位，重新注册到内核，并且复杂度还是线性增加的O(n)算法，在socket较少的时候还好，多了偏慢，并且最大支持1024，并且不容易修改。

## poll()和select()函数的主要区别是什么？

select具有O(N)的轮询复杂度，poll也是一样，但是poll没有最大连接数的限制，因为它是基于链表来存储的，而不是bitmap。poll还有一个特点是水平触发，报告了fd后数据没有处理，第二次Poll还会报告该id

## epoll函数工作原理是什么呢？

```c++
int epoll create(int size) //创建一个epoll结构空间，初始化数据结构
/**epfd结构的进程fd编号，函数依靠该编号找到对应的epoll结构
op表示是进行什么操作，比如说是
EPOLL_CTL_ADD：注册新的fd到epoll中，EPOLL_CTL_MOD：修改已经注册的fd，EPOLL_CTL_DEL ：从epoll删除一个fd
event结构体指针，告诉内核对该fd资源感兴趣的事件。
*/
int epoll ctl(int epfd,int op,int fd,struct epoll_event *event);

typedef union epoll_data {
    void *ptr;
    int fd;
    __uint32_t u32;
    __uint64_t u64;
 } epoll_data_t;

 struct epoll_event {
    __uint32_t events; /* Epoll events */
    epoll_data_t data; /* User data variable */
};
EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
EPOLLOUT：表示对应的文件描述符可以写；
EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
EPOLLERR：表示对应的文件描述符发生错误；
EPOLLHUP：表示对应的文件描述符被挂断；
EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。
EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里



/**
 maxevents表明的是最大就绪事件数
 timeout  0为非阻塞，-1为阻塞，大于0则是指定时间阻塞
 epfd指定要操作的epoll结构
 events是分配好的struct_event结构体数组，epoll会把发生的事件赋值给events数组中
*/
int epoll_wait(int epfd,struct_event *events,int maxevents,int timeout);

```

**epoll高效原理 mmap + 红黑树 + 链表**

使用mmap将内核空间和用户空间映射为同一内存，减少了select和poll之间来回的数据拷贝，提高性能。

并且每次插入到红黑树的结点会生成一个回调函数，该回调函数处理两件事情，就是将数据已经准备好的就绪队列，避免了像select或者poll一样在设备就绪后还需要再次轮询是哪个设备准备好。

在执行epoll_ctl的ADD操作的时候，不仅将文件描述符放在红黑树上，并且同时注册一个回调函数，内核在检测到某文件描述符可读写的时候就会调用对应的回调函数，然后将该文件描述符放在就绪列表中。

两种工作模式 

- 水平触发：事件就绪后socket数据第一次未处理第二次还会将该socket数据让你继续处理

- 边缘触发：事件就绪后用户必须处理，如果第一次没处理，那么就把数据清理掉，第二次就不会让你继续处理

  ET模式减少了epoll事件被重复触发的次数，因此效率比LT模式高。

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210329215714108.png" alt="image-20210329215714108" style="zoom:67%;" />

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210329220448072.png" alt="image-20210329220448072" style="zoom:50%;" />



**eventpoll**数据结构

有一个就绪队列和一个等队列和一个红黑树用来监听所有socket的，然后当进程调用epoll_wait方法的时候如果就绪队列里面没有数据，则会将线程加入到event_pool里面的等待队列。

加入等待队列以后的，相等于进程已经阻塞，此时需要将socket的等待队列指向当前eventpool。

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210329221327554.png" alt="image-20210329221327554" style="zoom:67%;" />

## eventpoll对象的就绪列表数据是如何维护的呢?

链表

## eventpool存放需要检查的socket信息是采用什么数据结构？为什么？

红黑树，增删查效率都比较高 时间复杂度logO(n)

## 系统中断和系统调用

系统中断分为软中断和硬中断

- 硬中断：发生在任意时刻，通常是事件驱动的方式通知某种数据到达，或者已经准备好，需要CPU干预操作
- 软中断：CPU自身发出的，比如内陷指令，或者说程序运行错误除数为0等方式造成的。系统调用主要是依靠软中断的0x80中断实现的

每一种中断都有对应的中断处理程序。

比如说当DMA交换完数据的时候，网卡向CPU发起一个中断，这个时候CPU假设在执行进程C的程序，此时需要将当前CPU执行上下文信息比如说执行到了哪一行，各种寄存器中保存的临时数值保存到进程C的PCB里面，然后去执行中断处理程序，当处理完中断处理程序的时候需要切换回进程C继续执行。

CPU有中断引脚，用来接受中断请求的，但是系统可以有许多设备，如果为每一个设备建立一个引脚肯定不够用，所以出现了8259A中断控制器，用于连接各种设备。

![image-20210329124105665](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210329124105665.png)

默认8个接口，并且还可以级联。中断是有优先级的。

![image-20210329124446501](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210329124446501.png)

每个中断都有编号，并且有自己的中断程序，都是依靠中断向量表来寻找对应的中断处理程序的。

![image-20210329124537152](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210329124537152.png)

CPU首先拿到中断请求编号，看到是哪个中断请求，然后去中断映射表去查询对应的中断处理程序入口地址。	0表示内核态，3表示用户态。

![image-20210329152626346](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210329152626346.png)

用户态和内核态切换到过程。使用80中断完成了系统调用的入口	

# 美团追魂9连问

## 请解释一下的对象的创建过程？

## 加问DCL要不要加volatile问题？

## 对象在内存中的存储布局？

## 对象头具体包括什么？

## 对象怎么定位？

## 对象怎么分配？

## Obejct o = new Object()在内存中占用多少字节？

## 为什么Hotspot不适用c++对象来代表JAVA对象？

## Class对象是在堆区还是在方法区？

# 操作系统+计算机网络

## 进程与线程的本质区别？以及各自的使用场景？

线程是独立调度的基本单位，进程是拥有资源的基本单位。

**多进程是指操作系统能运行多个程序/任务**

**多线程是指一个程序中可以运行多个顺序流。**

创建销毁线程要比创建销毁进程成本低的多，所以也有轻量级进程之称，因为进程要创建属于自己的PCB，开辟虚拟空间等等。

一个进程里面可以有多个线程，但是如果一个线程出错，会终止掉整个进程，但是一个进程挂掉不会影响其他进程。

进程有自己独立的虚拟地址空间，而一个进程中的多个线程共享进程的虚拟地址空间。

两者都可以并发执行。

**需要大量进行计算的优先使用线程，因为需要上下文切换，进程切换的开销较大。**

**需要频繁创建和销毁的优先用线程。**

**强相关的用线程，弱相关的用进程。**

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210413180728335.png" alt="image-20210413180728335" style="zoom:50%;" />

## 进程状态？JAVA中线程状态？

**OS进程状态**：

创建态(new) ->就绪态->运行态->终止态

就绪态和运行态之间可以双向转换

运行态->阻塞态->就绪态

阻塞态不可以直接到运行态，就绪态也不可以直接到阻塞态

运行态->就绪态 属于CPU调度，执行其他的进行

而就绪态->运行态 很容易理解，就是CPU获得到时间片开始运行

运行态->阻塞态  比如说申请某种资源，该资源还没有准备好，那么就会处于阻塞态，当资源准备好并且向CPU发出中断请求，然后CPU执行中断处理程序将阻塞的CPU移入到就绪队列，变为就绪态

常见的就是三种状态的转换

就绪态->运行态->阻塞态->就绪态->运行态。。。。。

JAVA进程状态：new Thread之后进入初始状态，调用start方法进入可运行状态，当分配到CPU时间片后进入运行中状态，当CPU时间片用完又重新回到可运行态 或者调用 Thread.yield，当调用Thread.sleep方法或者Thread.join进入阻塞态，当调用结束进入可运行态。

运行中的线程调用Obejct.wait方法进入ObjectMonitor的等待队列，当调用notify或者等待时间到从等待队列移动到阻塞队列，然后等待运行。

<img src="https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210413195908024.png" alt="image-20210413195908024" style="zoom:50%;" />

## 进程调度算法的特点以及使用场景？

## 进程同步问题？原理？

## 进程通信方法的特点以及使用场景？

## 线程实现方式？原理？

## 死锁必要条件？

## 解决死锁策略？如何分析死锁的代码？JAVA中如何解决死锁？

## 虚拟内存的作用？分页系统实现虚拟内存原理?

## 页面置换算法的原理？

## LRU的实现原理?手写一个

## 分页和分段的区别?以及段页式？

## 静态链接和动态链接的区别？

## TCP丶UDP的区别？

1.TCP是面向连接的，UDP是无连接的

2.TCP对系统资源的要求较多，UDP少

3.TCP保证数据传输正确性，UDP不保证

4.TCP保证数据传输的顺序性，UDP不保证

5.TCP是面向字节流的，UDP是数据报

## TCP协议如何保证可靠传输？

**校序重流拥**

**校验和**：当一次进行数据传输的时候，首先将TCP数据头的校验和字段用0填充，然后将首部和数据相加运行求和，然后求反码，填入校验和字段。

接收端接受到数据，然后将首部+头部，如果结果为1代表数据没有出错。

比如 

```bash
 1001
 0000 
=1001 ->反码  0110
然后接收端将
1001
0110 -> 1111 结果全为1代表数据正确。
```

**确认应答+序列号**

只有当ACK = 1的时候才代表确认号有用。

因为数据都是以字节发送的，发送的数据都会被编号为每个字节，比如发送端发送 1 2 3，三个字节，那么如果接收端正确接受的话，就会恢复ACK=1，确认号ack= 4，代表4之前的数据已经全部接受完毕，现在想要编号为4的数据。

**重传机制**：当发送端发送数据后迟迟没有接受到来自该数据的响应，那么会进行重新发送，直到接受到来自接受到数据的响应。TCP采用自适应算法，动态改变重传时间RTTS(加权平均往返时间)

**流量控制**：TCP发送发和接受发都有自己的接受和发送缓存，然后如果发送方发送数据速率过快，接收方来不及接受就会导致数据丢失或者出现错误，TCP的解决办法是通过设置TCP头部的窗口字段，告诉我要发送数据的大小，然后接收端会根据该值来调整接受缓存的大小，来实现流量控制。rwnd

**拥塞控制**：一般来说是通过慢开始，拥塞避免，快重传，快恢复。一般来说 慢开始和拥塞避免一起出现，快重传和快恢复一起出现。

**慢开始和拥塞控制**

发送窗口 = Min{拥塞窗口，接受窗口}

接受窗口 = 自适应调整

慢开始门限的初始化为16个报文段。

首先发送放发送数据的时候会选择拥塞控制窗口的大小和接受放窗口的大小，取最小值。慢开始算法的思路是当主机开始发送数据的时候，不立刻把大量数据注入到网络，否则可能造成阻塞。而是逐渐探测，假设默认值是1，那么发送报文段的大小会是1，2，4，8，16这样，当增加到慢开始门限值的时候，开始拥塞控制算法，每次将+1，如果当出现超时数据未响应，发送方判定为网络阻塞，于是调整门限值假设是在24超时，那么新的门限阈值就是24/2 = 12，同时设置拥塞窗口为1，重新进入慢开始阶段。下次，当执行的12的时候，又开始执行拥塞避免算法。

**快重传和快恢复**

就是当发送方连续收到3个对一个报文段的重复确认，发送方执行快重传和快恢复算法。

![image-20210413155040847](https://sober-feng.oss-cn-shanghai.aliyuncs.com/learning/pictures/image-20210413155040847.png)

比如说发送窗口初始化也为16个报文段，当收到连续来自三个一样的报文段确认的时候，不会等到超时。就不会进行慢开始和拥塞避免了，直接降低到第二次阈值处，比如说12。区别其实就是一个会降到1一个会直接降低到新阈值。

## TCP四次挥手具体过程，三次握手的原因丶四次握手的原因丶Time_Wait的作用

**三次握手过程**：发送方首先发送建立连接请求，请求头字段里面将SYN = 1，seq = x(随机值)，然后当接收方收到后开始执行初始化逻辑，比如初始化接受缓存窗口的大小等，然后响应给发送端 ACK = 1,SYN = 1,ack = x + 1,seq = y(随机值)，发送到接受到后根据请求头字段的窗口大小和拥塞窗口大小取最小值进行初始化自己的发送缓存窗口，然后再次发送给接收端 SYN = 1,ACK = 1,seq = z(随机值)

**四次握手过程**：首先想要主动断开连接方向另一方发送断开连接请求，FIN = 1，seq = x(随机值)，然后接受方收到之后发送一个响应请求，ACK = 1,ack = x+1,seq = n(随机值)，然后处理自己未完成的功能，当接收方处理完之后，再向断开请求方发送断开连接请求 FIN = 1,ACK = 1，ack = x+1,seq = y(随机值)，然后断开请求连接方收到求求以后也发送收到确认，然后发送 ACK = 1，ack = y+1,seq = n(随机值)，然后开始等待一个TIME_WAIT的时间，如果发现此时连接还没关闭，那么再次发送，因为可能接收端没有收到最后一次请求，所以需要等待一个TIME_WAIT时间。

因为可能还处于没有接收端可能还需要处理自己的一些事情，比如数据还未读取完等。也可以三次挥手，情况较少

**TIME_WAIT的作用就是保证全双工连接的可靠释放**。

TIMEWAIT等待2MLS，如果此时服务端再次发送了FIN，那么就认为最后一次连接服务端没有接收到，防止出现错误。为什么是2MLS呢，其实是2倍的MLS，其实就是指的是一个发送和一个接受所需要的最大时间。MLS网络通讯最大耗时。客户端发送最后一次，假设服务端没有收到，那么会服务器会重传一个FIN，来回2次，就是2MLS，如果没有收到服务端的FIN，则代表服务器已经接受到并且关闭了请求。



## 各层协议的作用，以及TCP/IP协议的特点？

应用层：真需要接受和处理数据的应用

传输层：TCP/UDP进行数据可靠/不可靠的数据传输，保证可靠传输

网络层：加源地址和目的地址和端口号

数据链路层：为网络层提供服务，并且对数据进行纠错，指定mac地址

物理层：介质的选择，比较笨，只管发送数据。

TCP/IP特点：可靠传输，拥塞控制。

## GET与POST比较：作用丶参数丶安全性丶幂等性丶可缓存？

GET 

- 请求会被缓存
- 请求有长度限制
- 不应在处理敏感数据的时候使用
- 数据显式在URL中
- 安全性相比POST较差

 POST

- 刷新页面的时候表单可能会被重复提交	
- 请求不会被缓存
- 对数据长度没有要求
- 安全性相比POST较高，数据显式在请求体中

幂等性：幂等的概念是指同一个请求在执行1次/多次都是完全相同的效果，PUT,DELETE,GET方法都是幂等的，而POST语义不是幂等的，重复请求可能会带来错误，或者意想不到的后果。

可缓存：顾名思义是否一个方法可以被缓存，GET方法是请求获取**指定的资源**，是安全的，幂等的，可缓存的。

而POST是根据请求体对执行的资源进行处理，POST不安全，不幂等，大部分不可缓存。

## Cookie作用丶安全性问题丶和Session的比较？

Cokkie是为了解决一次会话中的同一APP不同网站需要频繁登录的问题，每次访问浏览器就会带一个Cokkie，然后Cookie的id就会和Session里面的作比较，来保证登录问题。

## 缓存的Cache-Control字段，Expires和max-age的区别丶ETag验证原理？

max-age

## 长连接与短连接原理以及使用场景，流水线？

## HTTP存在的安全性问题，以及HTTPs的加密丶认证和完整性保护作用？

协议通信过程中，如果未进行加密，那么可能会造成数据泄漏等严重问题。

## HTTP/1.x的缺陷?以及HTTP/2的特点？

HTTP/2.0的特点

- 支持IO多路复用，一个连接并发处理多个请求。虽然HTTP/1.1可以创建多个TCP连接来支持并发请求，但是创建TCP连接都是需要开销的。
- 服务器推送
- 新的二进制格式，但是并没有改变Http/1.1的语义

## HTTP/1.1的特性？

Http1.1：

- 长连接，不需要像Http/1.0那样每次请求都要建立一个连接，keep-alive，并且支持请求的流水线处理。
- 错误通知的管理，增加了一些错误响应码，比如409 表示请求的资源与资源的当前状态发生冲突，410表示该资源被永久删除。
- HOST域，HTTP1.0中每台服务器都绑定一个唯一的IP地址，而Http1.1可以支持多个虚拟主机，所以也就可以绑定多个IP地址，且都包含Host域



## 集线器、交换机、路由器的作用，以及所属的网络层？

## IP 数据数据报常见字段的作用？

## ARP 协议的作用，以及维护 ARP 缓存的过程？

## DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡?

## 以太网的特点？以及帧结构？

## 浏览器的地址栏里输入一个url，点一下回车，会发生什么？

### （1）浏览器怎么得到url？

### （2）DNS解析是发送整个url吗？

### （3）DNS解析详细过程。

### （4）TCP三次握手之前需要什么？

### （5）ARP解析过程。

### （6）ip怎么寻址？

# Linux+Shell

## 硬链接与软链接的区别？

## 文件系统的原理？inode和block？数据恢复原理？

## 僵尸进程和孤儿进程区别？ 怎么分析僵尸进程产生的原因？

## 在 bash shell环境下，当一个命令正在执行的时候，按下control-Z会？

ctrl-c：终止正在运行的程序

ctrl-z ：挂起当前线程，将前台任务转向后台

## 文件目录data当前权限为rwx --- ---，只需要增加用户组可读可执行权限，但不允许写操作，具体方法为？

三个分别为 owners group others

数字化 r : 4  w : 2 x : 1

chmod  050data

## Linux下查看磁盘使用情况的命令是？

## 执行shell语句，可以生成/test文件的命令是(假设当前没有/test文件)

```bash
- touch /test 直接创建/test文件
- a = 'touch /test' 表示转义，' '中的内容会被执行，所以也是创建一个文件
>/test //代表输出重定向，将输出的内容写入到/test中，如果没有则创建
```

## 用什么命令来显示当前目录

- A echo $(pwd)
- B echo pwd
- C $pwd
- D pwd | echo

## linux查看系统活跃进程的命令是？



## 在[Linux系统](https://www.linuxprobe.com/)上，下面那个命令不可以用来查看文件内容？

A cat
B ls
C less
D more

## JAVA应用CPU使用率100%或者异常过高问题排查

1. 先通过top命令找到消费cpu很高的进程id
2. 再top -p pid指定监控某个进程
3. 然后按H获取当前进程的所有线程信息
4. 找到消耗cpu很高的线程编号
5. 执行jtack对当前的java应用进程做dump，输出所有的线程信息
6. 根据获取到的线程编号信息转换为16进制
7. 根据16进制的线程编号信息去所有线程信息里面找对应的线程内容
8. 解读线程信息，定位到具体代码

一般java应用cpu利用率过高基本上是因为

1. 程序计算比较密集
2. 程序死循环
3. IO读写过高
4. 程序逻辑请求阻塞

## 线程上下文类加载器如何破坏了双亲委派？SPI指的是什么

像经典的JDBC DriverManager去加载Mysql驱动的时候，static静态代码块就会去使用ServiceLoad.load去加载Driver.class,此时就会使用线程上下文类加载器，如果线程上下文类加载器为空，那么就使用默认的系统类加载器去加载，那么相当于就打破了双亲委派原则，然后会根据指定的类加载去去读取META-INF/services/下的java.sql.Driver配置文件，然后根据配置文件里面指定的全限定类名去类路径下找该类，然后进行加载。SPI是一种服务发现机制，全称为服务提供者接口。



