# 算法

## 比较类排序

### 冒泡排序

依次比较，比较出最大的

时间复杂度

- 最好时间复杂度：O(n2)
- 平均时间复杂度：O(n2)
- 最坏时间复杂度：O(n2)

空间复杂度：O(1)

稳定性：稳定的

### 选择排序

选择排序，每轮排序选出最大的

时间复杂度

- 最好时间复杂度：O(n2)
- 平均时间复杂度：O(n2)
- 最坏时间复杂度：O(n2)

空间复杂度：O(1)

稳定性：不稳定，因为数据会存在位置变更

### 插入排序

插入排序是首先将数组中的第一个元素看作是一个有序列表，然后将后面的数据依次插入到有序列表中。

时间复杂度

- 最好时间复杂度：O(n)
- 平均时间复杂度:   O(n2)
- 最坏时间复杂度:  O(n2)

空间复杂度：O(1)

稳定性：稳定的

### 希尔排序

希尔排序是基于增量来进行分组，然后每个分组的数据使用插入排序，直到增量等于1，完成排序结果。可以看作是一种更高效的直接插入排序算法

时间复杂度

- 最好时间复杂度：O(n)
- 平均时间复杂度：O(nlogn)  比如100 那么初始增量为50，那么可能需要6次对n的直接插入，所以平均时间复杂度O(nlogn)
- 最坏时间复杂度： O(n2)

空间复杂度：O(1)

稳定性：非稳定的，因为会基于分组插入，那么可能会导致a = b,a本应该在b的前面，但是由于被分到其他组，导致b在a的前面

```java
  /**
     * 希尔排序也可以看作是一种更高效的直接插入排序
     * 相当于将序列分组，然后对每组进行直接插入算法
     * 基于增量 ，增量对选取一般是 gap = data.length / 2 = 5
     * 然后循环递归除以2
     * 8 9 7 1 2  3 5 4 6 0
     * 我们希望从小到大排序
     *
     * 8 9 7 6 2 3 5 4 1 0
     *           3
     * @param data
     */
    public static void shellSort(int[] data){
        // 8 9 1
        //  5 5 2
        for (int gap = data.length / 2; gap > 0  ; gap  /= 2) { //第一层根据增量 依次是 5 2 1

            for (int i = gap; i < data.length; i ++) { //第二层循环是 根据 5的增量排序，根据2的增量排序 根据1的增量排序
                int temp = data[i];
                int j = i;
                for (; j >= gap && temp > data[j - gap] ; j -= gap) { // 第三层循环是根据增量直接插入
                    data[j] = data[j - gap];
                }
                data[j] = temp;
            }
        }
        System.out.println(Arrays.toString(data));

    }
```

### 堆排序



### 快速排序

由于快排找基准值的特性，所以该算法是不稳定的。

空间复杂度 O(logn)

什么时候是最坏时间复杂度？

比如说是想对一个数组进行升序排列，但是该数组本身就是有序的，因此最坏时间复杂度为O(n2)，因为每次递归都要进行O(n)次判断，因为有序，那么需要n次递归，所以需要O(n2)

时间复杂度

- 最好时间复杂度：O(nlogn)
- 平均时间复杂度：O(nlogn)
- 最坏时间复杂度：O(n2)

```java
   /**
     * 快速排序
     * 比较基准值的过程
     * 一般基准值可以选取arr[0],arr[length -1]
     * 比基准值大的放左边，小的放右边。
     */
    public static void quickSort(int[] arr,int low,int high){
        if (low < high){
            int index = getIndex(arr, low, high);
            //递归左边
            quickSort(arr,low,index - 1);
            //递归右边
            quickSort(arr,index + 1,high);
        }
    }
    public static int getIndex(int[] arr,int low,int high){
        boolean left = true,right = true;
        int temp = arr[low];
        while (low < high){
            if (left){
                if (temp > arr[high]){
                    arr[low] = arr[high];
                    low++;
                    right = true;
                }else {
                    right = false;
                    high--;
                }
            }
            if (right){
                if (temp < arr[low]){
                    arr[high] = arr[low];
                    high--;
                    left = true;
                }else {
                    low++;
                    left = false;
                }
            }
        }
        arr[low] = temp;
        return low;
    }
```



### 归并排序

稳定的

空间复杂度 O(nlogn)

时间复杂度

- 最好时间复杂度：O(nlogn)
- 平均时间复杂度：O(nlogn)
- 最坏时间复杂度：O(nlogn)

```java
  /**
     * 归并排序
     * 分而治之
     * @param arr
     *
     */
    public static void mergeSort(int[] arr,int left,int right,int[] temp){
        if (left < right){
            int mid = (left + right) / 2;
            mergeSort(arr,left,mid,temp);
            mergeSort(arr,mid + 1,right,temp);
            merge(arr,left,mid,right,temp);
        }

    }

    private static void merge(int[] arr, int left, int mid, int right, int[] temp) {
        int idx = 0;
        int lIdx = left, rIdx = mid + 1;

        while (lIdx <= mid || rIdx <= right ) {
            if (lIdx > mid) {
                break;
            }
            if (rIdx > right) {
                break;
            }
            if (arr[lIdx] < arr[rIdx]) {
                temp[idx++] = arr[lIdx];
                lIdx++;
            } else {
                temp[idx++] = arr[rIdx];
                rIdx++;
            }
        }

        //ldx = 3,riIdx = 5
        //mid =3
        while (lIdx <= mid) {
            temp[idx++] = arr[lIdx++];
        }
        while (rIdx <= right) {
            temp[idx++] = arr[rIdx++];
        }
        int index = 0;
        for (int i = left; i <= right; i++) {
            arr[i] = temp[index++];
        }
    }
```



## 非比较类排序

### 桶排序

**桶排序的时间复杂度 O(n)  内部使用快排最坏情况下 O(nlog(n))**

**桶排序的空间复杂度 O(n+k) k是指桶的数量**

**稳定性：主要是看每个桶内的排序算法是否稳定，如果内部排序算法是稳定的，那么桶排序也是稳定的，如果使用快速排序这种不稳定的算法，那么桶排序也就是不稳定的。**

可以使用小数，如果存在负数的话需要分两组来处理，一组处理正数，一组处理负数，也可以先给整体加一个足够大的数，覆盖输出数组的时候再减去一个足够大的数。

假设每个桶内使用快速排序

假设 n 个数据被放入在 m 个不同的桶中，那么每个桶中的使用快速排序的时间复杂度是 k = n / m;   O(klogk) = O(n/mlog(n/m)); 

那么m个桶， **O(m * n /m log (n/m)) = O(blog(n/m)); 所以当桶的个数m跟元素个数n十分接近，桶排序的时间复杂度可以看作是O(n)**;

那么最坏情况下，所有的元素都被放入一个桶中呢？那么这种情况下时间复杂度就退化为 O(nlog(n))

桶排序思路是先创建适合的桶的大小

然后依次以一种函数放入某个桶中，然后排序

取出桶中的数据放入到输出数组中

使用范围，适合**数据分布比较均匀**的场景，否则就退化为O(nlog(n)),并且空间复杂度也大

```java
 /**
     *  int[] arr = new int[]{49,38,65,97,76,13,27,46,35,6,100,11,2,4,5,4};
     *  计数排序在该数组需要创建 100 - 2 + 1  个桶
     *  而桶排序只需要创建11个桶，所以说两个是有区别的，桶排序本质上是创建一个区间，然后每个桶内的数据再进行排序，
     *  而计数排序则桶内不需要排序，而是计算数据
     *  计数排序本质上是一种特殊的桶排序，当桶的个数足够大的时候，就是计数排序
     * @param arr
     * @param buckets
     */
    public static void bucketSorts(int[] arr,int buckets){
        List<List<Integer>> scoreList = new ArrayList<>(buckets);
        for (int i = 0; i < buckets ; i++) {
             scoreList.add(new ArrayList<>());
        }
        for (int i = 0; i < arr.length ; i++) {
            int bucket = arr[i] / buckets;
            scoreList.get(bucket).add(arr[i]);
        }
        scoreList.forEach(e -> {
            Collections.sort(e);
        });
        System.out.println(scoreList);
    }
```

```java
//假设有500万个考生 分数在100 - 900 之间不等，然后的话呢 请你排个序
    public static void scoreSort(int[] data){
        List<List<Integer>> scoreList = new ArrayList<>();
        for (int i = 0; i < 801 ; i++) {
            scoreList.add(new ArrayList<>());
        }
        for (int i = 0; i < data.length ; i++) {
            List<Integer> score = scoreList.get(data[i] - 100);
            score.add(data[i]);
        }
        int index = 0;
        for (int i = 0; i < scoreList.size() ; i++) {
            for (int j = 0; j < scoreList.get(i).size() ; j++) {
                 data[index++] = scoreList.get(i).get(j);
            }
        }
        System.out.println(Arrays.toString(data));
    }
```



### 计数排序

计数排序的空间复杂度 O(max - min)

计数排序的时间复杂度 O(n + max - min) 1是常数可以忽略

**适用于较离散的非*负整数*序列**

```java
 public static void countSort(int[] arr){
        int max = arr[0];
        int min = arr[0];
        for (int i = 0; i < arr.length ; i++) {
            max = Math.max(max,arr[i]);
            min = Math.min(min,arr[i]);
        }
        //100 - 2 + 1 = 99
        int[] countArr = new int[max - min + 1];
        //
        for (int i = 0; i < arr.length ; i++) {
            countArr[arr[i] - min]++;
        }
        System.out.println(Arrays.toString(countArr));
        int count = 0;
        for (int i = 0; i < countArr.length ; i++) {
             while (countArr[i] > 0){
                 arr[count++] = i + min ;
                 countArr[i]--;
             }
        }

        System.out.println(Arrays.toString(arr));

    }
```

### 基数排序

时间复杂度：O(dn) d为最大数字的长度 每一次桶的分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度

空间复杂度：O(n + k) k为桶的个数，一般为十

稳定性：不稳定

数据选择：只能是非负整数

```java
 /**
     * 基数排序的思想是
     * 先统计最大数字的长度，然后比如三位，那么就要进行 个位 十位 百位的依次排序
     * @param arr
     */
    public static void radixSort(int[] arr){
        int max = arr[0];
        for (int i = 1; i < arr.length ; i++) {
             max = Math.max(max,arr[i]);
        }
        int count = 0;
        while (max != 0){
            max /= 10;
            count++;
        }
        List<List<Integer>> buckets = new ArrayList<>(10);
        for (int i = 0; i < 10; i++) {
             buckets.add(new ArrayList<>());
        }
        int multiple = 1,model;
        int remainder = 10;
        for (int i = 0; i < count; i++) {
            for (int j = 0; j < arr.length ; j++) {
                  int divide = arr[j] / multiple;
                   model = divide % remainder;
                  buckets.get(model).add(arr[j]);
            }
            int index = 0;
            for (List<Integer> bucket : buckets) {
                for (Integer data : bucket) {
                     arr[index++] = data;
                }
            }
            for (int j = 0; j < buckets.size() ; j++) {
                 buckets.get(j).clear();
            }
            multiple *= 10;
        }
        System.out.println(Arrays.toString(arr));
    }
```

# 常见面试题

## 计算在str字符串中，两个相邻TAG之间间距最大的间距字符数

```java
    public static int calDistance(String str,char tag){
        if (Objects.isNull(str) || str.length() == 0){
            return -1;
        }
        HashSet<Character> characters = new HashSet<>();
        int stIdx = 0,endIdx = 0,step = -1;
        for (int i = 0; i < str.length(); i++) {
             if (str.charAt(i) == tag){
                 if (!characters.add(str.charAt(i))){
                    endIdx = i;
                    step = Math.max(step,endIdx - stIdx - 1);
                    characters.remove(str.charAt(i));
                 }
                 stIdx = i;
             }
        }
        return step;
    }
```

## 最优路径

```java

    private static final int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    private static boolean[][] memo;
    private static List<List<Point>> res;
    private static List<Point> tmp;
    private static int m, n;


    /**
     * 0.0 0,1 0,2
     * 1,0,1,1 1,2
     * 2,0,2,1 2,2
     */
    static byte[][] map =
            {{11, 12, 15, 18, 20},
             {16, 20, 20, 20, 21},
             {15, 20, 29, 20, 23},
             {14, 20, 20, 20, 24},
             {13, 20, 25, 20, 29}};
    public static void main(String[] args) {
        byte stepDrop= 11 ;
        Point start=new Point(0,0);
        Point end=new Point(2,2);
        List<List<Point>> paths = findPath(map, start, end, stepDrop);
        //上图示例的例子最优路径高度总值应该为87，单一最优
        for (List<Point> path : paths) {
            System.out.println(path);
        }
    }
    /**
     * 查找最优路径
     *
     * @param map      地形数据
     * @param start    起始点
     * @param end      结束点
     * @param stepDrop 单步落差
     * @return
     */

    public static List<List<Point>> findPath(byte[][] map, Point start, Point end, byte stepDrop) {
        m = map.length;
        n = map[0].length;
        memo = new boolean[m][n];
        res = new LinkedList<>();
        tmp = new LinkedList<>();

        dfs(map,start, end, 0,stepDrop);

        HashMap<Integer, Integer> hashMap = new HashMap<>();
        int idx = 0;
        for (List<Point> re : res) {
            int path = 0;
            for (Point point : re) {
                byte b = map[point.x][point.y];
                path += b;
            }
            hashMap.put(idx++,path);
        }
       int min = Integer.MAX_VALUE;
        for (int value : hashMap.values()) {
             min = Math.min(min,value);
        }
       int fMin = min;
        List<List<Point>> realRes = new LinkedList<>();
        hashMap.forEach((k,v) -> {
            if (v == fMin){
                realRes.add(res.get(k));
            }
        });
        return realRes;
    }

    private static void dfs(byte[][] map,Point cur, Point end, int idx,int stepDrop) {
        if (cur.x > end.x || cur.y > end.y) return;
        int x = cur.x, y = cur.y;
        if (x == end.x && y == end.y) {
            tmp.add(end);
            res.add(new ArrayList<>(tmp));
            tmp.remove(tmp.size() - 1);
            return;
        }

        if (x < 0 || y < 0 || x >= m || y >= n || memo[x][y]) return;

        memo[x][y] = true;
        tmp.add(cur);

        for (int[] dir : dirs) {
            int x1 = x + dir[0], y1 = y + dir[1];
            /**
             * if (x1 >= 0 && x1 < map.length && y1 >= 0 && y1< map[0].length && (map[x1][y1] - map[x][y] <= stepDrop)){
               我理解的单步落差是指map[x][y] - map[x-1][y-1]的高度差不大于stepDrop 但是在示例中map里面的值单步落差至少也要大于等于9 所以我觉得我可能理解错了 去掉上面的注释可以实现
               我所理解的单步落差
             */
                dfs(map,new Point(x1, y1), end, idx + 1,stepDrop);
            //}
        }

        // backtrace
        tmp.remove(idx);
        memo[x][y] = false;
    }


    static class Point{
        int x;
        int y;
        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
        @Override
        public String toString() {
            return "(" + x +"," + y+")";
        }
    }
```

## 递归求和求最大值求列表个数

```java
  public static void main(String[] args) {
        LinkedList<Integer> sortList = new LinkedList<>();
        sortList.add(2);
        sortList.add(4);
        sortList.add(6);
        int fact = max(sortList);
        System.out.println(fact);
    }
    public static int fact(LinkedList<Integer> fact){
        if (fact.size() == 1){
            return fact.remove();
        }
        return fact.remove() + fact(fact);
    }

    public static int sum(LinkedList<Integer> fact){
        if (fact.size() == 1){
            return 1;
        }
        fact.remove();
        return 1 + sum(fact);
    }
    public static int max(LinkedList<Integer> fact){
        if (fact.isEmpty()){
            return Integer.MIN_VALUE;
        }
        return Math.max(fact.remove(),max(fact));
    }
```

## 递归版二分查找

```java
    public static int binarySearch(int[] arr,int left,int right,int find){
        int mid = (left + right) / 2;
         if (left > right){
             return -1;
         }else if (arr[mid] == find){
             return mid;
         }
         else{
             if (arr[mid] > find){
                return binarySearch(arr,left,mid - 1,find);
             }
             if (arr[mid] < find){
                 return binarySearch(arr,mid + 1,right,find);
             }
        }
         return -1;
    }
```



## LRU算法

```java
import java.util.HashMap;
import java.util.LinkedList;

public class LRUCache {
    private LinkedList<Node> linkedList = new LinkedList();
    private HashMap<Integer,Node> map = new HashMap<>();
    public int getVal(int k){
        if (!map.containsKey(k)){
            return -1;
        }
        Node result = map.get(k);
        Node node = new Node(k, result.val);
        linkedList.remove(node);
        linkedList.addFirst(node);
        return result.val;
    }
    public void put(int k,int v){
        Node node = new Node(k, v);
        if (map.containsKey(k)){
            linkedList.remove(node);
            linkedList.addFirst(node);
            map.put(k,node);
        }else {
           map.put(k,node);
           linkedList.addFirst(node);
        }
    }

    public void show() {
        for (Node node : linkedList) {
            System.out.println(node);
        }
    }


    static class Node{
        private int key;
        private int val;
        private Node next;
        private Node pre;

        public Node(int key,int val){
            this.key = key;
            this.val = val;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "key=" + key +
                    ", val=" + val +
                    '}';
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Node node = (Node) o;

            if (key != node.key) return false;
            if (val != node.val) return false;
           return true;
        }

        @Override
        public int hashCode() {
            int result = key;
            result = 31 * result + val;
            result = 31 * result + (next != null ? next.hashCode() : 0);
            result = 31 * result + (pre != null ? pre.hashCode() : 0);
            return result;
        }
    }
}

```

## 斐波那契数列高效版

```java
import java.text.SimpleDateFormat;
import java.util.Date;

public class FIbClass {
    static int count = 0;
    public static void main(String[] args) {
        int size = 100;
        int[] arr = new int[size + 1];
        long preTime = System.currentTimeMillis();
        int fib = fib(size,arr);
        long lastTime = System.currentTimeMillis();
        System.out.println((lastTime - preTime) );
        System.out.println(fib);
    }
    public static int fib(int n){
        if (n == 1 || n == 2){
            return 1;
        }
        return fib(n - 1) + fib(n - 2);
    }
    //求斐波那契数列
    public static int fib(int n,int[] arr){
        if (n == 1 || n == 2){
            return 1;
        }
        if (arr[n] != 0) {
            return arr[n];
        }
        int sum = fib(n - 1,arr) + fib(n - 2,arr);
        arr[n] = sum;
        return sum;

    }
}

```

## 最大堆实现优先队列

```java
import java.util.Arrays;

/**
 * 优先级队列
 * 可以选择最小堆实现，也可以选择最大堆实现
 * 大小堆其实就是一个数组版本的完全二叉树
 * 如果选择最小堆实现优先级队列，那么优先级队列第一个数据就是所有数据最小值
 * 如果选择最大堆实现优先级队列，那么优先级队列第一个数据就是所有数据最大值
 * 进行上浮动下浮动
 * 我们来使用最大堆来构建优先级队列
 *
 */
public class PriorityQueue <Key extends Comparable<Key>>{
    //存放了所有要比较的数据
    private Key[] keys;
    //当前队列的数量
    public int size = 1;

    public PriorityQueue(int capacity){
        keys = (Key[]) new Comparable[capacity + 1];
    }
    /**
     * 获取到队列最大值
     */
    public Key getMax(){
        return keys[1];
    }
    /**
     * 插入元素
     */
    public void insert(Key e){
        keys[size] = e;
        swim(size);
        if (++size == keys.length){
            Key[] temp = keys;
            keys = (Key[]) new Comparable[keys.length >> 1];
            for (int i = 0; i < temp.length ; i++) {
                keys[i] = temp[i];
            }
        }
    }
    /**
     * 删除最大元素并且返回
     */
    public Key delMax(){
        if (size == 0) return null;
        Key newRoot = keys[size - 1];
        keys[size - 1] = null;
        size--;
        Key max = getMax();
        keys[1] = newRoot;
        sink(1);
        return max;
    }
    /**
     * 上浮第k个元素，以维护最大堆的性质
     */
    public void swim(int k){
        while (parent(k) > 0 && less(parent(k),k)){
            swap(parent(k),k);
            k = parent(k);
        }
    }

    /**
     * 下浮第k个元素，以维护最大堆的性质
     * @param k
     */
    public void sink(int k){
        while (left(k) < size || right(k) < size){
            int index = -1;
            if (less(k,left(k))){
                index = left(k);
            }
            if (right(k) < size && less(k,right(k)) && less(left(k),right(k))) {
                index = right(k);
            }
            if (index == -1){
                break;
            }
            swap(k,index);
            k = index;
        }
    }
    private void swap(int i,int j){
        Key temp = keys[i];
        keys[i] = keys[j];
        keys[j] = temp;
    }

    /**
     * @param i
     * @param j
     * @return 判断key[i] 是否小于 key[j]
     */
    private boolean less(int i,int j){
       return keys[i].compareTo(keys[j]) < 0;
    }

    public int left(int root){
       return root * 2;
    }
    public int right(int root){
        return root * 2 + 1;
    }
    public int parent(int root){
        return root / 2;
    }

    public void show() {
        System.out.println(Arrays.toString(keys));
    }
}

```

## 二叉树所有节点值加1

```java
package tree;

public class BinaryTree {


    public void plusOne(TreeNode root){
        if (root == null) return ;
        root.val += 1;
        plusOne(root.left);
        plusOne(root.right);
    }

    static class TreeNode{
        public int val;
        private TreeNode left;
        private TreeNode right;
    }
}

```

## 判断两颗二叉树完全相同

```java
  public boolean isSameTree(TreeNode root1,TreeNode root2){
         if (root1 == null && root2 == null) return true;
         if (root1 == null && root2 != null) return false;
         if (root1 != null && root2 == null) return false;
         if (root1.val != root2.val) return false;
        return isSameTree(root1.left,root2.left)
                && isSameTree(root1.right,root2.right);
    }

    static class TreeNode{
        public int val;
        private TreeNode left;
        private TreeNode right;
    }
```

## 判断是否二叉搜索树

二叉搜索树定义：一个二叉树中，任意节点的值大于等于它的左子节点的值，小于等于它的右子节点的值

```java
```



## 二叉树检查一个数是否存在

```java
 /**
     * 检查一个数是否存在
     */
    public boolean isInBst(TreeNode root,int target){
        if (root == null) return false;
        if (root.val == target) return true;
      return isInBst(root.left,target) || isInBst(root.right,target);
    }

    static class TreeNode{
        public int val;
        private TreeNode left;
        private TreeNode right;
    }
```

## 利用BST特性判断一个数是否存在高效版

```java
    public boolean isInBstHigh(TreeNode root,int target){
        if (root == null) return false;
        if (root.val == target) return true;
        if (root.val < target){
           return isInBst(root.right,target);
        }
        if (root.val > target){
            return isInBst(root.left,target);
        }
        return false;
    }
```



## zk实现读写锁

```java
package distributed;

import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.framework.recipes.cache.NodeCache;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.client.ZKClientConfig;
import org.apache.zookeeper.data.Stat;
import sun.jvm.hotspot.debugger.win32.coff.COFFLineNumber;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;

public class ZkReadWriteLock {
    private CuratorFramework client;
    private String lockName;
    private String readLock;
    private String writeLock;
    private static final String read = "Read";
    private static final String write = "Write";
    private static final String localhost = "127.0.0.1";
    private String ourLockPath;
    public ZkReadWriteLock(){
        readLock = read;
        writeLock = write;
    }

    public void connect(String url,String lockName) throws Exception {
        ExponentialBackoffRetry retry = new ExponentialBackoffRetry(1000,3);
        this.lockName = lockName;
        client = CuratorFrameworkFactory.builder()
                .connectString(url)
                .connectionTimeoutMs(6000)
                .retryPolicy(retry)
                .sessionTimeoutMs(5000)
                .build();
        client.start();
        Stat stat = client.checkExists().forPath(lockName);
        if (Objects.isNull(stat)){
            client.create().creatingParentsIfNeeded()
                    .withMode(CreateMode.PERSISTENT)
                    .forPath(lockName);
        }
    }
    public List<String> getChild() throws Exception {
        return client.getChildren().forPath(lockName);
    }

    /**
     * 想想思路
     * 先自己写吧
     * 用户在执行业务逻辑的时候，直接调用该方法进行获取读锁，如果失败，则等待，进行watcher监听
     * 真正的判断逻辑 是每次获取锁的时候，创建一个临时顺序节点，并且具有读锁的标识，同时去判断子节点列表是否为空，如果是空
     * 那么代表可以直接获取锁，如果不为空，则向比它id小的写锁注册一个watcher监听，然后等待子节点列表触发监听
     * 设置锁名字的规则 ip_read_
     */
    public boolean acquireReadLock() throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        List<String> lockList = getChild();
        if (lockList.isEmpty()){
             client.create().creatingParentsIfNeeded()
                     .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)
                     .forPath(lockName + "/"+localhost+"_"+readLock);
             return true;
        }
        String path = client.create().creatingParentsIfNeeded()
                .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)
                .forPath(lockName + "/" + localhost + "_" + readLock);
        setOurLockPath(path);
        List<String> child = getChild();
        for (String lock : child) {
            int readIndex = lock.indexOf("_");
            String readLock = lock.substring(readIndex + 1,readIndex + 1 + 4);
            if ((lockName+"/"+lock).equals(path)){
                break;
            }
            if (read.equals(readLock)){
                continue;
            }
            client.getChildren().usingWatcher((CuratorWatcher) watchedEvent ->
                    countDownLatch.countDown()).forPath(lockName + "/"+lock);
            countDownLatch.await();
               return false;
        }
        return true;
        //代表需要进行判断比自己小的节点是否有写节点
    }

    public String getOurLockPath() {
        return ourLockPath;
    }

    public void setOurLockPath(String ourLockPath) {
        this.ourLockPath = ourLockPath;
    }

    /**
     * 获取写锁
     * 读
     * 读
     * 写
     * 读
     * @throws Exception
     */
    public boolean acquireWriteLock() throws Exception {
        CountDownLatch downLatch = new CountDownLatch(1);
        List<String> lockList = getChild();
        if (lockList.isEmpty()){
            String path = client.create().creatingParentsIfNeeded()
                    .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)
                    .forPath(lockName + "/" + localhost + "_" + writeLock);
            setOurLockPath(path);
            return true;
        }
        String path = client.create().creatingParentsIfNeeded()
                .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)
                .forPath(lockName + "/" + localhost + "_" + writeLock);
        int writeIndex = path.indexOf("_");
        setOurLockPath(path);
        String subLock = path.substring(writeIndex + 6);
        Integer writeLock = Integer.valueOf(subLock);
        int watchLock = writeLock - 1;
        String preLock = String.valueOf(watchLock);
        while (preLock.length() < subLock.length()){
            StringBuilder builder = new StringBuilder(preLock);
            builder.reverse();
           int length = subLock.length() - preLock.length();
            for (int i = 0; i < length ; i++) {
                builder.append("0");
            }
            builder.reverse();
            preLock = builder.toString();
        }
        String wr = lockName + "/" + localhost + "_" + write + preLock;
        String ra = lockName + "/" + localhost + "_" + readLock + preLock;
        Stat stat = client.checkExists().forPath(wr);
        Stat stat1 = client.checkExists().forPath(ra);
        if (Objects.isNull(stat) && Objects.isNull(stat1)){
            return true;
        }
        if (Objects.isNull(stat) && !Objects.isNull(stat1)){
            client.getChildren().usingWatcher((CuratorWatcher) watchedEvent ->
                    downLatch.countDown()).forPath(ra);
            downLatch.await();
            return true;
        }
        if (Objects.nonNull(stat) && Objects.isNull(stat1)){
            client.getChildren().usingWatcher((CuratorWatcher) watchedEvent ->
                    downLatch.countDown()).forPath(wr);
            downLatch.await();
            return true;
        }
        return false;
    }

    public void unlockWriteLock() throws Exception {
        client.delete().forPath(ourLockPath);
    }

    public void unlockReadLock() throws Exception {
        client.delete().forPath(ourLockPath);
    }
}
```

```java
package distributed;

public class ReadLockZkTest {
    public static void main(String[] args) throws Exception {

        Thread thread = new Thread(() -> {
            ZkReadWriteLock lock = new ZkReadWriteLock();
            try {
                lock.connect("127.0.0.1:2181","/Lock");
            } catch (Exception e) {
                e.printStackTrace();
            }
            try {
                lock.acquireWriteLock();
            } catch (Exception e) {
                e.printStackTrace();
            }
            try {
                System.out.println("获取写锁成功");
            }catch (Exception e){

            }finally {
                try {
                    Thread.sleep(10000);
                    lock.unlockWriteLock();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            System.out.println("释放写锁成功");
        });
        thread.start();

        Thread.sleep(2000);
        for (int i = 0; i < 2 ; i++) {
            Thread thread2 = new Thread(() -> {
                ZkReadWriteLock lock = new ZkReadWriteLock();
                try {
                    lock.connect("127.0.0.1:2181","/Lock");
                } catch (Exception e) {
                    e.printStackTrace();
                }
                try {
                    System.out.println("准备尝试获取读锁");
                    lock.acquireReadLock();
                    System.out.println("获取读锁成功. 执行业务逻辑");
                    Thread.sleep(10000);
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    try {
                        lock.unlockReadLock();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("释放读锁成功");
            });
            thread2.start();
        }

        Thread thread3 = new Thread(() -> {
            ZkReadWriteLock lock = new ZkReadWriteLock();
            try {
                lock.connect("127.0.0.1:2181","/Lock");
            } catch (Exception e) {
                e.printStackTrace();
            }
            try {
                Thread.sleep(2000);
                lock.acquireWriteLock();
            } catch (Exception e) {
                e.printStackTrace();
            }
            try {
                System.out.println("获取写锁成功");
            }catch (Exception e){

            }finally {
                try {
                    lock.unlockWriteLock();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            System.out.println("释放写锁成功");
        });
        thread3.start();

    }
}
```

## 判断是否是BST(二叉搜索树)

```java
  public boolean isValidBst(TreeNode root){
       return isBinarySearchTree(root,null,null);

    }

    /**
     * 是否是二叉搜索树
     * @param root
     * @param min
     * @param max
     * @return
     *  向右边的话
     *  root.right root,max
     *       10
     *     7     16
     *   5   9
     *      8  10
     *
     * 7向左，带的最大值是7，走到底发现只有5，返回true满足条件 然后回溯
     * 此时再保持这现在的状态向右
     * 7向右的话是9，应该min是7，max是10
     * 并且如果你向左边走的话，你的最大值其实不会用到，只需要判断是否小于最小值
     * 但是如果你是向左边走然后又要向右走，那么你就需要带这最大值10，不可以比它大 否则也return false
     *
     *
     *  root.left(7),null,max(10)
     *  root.right,min(7),max(10);
     *  root.left,min,max(9)
     *  root.right,min,max(10);

     *
     */
    public boolean isBinarySearchTree(TreeNode root, TreeNode min,TreeNode max){
         if (root == null) return true;
         if (min != null && root.val < min.val) return false;
         if (max != null && root.val > max.val) return false;
         return isBinarySearchTree(root.left,min,root) &&
                 isBinarySearchTree(root.right,root,max);
    }

```

## BST删除节点

```java
  /**
     * 三种可能性
     * 第一种：该节点无左右子节点
     * 第二种：只有一个左节点或者只有一个右节点，直接覆盖
     * 第三种：左右子节点都有，找左边最大的节点或者右边最小的节点进行替换
     *
     * @param root
     * @param val
     * @param parent
     * @return
     */
    public TreeNode delNode(TreeNode root,int val,TreeNode parent){
         if (root == null) return null;
         if (root.val == val && root.left == null && root.right == null){
             if (parent != null){
                 if (root.val < parent.val){
                     parent.left = null;
                 }else {
                     parent.right = null;
                 }
             }else {

                 //代表是根节点
                 root = null;
             }
             return root;
         }else if (root.val == val && (root.left == null || root.right == null)){
             if (parent != null){
                 if (root.left == null){
                     parent.right = root.right;
                 }else {
                     parent.left = root.left;
                 }
             }else {
                 //代表是根节点
                 if (root.left == null){
                     root = root.right;
                 }else {
                     root = root.left;
                 }
             }
             return root;
         }else if (root.val == val && root.left != null && root.right != null){
              //此处需要进行寻找左边最大的数，或者右边最小的数，找右边吧
             TreeNode minNode = findMinNode(root.right);
                 //代表是根节点
                 if (minNode.left == null){
                     swap(root,minNode);
                     root.right = null;
                 }else if (minNode.left.left == null){
                    swap(root,minNode.left);
                     minNode.left = null;
                 }
              return minNode;
         }
         if (val >= root.val)
        return delNode(root.right,val,root);
         else {
             return delNode(root.left,val,root);
         }
    }
    public void swap(TreeNode minNode, TreeNode root){
        int temp = minNode.val;
        minNode.val = root.val;
        root.val = temp;
    }


    private TreeNode findMinNode(TreeNode root) {
        if (root == null) return null;
        if (root.left == null) return root;
        if (root.left.left == null) return root;
        return findMinNode(root.left);
    }
```

## 计算完全二叉树的节点数

完全二叉树：Complete Binary Tree

满二叉树：Perfect Binary Tree(英文理解完美二叉树)

英文中的Full Binary Tree是指一棵二叉树的所有节点要么没有孩子节点，要么有左右节点

## 求满二叉的节点树

复杂度Olog(n)

```java
   /**
     * 如何求树的高度？
     * 如果是一棵满二叉树 那么树的节点和树的高度就有密切关系
     */
    public int treeHigh(TreeNode root){
        if (root == null) return 0;
        int high = 0;
        while (root != null){
            root = root.left;
            high++;
        }
        return (int) (Math.pow(2,high) - 1);
    }
```

## 寻找当前节点的后继节点

```java
package tree;

public class FindSuccessorNode {
    public static void main(String[] args) {

    }

    /**
     * @param node 寻找该节点的后继节点
     * @return
     */
    public static Node findSuccessorNode(Node node) {
        if (node == null) {
            return null;
        }
            if (node.right != null) {
                return getLeftNodes(node.right);
            }
            Node cur = node;
            Node parent = node.parent;
            while (parent != null && parent.left != cur) {
                cur = parent;
                parent = cur.parent;
            }
            return parent;

    }

    public static Node getLeftNodes(Node x) {
        Node cur = x;
        while (cur.left != null) {
            cur = cur.left;
        }
        return cur;
    }

    static class Node {
        int val;
        Node left;
        Node right;
        Node parent;

        public Node(int val) {
            this.val = val;
        }

    }
}


```

## 谷歌凹凸折痕问题

```java
package tree;



public class GoogleAlgorithm {
    public static void main(String[] args) {
      kinkMark(3);
    }

    /**
     * 凹凸折痕问题 给你一张纸，进行折叠  然后输入一个参数n，问你n的输入产生了多少个凹凸折痕 进行打印
     *
     */
    public static void kinkMark(int n){
        processor(n,1,true);
    }

    public static void processor(int n,int cur,boolean down){
        if (cur > n){
            return;
        }
        processor(n,cur+1,true);
        System.out.println(down ? cur + "凹" : cur + "凸");
        processor(n,cur+1,false);
    }

}

```

## 寻找两个节点中的最低公共祖先

```java

package tree;

public class HighLowestCommonAncestor {
    public static void main(String[] args) {
        Node node1 = new Node(10);
        Node node2 = new Node(7);
        Node node3 = new Node(8);
        Node node4 = new Node(11);
        Node node5 = new Node(13);
        Node node6 = new Node(19);
        node1.left = node2;
        node1.right = node3;
        node2.left = node4;
        node2.right = node5;
        node3.left = node6;

        Node lca = flc(node1, node4, node6);
        System.out.println(lca.val);

    }
    public static Node flc(Node root,Node o1,Node o2){
        if (root == null || root == o1 || root == o2){
            return root;
        }
        Node left = flc(root.left, o1, o2);
        Node right = flc(root.right, o1, o2);

        if (left != null && right != null){
            return root;
        }
        return left != null ? left : right;
    }
}

```

```java
package tree;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;

/**
 * 最低公共祖先
 */
public class LowestCommonAncestor {
    public static void main(String[] args) {
        Node node1 = new Node(10);
        Node node2 = new Node(7);
        Node node3 = new Node(8);
        Node node4 = new Node(11);
        Node node5 = new Node(13);
        Node node6 = new Node(19);
        node1.left = node2;
        node1.right = node3;
        node2.left = node4;
        node2.right = node5;
        node3.left = node6;

        Node lca = lca(node1, node4, node2);
        System.out.println(lca.val);

    }

    /**
     *
     * @param root 树的根节点
     * @param o1
     * @param o2
     * @return 返回最低的公共祖先
     */
    public static Node lca(Node root,Node o1,Node o2){
        Map<Node,Node> parentMap = new HashMap<>();
        parentMap.put(root,null);
        process(root,parentMap);
        LinkedList<Node> nodes = new LinkedList<>();
        nodes.add(o1);
        Node parent = parentMap.get(o1);
        while (parent != null){
            nodes.add(parent);
            parent = parentMap.get(parent);
        }


        Node p = parentMap.get(o2);
        for (Node node : nodes) {
            if (node == o2){
                return node;
            }
            while (p != null){
                if (node == p){
                    return node;
                }
                p = parentMap.get(p);
            }
            p = parentMap.get(o2);
        }
        return null;
    }
    public static void process(Node root,Map<Node,Node> parentMap){
        if (root == null){
            return;
        }
        if (root.left != null){
            parentMap.put(root.left,root);
        }
        if (root.right != null){
            parentMap.put(root.right,root);
        }
        process(root.left,parentMap);
        process(root.right,parentMap);
    }
}

```

## 树的非递归遍历与计算树最大层数的节点数量

```java
package tree;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Stack;

public class NoRecursionShow {
    public static void main(String[] args) {
      Node<Integer> root = new Node(1);
      Node<Integer> node1 = new Node(2);
      Node<Integer> node2 = new Node(3);
      Node<Integer> node3 = new Node(4);
      Node<Integer> node4 = new Node(5);
      Node<Integer> node5 = new Node(6);
      Node<Integer> node6 = new Node(7);
      Node<Integer> node7 = new Node(8);
      Node<Integer> node8 = new Node(9);
      root.left = node1;
      root.right = node2;
      node1.left = node3;
      node1.right = node4;
      node2.left = node5;
      node2.right = node6;
      node4.right = node7;
      node5.left = node8;
        int i = noHashMaxLevelNums(root);
        System.out.println(i);

    }
    public static int noHashMaxLevelNums(Node root){
        if (root == null){
            return 0;
        }
        LinkedList<Node> queue = new LinkedList<>();
        queue.add(root);
        int max = Integer.MIN_VALUE;
        int curLevelNodes = 0;
        Node curEnd = root;
        Node nextEnd = null;
        while (!queue.isEmpty()){
            Node node = queue.pop();
            if (node.left != null){
                queue.add(node.left);
                nextEnd = node.left;
            }
            if (node.right != null){
                queue.add(node.right);
                nextEnd = node.right;
            }
            curLevelNodes++;
            if (node == curEnd){
                max = Math.max(max,curLevelNodes);
                curEnd = nextEnd;
                curLevelNodes = 0;
            }

        }
        return max;
    }
    public static int HashTableLevelPrint(Node root){
        if (root == null){
            return 0;
        }
        HashMap<Node,Integer> map = new HashMap<>();
        LinkedList<Node> queue = new LinkedList<>();
        queue.add(root);
        map.put(root,1); //代表在第一层
        int max = Integer.MIN_VALUE;
        int curLevelNodes = 0;
        int curLevel = 1;
        while (!queue.isEmpty()){
            Node pop = queue.pop();
            int level = map.get(pop);
            if (curLevel == level){
                curLevelNodes++;
            }else {
                curLevel = level;
                max = Math.max(max,curLevelNodes);
                curLevelNodes = 1;
            }
            if (pop.left != null){
                queue.add(pop.left);
                map.put(pop.left,curLevel+1);
            }
            if (pop.right != null){
                queue.add(pop.right);
                map.put(pop.right,curLevel+1);
            }
        }
        return max;
    }
    //    4，5
    public static void noRecursionFollow(Node root){
        if (root == null){
            return;
        }
        Stack<Node> s = new Stack<>();
        Stack<Node> assist = new Stack<>();
        s.push(root);
        while (!s.isEmpty()){
            Node pop = s.pop();
            assist.push(pop);
            if (pop.left != null){
                s.push(pop.left);
            }
            if (pop.right != null){
                s.push(pop.right);
            }
        }
        while (!assist.isEmpty()){
            System.out.print(assist.pop().val + "  ");
        }


    }
    //非递归前序遍历          3
    public static void noRecursionPre(Node root){
        if (root == null){
            return;
        }
        Stack<Node> s = new Stack<>();
        s.push(root);
        while (!s.isEmpty()){
            Node pop = s.pop();
            System.out.println(pop.val);
            if (pop.right != null){
                s.push(pop.right);
            }
            if (pop.left != null){
                s.push(pop.left);
            }
        }
    }
    //非递归中序
    //                    1，
    public static void noRecursionMid(Node root){
        if (root == null){
            return;
        }
        Stack<Node> s = new Stack<>();
        while (root != null){
            s.push(root);
            root = root.left;
        }
        while (!s.isEmpty()){
            Node pop = s.pop();
            System.out.println(pop.val);
            if (pop.right != null){
                Node right = pop.right;
                while (right != null){
                    s.push(right);
                    right = right.left;
                }
            }
        }
    }


}
class Node<V>{
    Node<V> left;
    Node<V> right;
    V val;
    public Node(V val){
        this.val = val;
    }
}

```



# 图

